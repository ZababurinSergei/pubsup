{
  "version": 3,
  "sources": ["../../../../../node_modules/it-drain/src/index.ts", "../../../../../node_modules/it-parallel/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything\n */\nfunction drain (source: Iterable<unknown>): void\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void>\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void> | void {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    })()\n  } else {\n    for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n  }\n}\n\nexport default drain\n", "/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n"],
  "mappings": ";;;;;AA6BA,SAAS,gBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAQA,SAAS,MAAO,QAAkD;AAChE,MAAI,gBAAgB,MAAM,GAAG;AAC3B,YAAQ,YAAW;AACjB,uBAAiB,KAAK,QAAQ;MAAE;IAClC,GAAE;EACJ,OAAO;AACL,eAAW,KAAK,QAAQ;IAAE;EAC5B;AACF;AAEA,IAAA,cAAe;;;ACgCf,IAAM,cAAc,WAAW,eAAe;AAe9C,gBAAO,SAAuC,QAAsE,UAA2B,CAAA,GAAE;AAC/I,MAAI,cAAc,QAAQ,eAAe;AAEzC,MAAI,cAAc,GAAG;AACnB,kBAAc;EAChB;AAEA,QAAM,UAAU,QAAQ,WAAW,OAAO,QAAQ,QAAQ;AAC1D,QAAM,UAAU,IAAI,YAAW;AAE/B,QAAM,MAA2B,CAAA;AACjC,MAAI,gBAAgB,OAAK;AACzB,MAAI,kBAAkB,OAAK;AAC3B,MAAI,iBAAiB;AACrB,MAAI;AACJ,MAAI,UAAU;AAEd,UAAQ,iBAAiB,iBAAiB,MAAK;AAC7C,oBAAgB,QAAO;EACzB,CAAC;AAED,OAAK,QAAQ,QAAO,EAAG,KAAK,YAAW;AACrC,QAAI;AACF,uBAAiB,QAAQ,QAAQ;AAC/B,YAAI,IAAI,WAAW,aAAa;AAC9B,0BAAgB,OAAK;AACrB,gBAAM,cAAc;QACtB;AAEA,YAAI,SAAS;AACX;QACF;AAEA,cAAM,KAAU;UACd,MAAM;;AAER,YAAI,KAAK,EAAE;AAEX,aAAI,EACD,KAAK,YAAS;AACb,aAAG,OAAO;AACV,aAAG,KAAK;AACR,aAAG,QAAQ;AACX,kBAAQ,cAAc,IAAI,YAAY,eAAe,CAAC;QACxD,GAAG,SAAM;AACP,aAAG,OAAO;AACV,aAAG,MAAM;AACT,kBAAQ,cAAc,IAAI,YAAY,eAAe,CAAC;QACxD,CAAC;MACL;AAEA,uBAAiB;AACjB,cAAQ,cAAc,IAAI,YAAY,eAAe,CAAC;IACxD,SAAS,KAAU;AACjB,kBAAY;AACZ,cAAQ,cAAc,IAAI,YAAY,eAAe,CAAC;IACxD;EACF,CAAC;AAED,WAAS,kBAAe;AACtB,QAAI,SAAS;AACX,aAAO,IAAI,CAAC,GAAG;IACjB;AAEA,WAAO,QAAQ,IAAI,KAAK,QAAM,GAAG,IAAI,CAAC;EACxC;AAEA,YAAW,qBAAkB;AAC3B,WAAQ,IAAI,SAAS,KAAM,IAAI,CAAC,EAAE,MAAM;AACtC,YAAM,KAAK,IAAI,CAAC;AAChB,UAAI,MAAK;AAET,UAAI,GAAG,IAAI;AACT,cAAM,GAAG;MACX,OAAO;AAEL,kBAAU;AACV,sBAAc,QAAO;AAErB,cAAM,GAAG;MACX;AAEA,oBAAc,QAAO;IACvB;EACF;AAEA,YAAW,uBAAoB;AAG7B,WAAO,gBAAe,GAAI;AACxB,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,YAAI,IAAI,CAAC,EAAE,MAAM;AACf,gBAAM,KAAK,IAAI,CAAC;AAChB,cAAI,OAAO,GAAG,CAAC;AACf;AAEA,cAAI,GAAG,IAAI;AACT,kBAAM,GAAG;UACX,OAAO;AACL,sBAAU;AACV,0BAAc,QAAO;AAErB,kBAAM,GAAG;UACX;AAEA,wBAAc,QAAO;QACvB;MACF;IACF;EACF;AAEA,SAAO,MAAM;AACX,QAAI,CAAC,gBAAe,GAAI;AACtB,wBAAkB,OAAK;AACvB,YAAM,gBAAgB;IACxB;AAEA,QAAI,aAAa,MAAM;AAErB,YAAM;IACR;AAEA,QAAI,SAAS;AACX,aAAQ,mBAAkB;IAC5B,OAAO;AACL,aAAQ,qBAAoB;IAC9B;AAEA,QAAI,kBAAkB,IAAI,WAAW,GAAG;AAEtC;IACF;EACF;AACF;",
  "names": []
}
