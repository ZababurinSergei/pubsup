{
  "version": 3,
  "sources": ["../../../../../../../node_modules/@libp2p/identify/src/consts.ts", "../../../../../../../node_modules/@libp2p/identify/src/pb/message.ts", "../../../../../../../node_modules/@libp2p/identify/src/utils.ts", "../../../../../../../node_modules/@libp2p/identify/src/identify-push.ts", "../../../../../../../node_modules/@libp2p/identify/src/identify.ts", "../../../../../../../node_modules/@libp2p/identify/src/index.ts"],
  "sourcesContent": ["export const PROTOCOL_VERSION = 'ipfs/0.1.0' // deprecated\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0' // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0' // deprecated\n\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0'\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nexport const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\n// https://github.com/libp2p/go-libp2p/blob/0385ec924bad172f74a74db09939e97c079b1420/p2p/protocol/identify/id.go#L47C7-L47C25\nexport const MAX_PUSH_CONCURRENCY = 32\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string()\n              break\n            case 6:\n              obj.agentVersion = reader.string()\n              break\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.listenAddrs.push(reader.bytes())\n              break\n            case 4:\n              obj.observedAddr = reader.bytes()\n              break\n            case 3:\n              obj.protocols.push(reader.string())\n              break\n            case 8:\n              obj.signedPeerRecord = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Identify>): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Identify => {\n    return decodeMessage(buf, Identify.codec())\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { isNode, isBrowser, isWebWorker, isElectronMain, isElectronRenderer, isReactNative } from 'wherearewe'\nimport { IDENTIFY_PROTOCOL_VERSION, MAX_IDENTIFY_MESSAGE_SIZE, MAX_PUSH_CONCURRENCY } from './consts.js'\nimport type { IdentifyComponents, IdentifyInit } from './index.js'\nimport type { Identify as IdentifyMessage } from './pb/message.js'\nimport type { Libp2pEvents, IdentifyResult, SignedPeerRecord, Logger, Connection, TypedEventTarget, Peer, PeerData, PeerStore, NodeInfo, Startable, PeerId, IncomingStreamData } from '@libp2p/interface'\nimport type { AddressManager, Registrar } from '@libp2p/interface-internal'\n\nexport const defaultValues = {\n  protocolPrefix: 'ipfs',\n  timeout: 5000,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1,\n  maxObservedAddresses: 10,\n  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,\n  runOnConnectionOpen: true,\n  runOnSelfUpdate: true,\n  runOnTransientConnection: true,\n  concurrency: MAX_PUSH_CONCURRENCY\n}\n\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nexport function getCleanMultiaddr (addr: Uint8Array | string | null | undefined): Multiaddr | undefined {\n  if (addr != null && addr.length > 0) {\n    try {\n      return multiaddr(addr)\n    } catch {\n\n    }\n  }\n}\n\nexport function getAgentVersion (nodeInfo: NodeInfo, agentVersion?: string): string {\n  if (agentVersion != null) {\n    return agentVersion\n  }\n\n  agentVersion = `${nodeInfo.name}/${nodeInfo.version}`\n  // Append user agent version to default AGENT_VERSION depending on the environment\n  if (isNode || isElectronMain) {\n    agentVersion += ` UserAgent=${globalThis.process.version}`\n  } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {\n    agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`\n  }\n\n  return agentVersion\n}\n\nexport async function consumeIdentifyMessage (peerStore: PeerStore, events: TypedEventTarget<Libp2pEvents>, log: Logger, connection: Connection, message: IdentifyMessage): Promise<IdentifyResult> {\n  log('received identify from %p', connection.remotePeer)\n\n  if (message == null) {\n    throw new CodeError('message was null or undefined', 'ERR_INVALID_MESSAGE')\n  }\n\n  const peer: PeerData = {}\n\n  if (message.listenAddrs.length > 0) {\n    peer.addresses = message.listenAddrs.map(buf => ({\n      isCertified: false,\n      multiaddr: multiaddr(buf)\n    }))\n  }\n\n  if (message.protocols.length > 0) {\n    peer.protocols = message.protocols\n  }\n\n  if (message.publicKey != null) {\n    peer.publicKey = message.publicKey\n\n    const peerId = await peerIdFromKeys(message.publicKey)\n\n    if (!peerId.equals(connection.remotePeer)) {\n      throw new CodeError('public key did not match remote PeerId', 'ERR_INVALID_PUBLIC_KEY')\n    }\n  }\n\n  let output: SignedPeerRecord | undefined\n\n  // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n  if (message.signedPeerRecord != null) {\n    log('received signedPeerRecord from %p', connection.remotePeer)\n\n    let peerRecordEnvelope = message.signedPeerRecord\n    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN)\n    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n\n    // Verify peerId\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      throw new CodeError('signing key does not match PeerId in the PeerRecord', 'ERR_INVALID_SIGNING_KEY')\n    }\n\n    // Make sure remote peer is the one sending the record\n    if (!connection.remotePeer.equals(peerRecord.peerId)) {\n      throw new CodeError('signing key does not match remote PeerId', 'ERR_INVALID_PEER_RECORD_KEY')\n    }\n\n    let existingPeer: Peer | undefined\n\n    try {\n      existingPeer = await peerStore.get(peerRecord.peerId)\n    } catch (err: any) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    if (existingPeer != null) {\n      // don't lose any existing metadata\n      peer.metadata = existingPeer.metadata\n\n      // if we have previously received a signed record for this peer, compare it to the incoming one\n      if (existingPeer.peerRecordEnvelope != null) {\n        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope)\n        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n        // ensure seq is greater than, or equal to, the last received\n        if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n          log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n          peerRecord = storedRecord\n          peerRecordEnvelope = existingPeer.peerRecordEnvelope\n        }\n      }\n    }\n\n    // store the signed record for next time\n    peer.peerRecordEnvelope = peerRecordEnvelope\n\n    // override the stored addresses with the signed multiaddrs\n    peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n      isCertified: true,\n      multiaddr\n    }))\n\n    output = {\n      seq: peerRecord.seqNumber,\n      addresses: peerRecord.multiaddrs\n    }\n  } else {\n    log('%p did not send a signed peer record', connection.remotePeer)\n  }\n\n  log('patching %p with', connection.remotePeer, peer)\n  await peerStore.patch(connection.remotePeer, peer)\n\n  if (message.agentVersion != null || message.protocolVersion != null) {\n    const metadata: Record<string, Uint8Array> = {}\n\n    if (message.agentVersion != null) {\n      metadata.AgentVersion = uint8ArrayFromString(message.agentVersion)\n    }\n\n    if (message.protocolVersion != null) {\n      metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion)\n    }\n\n    log('merging %p metadata', connection.remotePeer, metadata)\n    await peerStore.merge(connection.remotePeer, {\n      metadata\n    })\n  }\n\n  const result: IdentifyResult = {\n    peerId: connection.remotePeer,\n    protocolVersion: message.protocolVersion,\n    agentVersion: message.agentVersion,\n    publicKey: message.publicKey,\n    listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n    observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n    protocols: message.protocols,\n    signedPeerRecord: output,\n    connection\n  }\n\n  events.safeDispatchEvent('peer:identify', { detail: result })\n\n  return result\n}\n\nexport interface AbstractIdentifyInit extends IdentifyInit {\n  protocol: string\n  log: Logger\n}\n\nexport abstract class AbstractIdentify implements Startable {\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  protected protocol: string\n  protected started: boolean\n  protected readonly timeout: number\n  protected readonly peerId: PeerId\n  protected readonly peerStore: PeerStore\n  protected readonly registrar: Registrar\n  protected readonly addressManager: AddressManager\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  protected readonly maxMessageSize: number\n  protected readonly maxObservedAddresses: number\n  protected readonly events: TypedEventTarget<Libp2pEvents>\n  protected readonly runOnTransientConnection: boolean\n  protected readonly log: Logger\n\n  constructor (components: IdentifyComponents, init: AbstractIdentifyInit) {\n    this.protocol = init.protocol\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.addressManager = components.addressManager\n    this.events = components.events\n    this.log = init.log\n\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.peerStore.merge(this.peerId, {\n      metadata: {\n        AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n        ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n      }\n    })\n\n    await this.registrar.handle(this.protocol, (data) => {\n      void this.handleProtocol(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.registrar.unhandle(this.protocol)\n\n    this.started = false\n  }\n\n  protected abstract handleProtocol (data: IncomingStreamData): Promise<void>\n}\n", "/* eslint-disable complexity */\n\nimport { serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { protocols } from '@multiformats/multiaddr'\nimport drain from 'it-drain'\nimport parallel from 'it-parallel'\nimport { pbStream } from 'it-protobuf-stream'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport {\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues } from './utils.js'\nimport type { IdentifyPush as IdentifyPushInterface, IdentifyPushComponents, IdentifyPushInit } from './index.js'\nimport type { Stream, Startable } from '@libp2p/interface'\nimport type { ConnectionManager, IncomingStreamData } from '@libp2p/interface-internal'\n\nexport class IdentifyPush extends AbstractIdentify implements Startable, IdentifyPushInterface {\n  private readonly connectionManager: ConnectionManager\n  private readonly concurrency: number\n\n  constructor (components: IdentifyPushComponents, init: IdentifyPushInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify-push')\n    })\n\n    this.connectionManager = components.connectionManager\n    this.concurrency = init.concurrency ?? defaultValues.concurrency\n\n    if ((init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate)) {\n      // When self peer record changes, trigger identify-push\n      components.events.addEventListener('self:peer:update', (evt) => {\n        void this.push().catch(err => { this.log.error(err) })\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify-push'\n  ]\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async push (): Promise<void> {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n    const peerRecord = new PeerRecord({\n      peerId: this.peerId,\n      multiaddrs: listenAddresses\n    })\n    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId)\n    const supportedProtocols = this.registrar.getProtocols()\n    const peer = await this.peerStore.get(this.peerId)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion))\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion))\n    const self = this\n\n    async function * pushToConnections (): AsyncGenerator<() => Promise<void>> {\n      for (const connection of self.connectionManager.getConnections()) {\n        const peer = await self.peerStore.get(connection.remotePeer)\n\n        if (!peer.protocols.includes(self.protocol)) {\n          continue\n        }\n\n        yield async () => {\n          let stream: Stream | undefined\n          const signal = AbortSignal.timeout(self.timeout)\n\n          setMaxListeners(Infinity, signal)\n\n          try {\n            stream = await connection.newStream(self.protocol, {\n              signal,\n              runOnTransientConnection: self.runOnTransientConnection\n            })\n\n            const pb = pbStream(stream, {\n              maxDataLength: self.maxMessageSize\n            }).pb(IdentifyMessage)\n\n            await pb.write({\n              listenAddrs: listenAddresses.map(ma => ma.bytes),\n              signedPeerRecord: signedPeerRecord.marshal(),\n              protocols: supportedProtocols,\n              agentVersion,\n              protocolVersion\n            }, {\n              signal\n            })\n\n            await stream.close({\n              signal\n            })\n          } catch (err: any) {\n            // Just log errors\n            self.log.error('could not push identify update to peer', err)\n            stream?.abort(err)\n          }\n        }\n      }\n    }\n\n    await drain(parallel(pushToConnections(), {\n      concurrency: this.concurrency\n    }))\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async handleProtocol (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    try {\n      if (this.peerId.equals(connection.remotePeer)) {\n        throw new Error('received push from ourselves?')\n      }\n\n      const options = {\n        signal: AbortSignal.timeout(this.timeout)\n      }\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxMessageSize\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n      await stream.close(options)\n\n      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message)\n    } catch (err: any) {\n      this.log.error('received invalid message', err)\n      stream.abort(err)\n      return\n    }\n\n    this.log('handled push from %p', connection.remotePeer)\n  }\n}\n", "/* eslint-disable complexity */\n\nimport { CodeError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { protocols } from '@multiformats/multiaddr'\nimport { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\nimport { pbStream } from 'it-protobuf-stream'\nimport {\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport { AbstractIdentify, consumeIdentifyMessage, defaultValues, getCleanMultiaddr } from './utils.js'\nimport type { Identify as IdentifyInterface, IdentifyComponents, IdentifyInit } from './index.js'\nimport type { IdentifyResult, AbortOptions, Connection, Stream, Startable } from '@libp2p/interface'\nimport type { IncomingStreamData } from '@libp2p/interface-internal'\n\nexport class Identify extends AbstractIdentify implements Startable, IdentifyInterface {\n  constructor (components: IdentifyComponents, init: IdentifyInit = {}) {\n    super(components, {\n      ...init,\n      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,\n      log: components.logger.forComponent('libp2p:identify')\n    })\n\n    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n      // When a new connection happens, trigger identify\n      components.events.addEventListener('connection:open', (evt) => {\n        const connection = evt.detail\n        this.identify(connection).catch(err => { this.log.error('error during identify trigged by connection:open', err) })\n      })\n    }\n  }\n\n  [serviceCapabilities]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyMessage> {\n    let stream: Stream | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream(this.protocol, {\n        ...options,\n        runOnTransientConnection: this.runOnTransientConnection\n      })\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxMessageSize\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n\n      await stream.close(options)\n\n      return message\n    } catch (err: any) {\n      this.log.error('error while reading identify message', err)\n      stream?.abort(err)\n      throw err\n    }\n  }\n\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyResult> {\n    const message = await this._identify(connection, options)\n    const {\n      publicKey,\n      protocols,\n      observedAddr\n    } = message\n\n    if (publicKey == null) {\n      throw new CodeError('public key was missing from identify message', 'ERR_MISSING_PUBLIC_KEY')\n    }\n\n    const id = await peerIdFromKeys(publicKey)\n\n    if (!connection.remotePeer.equals(id)) {\n      throw new CodeError('identified peer does not match the expected peer', 'ERR_INVALID_PEER')\n    }\n\n    if (this.peerId.equals(id)) {\n      throw new CodeError('identified peer is our own peer id?', 'ERR_INVALID_PEER')\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = getCleanMultiaddr(observedAddr)\n\n    this.log('identify completed for peer %p and protocols %o', id, protocols)\n    this.log('our observed address is %a', cleanObservedAddr)\n\n    if (cleanObservedAddr != null &&\n        this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {\n      this.log('storing our observed address %a', cleanObservedAddr)\n      this.addressManager.addObservedAddr(cleanObservedAddr)\n    }\n\n    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async handleProtocol (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    const signal = AbortSignal.timeout(this.timeout)\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      const publicKey = this.peerId.publicKey ?? new Uint8Array(0)\n      const peerData = await this.peerStore.get(this.peerId)\n      const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.peerId,\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      let observedAddr: Uint8Array | undefined = connection.remoteAddr.bytes\n\n      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n        observedAddr = undefined\n      }\n\n      const pb = pbStream(stream).pb(IdentifyMessage)\n\n      await pb.write({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr,\n        protocols: peerData.protocols\n      }, {\n        signal\n      })\n\n      await stream.close({\n        signal\n      })\n    } catch (err: any) {\n      this.log.error('could not respond to identify request', err)\n      stream.abort(err)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.\n *\n * This protocol allows network peers to discover the multiaddrs the current node listens on, and the protocols it supports.\n *\n * A second function, `identifyPush` is also exported to add support for [identify/push](https://github.com/libp2p/specs/blob/master/identify/README.md#identifypush).\n *\n * This protocol will send updates to all connected peers when the multiaddrs or protocols of the current node change.\n *\n * > [!TIP]\n * > For maximum network compatibility you should configure both protocols\n *\n * @example Enabling identify\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identify } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identify: identify()\n *   }\n * })\n * ```\n *\n * @example Enabling identify push\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identifyPush } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identifyPush: identifyPush()\n *   }\n * })\n * ```\n */\n\nimport { IdentifyPush as IdentifyPushClass } from './identify-push.js'\nimport { Identify as IdentifyClass } from './identify.js'\nimport type { AbortOptions, IdentifyResult, Libp2pEvents, ComponentLogger, NodeInfo, TypedEventTarget, PeerId, PeerStore, Connection } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\nexport interface IdentifyInit {\n  /**\n   * The prefix to use for the protocol\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n\n  /**\n   * What details we should send as part of an identify message\n   */\n  agentVersion?: string\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   *\n   * @default 5000\n   */\n  timeout?: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected\n   *\n   * @default 8192\n   */\n  maxMessageSize?: number\n\n  /**\n   * The maximum number of inbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxInboundStreams?: number\n\n  /**\n   * The maximum number of outbound streams that may be open on a single\n   * connection for this protocol\n   *\n   * @default 1\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * The maximum number of observed addresses to send in an Identify message\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * Whether to run on connections with data or duration limits\n   *\n   * @default true\n   */\n  runOnTransientConnection?: boolean\n\n  /**\n   * Whether to automatically run identify on newly opened connections\n   *\n   * @default true\n   */\n  runOnConnectionOpen?: boolean\n}\n\nexport interface IdentifyPushInit extends Omit<IdentifyInit, 'runOnConnectionOpen'> {\n  /**\n   * Whether to automatically dial identify-push on self updates\n   *\n   * @default true\n   */\n  runOnSelfUpdate?: boolean\n\n  /**\n   * Push to this many connections in parallel\n   *\n   * @default 32\n   */\n  concurrency?: number\n}\n\nexport interface IdentifyComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  addressManager: AddressManager\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  nodeInfo: NodeInfo\n}\n\nexport interface IdentifyPushComponents extends IdentifyComponents {\n  connectionManager: ConnectionManager\n}\n\nexport interface Identify {\n  /**\n   * due to the default limits on inbound/outbound streams for this protocol,\n   * invoking this method when runOnConnectionOpen is true can lead to unpredictable results\n   * as streams may be closed by the local or the remote node.\n   * Please use with caution. If you find yourself needing to call this method to discover other peers that support your protocol,\n   * you may be better off configuring a topology to be notified instead.\n   */\n  identify(connection: Connection, options?: AbortOptions): Promise<IdentifyResult>\n}\n\nexport interface IdentifyPush {\n  push(): Promise<void>\n}\n\nexport function identify (init: IdentifyInit = {}): (components: IdentifyComponents) => Identify {\n  return (components) => new IdentifyClass(components, init)\n}\n\nexport function identifyPush (init: IdentifyPushInit = {}): (components: IdentifyPushComponents) => IdentifyPush {\n  return (components) => new IdentifyPushClass(components, init)\n}\n"],
  "mappings": "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",
  "names": ["Identify", "message", "multiaddr", "peer", "message", "Identify", "message", "Identify"]
}
