// ../../node_modules/@libp2p/interface/dist/src/pubsub/index.js
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));

// ../../node_modules/@libp2p/interface/dist/src/transport/index.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// ../../node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class _AbortError extends Error {
  code;
  type;
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
    this.code = _AbortError.code;
    this.type = _AbortError.type;
  }
  static code = "ABORT_ERR";
  static type = "aborted";
};
var CodeError = class extends Error {
  code;
  props;
  constructor(message, code, props) {
    super(message);
    this.code = code;
    this.name = props?.name ?? "CodeError";
    this.props = props ?? {};
  }
};
var AggregateCodeError = class extends AggregateError {
  code;
  props;
  constructor(errors, message, code, props) {
    super(errors, message);
    this.code = code;
    this.name = props?.name ?? "AggregateCodeError";
    this.props = props ?? {};
  }
};
var ERR_TIMEOUT = "ERR_TIMEOUT";
var ERR_INVALID_MESSAGE = "ERR_INVALID_MESSAGE";

// ../../node_modules/@libp2p/interface/dist/src/events.browser.js
function setMaxListeners() {
}

// ../../node_modules/@libp2p/interface/dist/src/events.js
var setMaxListeners2 = (n, ...eventTargets) => {
  try {
    setMaxListeners(n, ...eventTargets);
  } catch {
  }
};

// ../../node_modules/@libp2p/interface/dist/src/event-target.js
var TypedEventEmitter = class extends EventTarget {
  #listeners = /* @__PURE__ */ new Map();
  constructor() {
    super();
    setMaxListeners2(Infinity, this);
  }
  listenerCount(type) {
    const listeners = this.#listeners.get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      list = [];
      this.#listeners.set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    this.#listeners.set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = this.#listeners.get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    this.#listeners.set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
var CustomEvent = globalThis.CustomEvent;

// ../../node_modules/@libp2p/interface/dist/src/connection/index.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// ../../node_modules/@libp2p/interface/dist/src/content-routing/index.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// ../../node_modules/@libp2p/interface/dist/src/peer-discovery/index.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// ../../node_modules/@libp2p/interface/dist/src/peer-id/index.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[peerIdSymbol]);
}

// ../../node_modules/@libp2p/interface/dist/src/peer-routing/index.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// ../../node_modules/@libp2p/interface/dist/src/peer-store/tags.js
var KEEP_ALIVE = "keep-alive";

// ../../node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStart != null) {
      await s.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.start();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStart != null) {
      await s.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStop != null) {
      await s.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.stop();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStop != null) {
      await s.afterStop();
    }
  }));
}

// ../../node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

export {
  connectionSymbol,
  contentRoutingSymbol,
  peerDiscoverySymbol,
  peerIdSymbol,
  isPeerId,
  peerRoutingSymbol,
  KEEP_ALIVE,
  StrictSign,
  StrictNoSign,
  TopicValidatorResult,
  transportSymbol,
  FaultTolerance,
  AbortError,
  CodeError,
  AggregateCodeError,
  ERR_TIMEOUT,
  ERR_INVALID_MESSAGE,
  setMaxListeners2 as setMaxListeners,
  TypedEventEmitter,
  CustomEvent,
  isStartable,
  start,
  stop,
  serviceCapabilities,
  serviceDependencies
};
//# sourceMappingURL=chunk-EZU2LKBL.js.map
