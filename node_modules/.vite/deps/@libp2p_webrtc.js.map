{
  "version": 3,
  "sources": ["../../../../../../../node_modules/@libp2p/webrtc/src/error.ts", "../../../../../../../node_modules/detect-browser/es/index.js", "../../../../../../../node_modules/@libp2p/webrtc/src/constants.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/util.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/maconn.ts", "../../../../../../../node_modules/p-event/index.js", "../../../../../../../node_modules/@libp2p/webrtc/src/pb/message.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/stream.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/muxer.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/webrtc/index.browser.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/pb/message.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/util.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/initiate-connection.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/listener.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/signaling-stream-handler.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-private/transport.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-public/sdp.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-public/util.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/private-to-public/transport.ts", "../../../../../../../node_modules/@libp2p/webrtc/src/index.ts"],
  "sourcesContent": ["import { CodeError } from '@libp2p/interface'\nimport type { Direction } from '@libp2p/interface'\n\nexport enum codes {\n  ERR_ALREADY_ABORTED = 'ERR_ALREADY_ABORTED',\n  ERR_DATA_CHANNEL = 'ERR_DATA_CHANNEL',\n  ERR_CONNECTION_CLOSED = 'ERR_CONNECTION_CLOSED',\n  ERR_HASH_NOT_SUPPORTED = 'ERR_HASH_NOT_SUPPORTED',\n  ERR_INVALID_MULTIADDR = 'ERR_INVALID_MULTIADDR',\n  ERR_INVALID_FINGERPRINT = 'ERR_INVALID_FINGERPRINT',\n  ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS',\n  ERR_NOT_IMPLEMENTED = 'ERR_NOT_IMPLEMENTED',\n  ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS',\n  ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS',\n}\n\nexport class WebRTCTransportError extends CodeError {\n  constructor (msg: string, code?: string) {\n    super(`WebRTC transport error: ${msg}`, code ?? '')\n    this.name = 'WebRTCTransportError'\n  }\n}\n\nexport class ConnectionClosedError extends WebRTCTransportError {\n  constructor (state: RTCPeerConnectionState, msg: string) {\n    super(`peerconnection moved to state: ${state}: ${msg}`, codes.ERR_CONNECTION_CLOSED)\n    this.name = 'WebRTC/ConnectionClosed'\n  }\n}\n\nexport function connectionClosedError (state: RTCPeerConnectionState, msg: string): ConnectionClosedError {\n  return new ConnectionClosedError(state, msg)\n}\n\nexport class DataChannelError extends WebRTCTransportError {\n  constructor (streamLabel: string, msg: string) {\n    super(`[stream: ${streamLabel}] data channel error: ${msg}`, codes.ERR_DATA_CHANNEL)\n    this.name = 'WebRTC/DataChannelError'\n  }\n}\n\nexport function dataChannelError (streamLabel: string, msg: string): DataChannelError {\n  return new DataChannelError(streamLabel, msg)\n}\n\nexport class InappropriateMultiaddrError extends WebRTCTransportError {\n  constructor (msg: string) {\n    super(`There was a problem with the Multiaddr which was passed in: ${msg}`, codes.ERR_INVALID_MULTIADDR)\n    this.name = 'WebRTC/InappropriateMultiaddrError'\n  }\n}\n\nexport function inappropriateMultiaddr (msg: string): InappropriateMultiaddrError {\n  return new InappropriateMultiaddrError(msg)\n}\n\nexport class InvalidArgumentError extends WebRTCTransportError {\n  constructor (msg: string) {\n    super(`There was a problem with a provided argument: ${msg}`, codes.ERR_INVALID_PARAMETERS)\n    this.name = 'WebRTC/InvalidArgumentError'\n  }\n}\n\nexport function invalidArgument (msg: string): InvalidArgumentError {\n  return new InvalidArgumentError(msg)\n}\n\nexport class InvalidFingerprintError extends WebRTCTransportError {\n  constructor (fingerprint: string, source: string) {\n    super(`Invalid fingerprint \"${fingerprint}\" within ${source}`, codes.ERR_INVALID_FINGERPRINT)\n    this.name = 'WebRTC/InvalidFingerprintError'\n  }\n}\n\nexport function invalidFingerprint (fingerprint: string, source: string): InvalidFingerprintError {\n  return new InvalidFingerprintError(fingerprint, source)\n}\n\nexport class OperationAbortedError extends WebRTCTransportError {\n  constructor (context: string, abortReason: string) {\n    super(`Signalled to abort because (${abortReason}}) ${context}`, codes.ERR_ALREADY_ABORTED)\n    this.name = 'WebRTC/OperationAbortedError'\n  }\n}\n\nexport function operationAborted (context: string, reason: string): OperationAbortedError {\n  return new OperationAbortedError(context, reason)\n}\n\nexport class OverStreamLimitError extends WebRTCTransportError {\n  constructor (msg: string) {\n    const code = msg.startsWith('inbound') ? codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS : codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS\n    super(msg, code)\n    this.name = 'WebRTC/OverStreamLimitError'\n  }\n}\n\nexport function overStreamLimit (dir: Direction, proto: string): OverStreamLimitError {\n  return new OverStreamLimitError(`${dir} stream limit reached for protocol - ${proto}`)\n}\n\nexport class UnimplementedError extends WebRTCTransportError {\n  constructor (methodName: string) {\n    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`, codes.ERR_NOT_IMPLEMENTED)\n    this.name = 'WebRTC/UnimplementedError'\n  }\n}\n\nexport function unimplemented (methodName: string): UnimplementedError {\n  return new UnimplementedError(methodName)\n}\n\nexport class UnsupportedHashAlgorithmError extends WebRTCTransportError {\n  constructor (algo: number) {\n    super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `, codes.ERR_HASH_NOT_SUPPORTED)\n    this.name = 'WebRTC/UnsupportedHashAlgorithmError'\n  }\n}\n\nexport function unsupportedHashAlgorithmCode (code: number): UnsupportedHashAlgorithmError {\n  return new UnsupportedHashAlgorithmError(code)\n}\n", "var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar BrowserInfo = /** @class */ (function () {\n    function BrowserInfo(name, version, os) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.type = 'browser';\n    }\n    return BrowserInfo;\n}());\nexport { BrowserInfo };\nvar NodeInfo = /** @class */ (function () {\n    function NodeInfo(version) {\n        this.version = version;\n        this.type = 'node';\n        this.name = 'node';\n        this.os = process.platform;\n    }\n    return NodeInfo;\n}());\nexport { NodeInfo };\nvar SearchBotDeviceInfo = /** @class */ (function () {\n    function SearchBotDeviceInfo(name, version, os, bot) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.bot = bot;\n        this.type = 'bot-device';\n    }\n    return SearchBotDeviceInfo;\n}());\nexport { SearchBotDeviceInfo };\nvar BotInfo = /** @class */ (function () {\n    function BotInfo() {\n        this.type = 'bot';\n        this.bot = true; // NOTE: deprecated test name instead\n        this.name = 'bot';\n        this.version = null;\n        this.os = null;\n    }\n    return BotInfo;\n}());\nexport { BotInfo };\nvar ReactNativeInfo = /** @class */ (function () {\n    function ReactNativeInfo() {\n        this.type = 'react-native';\n        this.name = 'react-native';\n        this.version = null;\n        this.os = null;\n    }\n    return ReactNativeInfo;\n}());\nexport { ReactNativeInfo };\n// tslint:disable-next-line:max-line-length\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n    ['aol', /AOLShield\\/([0-9\\._]+)/],\n    ['edge', /Edge\\/([0-9\\._]+)/],\n    ['edge-ios', /EdgiOS\\/([0-9\\._]+)/],\n    ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/],\n    ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/],\n    ['samsung', /SamsungBrowser\\/([0-9\\.]+)/],\n    ['silk', /\\bSilk\\/([0-9._-]+)\\b/],\n    ['miui', /MiuiBrowser\\/([0-9\\.]+)$/],\n    ['beaker', /BeakerBrowser\\/([0-9\\.]+)/],\n    ['edge-chromium', /EdgA?\\/([0-9\\.]+)/],\n    [\n        'chromium-webview',\n        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/,\n    ],\n    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n    ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n    ['fxios', /FxiOS\\/([0-9\\.]+)/],\n    ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/],\n    ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n    ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n    ['pie', /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/],\n    ['pie', /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/],\n    ['netfront', /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/],\n    ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n    ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n    ['ie', /MSIE\\s(7\\.0)/],\n    ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n    ['android', /Android\\s([0-9\\.]+)/],\n    ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n    ['safari', /Version\\/([0-9\\._]+).*Safari/],\n    ['facebook', /FB[AS]V\\/([0-9\\.]+)/],\n    ['instagram', /Instagram\\s([0-9\\.]+)/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n    ['curl', /^curl\\/([0-9\\.]+)$/],\n    ['searchbot', SEARCHBOX_UA_REGEX],\n];\nvar operatingSystemRules = [\n    ['iOS', /iP(hone|od|ad)/],\n    ['Android OS', /Android/],\n    ['BlackBerry OS', /BlackBerry|BB10/],\n    ['Windows Mobile', /IEMobile/],\n    ['Amazon OS', /Kindle/],\n    ['Windows 3.11', /Win16/],\n    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],\n    ['Windows 98', /(Windows 98)|(Win98)/],\n    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],\n    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],\n    ['Windows Server 2003', /(Windows NT 5.2)/],\n    ['Windows Vista', /(Windows NT 6.0)/],\n    ['Windows 7', /(Windows NT 6.1)/],\n    ['Windows 8', /(Windows NT 6.2)/],\n    ['Windows 8.1', /(Windows NT 6.3)/],\n    ['Windows 10', /(Windows NT 10.0)/],\n    ['Windows ME', /Windows ME/],\n    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],\n    ['Open BSD', /OpenBSD/],\n    ['Sun OS', /SunOS/],\n    ['Chrome OS', /CrOS/],\n    ['Linux', /(Linux)|(X11)/],\n    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],\n    ['QNX', /QNX/],\n    ['BeOS', /BeOS/],\n    ['OS/2', /OS\\/2/],\n];\nexport function detect(userAgent) {\n    if (!!userAgent) {\n        return parseUserAgent(userAgent);\n    }\n    if (typeof document === 'undefined' &&\n        typeof navigator !== 'undefined' &&\n        navigator.product === 'ReactNative') {\n        return new ReactNativeInfo();\n    }\n    if (typeof navigator !== 'undefined') {\n        return parseUserAgent(navigator.userAgent);\n    }\n    return getNodeVersion();\n}\nfunction matchUserAgent(ua) {\n    // opted for using reduce here rather than Array#first with a regex.test call\n    // this is primarily because using the reduce we only perform the regex\n    // execution once rather than once for the test and for the exec again below\n    // probably something that needs to be benchmarked though\n    return (ua !== '' &&\n        userAgentRules.reduce(function (matched, _a) {\n            var browser = _a[0], regex = _a[1];\n            if (matched) {\n                return matched;\n            }\n            var uaMatch = regex.exec(ua);\n            return !!uaMatch && [browser, uaMatch];\n        }, false));\n}\nexport function browserName(ua) {\n    var data = matchUserAgent(ua);\n    return data ? data[0] : null;\n}\nexport function parseUserAgent(ua) {\n    var matchedRule = matchUserAgent(ua);\n    if (!matchedRule) {\n        return null;\n    }\n    var name = matchedRule[0], match = matchedRule[1];\n    if (name === 'searchbot') {\n        return new BotInfo();\n    }\n    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)\n    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);\n    if (versionParts) {\n        if (versionParts.length < REQUIRED_VERSION_PARTS) {\n            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);\n        }\n    }\n    else {\n        versionParts = [];\n    }\n    var version = versionParts.join('.');\n    var os = detectOS(ua);\n    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n    if (searchBotMatch && searchBotMatch[1]) {\n        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);\n    }\n    return new BrowserInfo(name, version, os);\n}\nexport function detectOS(ua) {\n    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n        var match = regex.exec(ua);\n        if (match) {\n            return os;\n        }\n    }\n    return null;\n}\nexport function getNodeVersion() {\n    var isNode = typeof process !== 'undefined' && process.version;\n    return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nfunction createVersionParts(count) {\n    var output = [];\n    for (var ii = 0; ii < count; ii++) {\n        output.push('0');\n    }\n    return output;\n}\n", "/**\n * STUN servers help clients discover their own public IPs.\n *\n * Using five or more servers causes warnings to be printed so\n * ensure we limit it to max x4\n *\n * @see https://gist.github.com/mondain/b0ec1cf5f60ae726202e\n */\nexport const DEFAULT_ICE_SERVERS = [\n  'stun:stun.l.google.com:19302',\n  'stun:global.stun.twilio.com:3478',\n  'stun:stun.cloudflare.com:3478',\n  'stun:stun.services.mozilla.com:3478'\n]\n", "import { detect } from 'detect-browser'\nimport pDefer from 'p-defer'\nimport pTimeout from 'p-timeout'\nimport { DEFAULT_ICE_SERVERS } from './constants.js'\nimport type { LoggerOptions } from '@libp2p/interface'\n\nconst browser = detect()\nexport const isFirefox = ((browser != null) && browser.name === 'firefox')\n\nexport const nopSource = async function * nop (): AsyncGenerator<Uint8Array, any, unknown> {}\n\nexport const nopSink = async (_: any): Promise<void> => {}\n\nexport const DATA_CHANNEL_DRAIN_TIMEOUT = 30 * 1000\n\nexport function drainAndClose (channel: RTCDataChannel, direction: string, drainTimeout: number = DATA_CHANNEL_DRAIN_TIMEOUT, options: LoggerOptions): void {\n  if (channel.readyState !== 'open') {\n    return\n  }\n\n  void Promise.resolve()\n    .then(async () => {\n      // wait for bufferedAmount to become zero\n      if (channel.bufferedAmount > 0) {\n        options.log('%s drain channel with %d buffered bytes', direction, channel.bufferedAmount)\n        const deferred = pDefer()\n        let drained = false\n\n        channel.bufferedAmountLowThreshold = 0\n\n        const closeListener = (): void => {\n          if (!drained) {\n            options.log('%s drain channel closed before drain', direction)\n            deferred.resolve()\n          }\n        }\n\n        channel.addEventListener('close', closeListener, {\n          once: true\n        })\n\n        channel.addEventListener('bufferedamountlow', () => {\n          drained = true\n          channel.removeEventListener('close', closeListener)\n          deferred.resolve()\n        })\n\n        await pTimeout(deferred.promise, {\n          milliseconds: drainTimeout\n        })\n      }\n    })\n    .then(async () => {\n      // only close if the channel is still open\n      if (channel.readyState === 'open') {\n        channel.close()\n      }\n    })\n    .catch(err => {\n      options.log.error('error closing outbound stream', err)\n    })\n}\n\nexport interface AbortPromiseOptions {\n  signal?: AbortSignal\n  message?: string\n}\n\nexport async function getRtcConfiguration (config?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>)): Promise<RTCConfiguration> {\n  config = config ?? {}\n\n  if (typeof config === 'function') {\n    config = await config()\n  }\n\n  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map(url => ({\n    urls: [\n      url\n    ]\n  }))\n\n  return config\n}\n", "import { nopSink, nopSource } from './util.js'\nimport type { ComponentLogger, Logger, MultiaddrConnection, MultiaddrConnectionTimeline, CounterGroup } from '@libp2p/interface'\nimport type { AbortOptions, Multiaddr } from '@multiformats/multiaddr'\nimport type { Source, Sink } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ninterface WebRTCMultiaddrConnectionInit {\n  /**\n   * WebRTC Peer Connection\n   */\n  peerConnection: RTCPeerConnection\n\n  /**\n   * The multiaddr address used to communicate with the remote peer\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * Holds the relevant events timestamps of the connection\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * Optional metrics counter group for this connection\n   */\n  metrics?: CounterGroup\n}\n\nexport interface WebRTCMultiaddrConnectionComponents {\n  logger: ComponentLogger\n}\n\nexport class WebRTCMultiaddrConnection implements MultiaddrConnection {\n  readonly log: Logger\n\n  /**\n   * WebRTC Peer Connection\n   */\n  readonly peerConnection: RTCPeerConnection\n\n  /**\n   * The multiaddr address used to communicate with the remote peer\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * Holds the lifecycle times of the connection\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * Optional metrics counter group for this connection\n   */\n  metrics?: CounterGroup\n\n  /**\n   * The stream source, a no-op as the transport natively supports multiplexing\n   */\n  source: AsyncGenerator<Uint8Array, any, unknown> = nopSource()\n\n  /**\n   * The stream destination, a no-op as the transport natively supports multiplexing\n   */\n  sink: Sink<Source<Uint8Array | Uint8ArrayList>, Promise<void>> = nopSink\n\n  constructor (components: WebRTCMultiaddrConnectionComponents, init: WebRTCMultiaddrConnectionInit) {\n    this.log = components.logger.forComponent('libp2p:webrtc:maconn')\n    this.remoteAddr = init.remoteAddr\n    this.timeline = init.timeline\n    this.peerConnection = init.peerConnection\n\n    const initialState = this.peerConnection.connectionState\n\n    this.peerConnection.onconnectionstatechange = () => {\n      this.log.trace('peer connection state change', this.peerConnection.connectionState, 'initial state', initialState)\n\n      if (this.peerConnection.connectionState === 'disconnected' || this.peerConnection.connectionState === 'failed' || this.peerConnection.connectionState === 'closed') {\n        // nothing else to do but close the connection\n        this.timeline.close = Date.now()\n      }\n    }\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    this.log.trace('closing connection')\n\n    this.peerConnection.close()\n    this.timeline.close = Date.now()\n    this.metrics?.increment({ close: true })\n  }\n\n  abort (err: Error): void {\n    this.log.error('closing connection due to error', err)\n\n    this.peerConnection.close()\n    this.timeline.close = Date.now()\n    this.metrics?.increment({ abort: true })\n  }\n}\n", "import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.addEventListener || emitter.on || emitter.addListener;\n\tconst removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\t\tif (options.filter && !options.filter(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = error => {\n\t\t\tcancel();\n\t\t\treject(error);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\ttimeout.cancel = cancel;\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]);\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t// eslint-disable-next-line unicorn/no-array-callback-reference\n\t\tif (options.filter && !options.filter(value)) {\n\t\t\tcancel();\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Message {\n  flag?: Message.Flag\n  message?: Uint8Array\n}\n\nexport namespace Message {\n  export enum Flag {\n    FIN = 'FIN',\n    STOP_SENDING = 'STOP_SENDING',\n    RESET = 'RESET',\n    FIN_ACK = 'FIN_ACK'\n  }\n\n  enum __FlagValues {\n    FIN = 0,\n    STOP_SENDING = 1,\n    RESET = 2,\n    FIN_ACK = 3\n  }\n\n  export namespace Flag {\n    export const codec = (): Codec<Flag> => {\n      return enumeration<Flag>(__FlagValues)\n    }\n  }\n\n  let _codec: Codec<Message>\n\n  export const codec = (): Codec<Message> => {\n    if (_codec == null) {\n      _codec = message<Message>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.flag != null) {\n          w.uint32(8)\n          Message.Flag.codec().encode(obj.flag, w)\n        }\n\n        if (obj.message != null) {\n          w.uint32(18)\n          w.bytes(obj.message)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.flag = Message.Flag.codec().decode(reader)\n              break\n            case 2:\n              obj.message = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Message>): Uint8Array => {\n    return encodeMessage(obj, Message.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Message => {\n    return decodeMessage(buf, Message.codec())\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { AbstractStream, type AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport * as lengthPrefixed from 'it-length-prefixed'\nimport { type Pushable, pushable } from 'it-pushable'\nimport pDefer from 'p-defer'\nimport { pEvent, TimeoutError } from 'p-event'\nimport pTimeout from 'p-timeout'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { Message } from './pb/message.js'\nimport type { DataChannelOptions } from './index.js'\nimport type { AbortOptions, ComponentLogger, Direction } from '@libp2p/interface'\nimport type { DeferredPromise } from 'p-defer'\n\nexport interface WebRTCStreamInit extends AbstractStreamInit, DataChannelOptions {\n  /**\n   * The network channel used for bidirectional peer-to-peer transfers of\n   * arbitrary data\n   *\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel}\n   */\n  channel: RTCDataChannel\n\n  logger: ComponentLogger\n}\n\n/**\n * How much can be buffered to the DataChannel at once\n */\nexport const MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024\n\n/**\n * How long time we wait for the 'bufferedamountlow' event to be emitted\n */\nexport const BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1000\n\n/**\n * protobuf field definition overhead + length encoding prefix length\n */\nexport const PROTOBUF_OVERHEAD = 7\n\n/**\n * Length of varint, in bytes\n */\nexport const VARINT_LENGTH = 2\n\n/**\n * Max message size that can be sent to the DataChannel\n *\n * @see https://blog.mozilla.org/webrtc/large-data-channel-messages/\n * @see https://issues.webrtc.org/issues/40644524\n */\nexport const MAX_MESSAGE_SIZE = 256 * 1024\n\n/**\n * When closing streams we send a FIN then wait for the remote to\n * reply with a FIN_ACK. If that does not happen within this timeout\n * we close the stream anyway.\n */\nexport const FIN_ACK_TIMEOUT = 5000\n\n/**\n * When sending data messages, if the channel is not in the \"open\" state, wait\n * this long for the \"open\" event to fire.\n */\nexport const OPEN_TIMEOUT = 5000\n\nexport class WebRTCStream extends AbstractStream {\n  /**\n   * The data channel used to send and receive data\n   */\n  private readonly channel: RTCDataChannel\n\n  /**\n   * push data from the underlying datachannel to the length prefix decoder\n   * and then the protobuf decoder.\n   */\n  private readonly incomingData: Pushable<Uint8Array>\n\n  private readonly maxBufferedAmount: number\n\n  private readonly bufferedAmountLowEventTimeout: number\n\n  /**\n   * The maximum size of a message in bytes\n   */\n  private readonly maxMessageSize: number\n\n  /**\n   * When this promise is resolved, the remote has sent us a FIN flag\n   */\n  private readonly receiveFinAck: DeferredPromise<void>\n  private readonly finAckTimeout: number\n  private readonly openTimeout: number\n\n  constructor (init: WebRTCStreamInit) {\n    // override onEnd to send/receive FIN_ACK before closing the stream\n    const originalOnEnd = init.onEnd\n    init.onEnd = (err?: Error): void => {\n      this.log.trace('readable and writeable ends closed', this.status)\n\n      void Promise.resolve(async () => {\n        if (this.timeline.abort != null || this.timeline.reset !== null) {\n          return\n        }\n\n        // wait for FIN_ACK if we haven't received it already\n        try {\n          await pTimeout(this.receiveFinAck.promise, {\n            milliseconds: this.finAckTimeout\n          })\n        } catch (err) {\n          this.log.error('error receiving FIN_ACK', err)\n        }\n      })\n        .then(() => {\n        // stop processing incoming messages\n          this.incomingData.end()\n\n          // final cleanup\n          originalOnEnd?.(err)\n        })\n        .catch(err => {\n          this.log.error('error ending stream', err)\n        })\n    }\n\n    super(init)\n\n    this.channel = init.channel\n    this.channel.binaryType = 'arraybuffer'\n    this.incomingData = pushable<Uint8Array>()\n    this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT\n    this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT\n    this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD - VARINT_LENGTH\n    this.receiveFinAck = pDefer()\n    this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT\n    this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT\n\n    // set up initial state\n    switch (this.channel.readyState) {\n      case 'open':\n        this.timeline.open = new Date().getTime()\n        break\n\n      case 'closed':\n      case 'closing':\n        if (this.timeline.close === undefined || this.timeline.close === 0) {\n          this.timeline.close = Date.now()\n        }\n        break\n      case 'connecting':\n        // noop\n        break\n\n      default:\n        this.log.error('unknown datachannel state %s', this.channel.readyState)\n        throw new CodeError('Unknown datachannel state', 'ERR_INVALID_STATE')\n    }\n\n    // handle RTCDataChannel events\n    this.channel.onopen = (_evt) => {\n      this.timeline.open = new Date().getTime()\n    }\n\n    this.channel.onclose = (_evt) => {\n      // if the channel has closed we'll never receive a FIN_ACK so resolve the\n      // promise so we don't try to wait later\n      this.receiveFinAck.resolve()\n\n      void this.close().catch(err => {\n        this.log.error('error closing stream after channel closed', err)\n      })\n    }\n\n    this.channel.onerror = (evt) => {\n      const err = (evt as RTCErrorEvent).error\n      this.abort(err)\n    }\n\n    this.channel.onmessage = async (event: MessageEvent<ArrayBuffer>) => {\n      const { data } = event\n\n      if (data === null || data.byteLength === 0) {\n        return\n      }\n\n      this.incomingData.push(new Uint8Array(data, 0, data.byteLength))\n    }\n\n    const self = this\n\n    // pipe framed protobuf messages through a length prefixed decoder, and\n    // surface data from the `Message.message` field through a source.\n    Promise.resolve().then(async () => {\n      for await (const buf of lengthPrefixed.decode(this.incomingData)) {\n        const message = self.processIncomingProtobuf(buf)\n\n        if (message != null) {\n          self.sourcePush(new Uint8ArrayList(message))\n        }\n      }\n    })\n      .catch(err => {\n        this.log.error('error processing incoming data channel messages', err)\n      })\n  }\n\n  sendNewStream (): void {\n    // opening new streams is handled by WebRTC so this is a noop\n  }\n\n  async _sendMessage (data: Uint8ArrayList, checkBuffer: boolean = true): Promise<void> {\n    if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {\n      try {\n        this.log('channel buffer is %d, wait for \"bufferedamountlow\" event', this.channel.bufferedAmount)\n        await pEvent(this.channel, 'bufferedamountlow', { timeout: this.bufferedAmountLowEventTimeout })\n      } catch (err: any) {\n        if (err instanceof TimeoutError) {\n          throw new CodeError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`, 'ERR_BUFFER_CLEAR_TIMEOUT')\n        }\n\n        throw err\n      }\n    }\n\n    if (this.channel.readyState === 'closed' || this.channel.readyState === 'closing') {\n      throw new CodeError(`Invalid datachannel state - ${this.channel.readyState}`, 'ERR_INVALID_STATE')\n    }\n\n    if (this.channel.readyState !== 'open') {\n      this.log('channel state is \"%s\" and not \"open\", waiting for \"open\" event before sending data', this.channel.readyState)\n      await pEvent(this.channel, 'open', { timeout: this.openTimeout })\n      this.log('channel state is now \"%s\", sending data', this.channel.readyState)\n    }\n\n    // send message without copying data\n    this.channel.send(data.subarray())\n  }\n\n  async sendData (data: Uint8ArrayList): Promise<void> {\n    // sending messages is an async operation so use a copy of the list as it\n    // may be changed beneath us\n    data = data.sublist()\n\n    while (data.byteLength > 0) {\n      const toSend = Math.min(data.byteLength, this.maxMessageSize)\n      const buf = data.subarray(0, toSend)\n      const msgbuf = Message.encode({ message: buf })\n      const sendbuf = lengthPrefixed.encode.single(msgbuf)\n      await this._sendMessage(sendbuf)\n\n      data.consume(toSend)\n    }\n  }\n\n  async sendReset (): Promise<void> {\n    await this._sendFlag(Message.Flag.RESET)\n  }\n\n  async sendCloseWrite (options: AbortOptions): Promise<void> {\n    const sent = await this._sendFlag(Message.Flag.FIN)\n\n    if (sent) {\n      this.log.trace('awaiting FIN_ACK')\n      try {\n        await raceSignal(this.receiveFinAck.promise, options?.signal, {\n          errorMessage: 'sending close-write was aborted before FIN_ACK was received',\n          errorCode: 'ERR_FIN_ACK_NOT_RECEIVED'\n        })\n      } catch (err) {\n        this.log.error('failed to await FIN_ACK', err)\n      }\n    } else {\n      this.log.trace('sending FIN failed, not awaiting FIN_ACK')\n    }\n\n    // if we've attempted to receive a FIN_ACK, do not try again\n    this.receiveFinAck.resolve()\n  }\n\n  async sendCloseRead (): Promise<void> {\n    await this._sendFlag(Message.Flag.STOP_SENDING)\n  }\n\n  /**\n   * Handle incoming\n   */\n  private processIncomingProtobuf (buffer: Uint8ArrayList): Uint8Array | undefined {\n    const message = Message.decode(buffer)\n\n    if (message.flag !== undefined) {\n      this.log.trace('incoming flag %s, write status \"%s\", read status \"%s\"', message.flag, this.writeStatus, this.readStatus)\n\n      if (message.flag === Message.Flag.FIN) {\n        // We should expect no more data from the remote, stop reading\n        this.remoteCloseWrite()\n\n        this.log.trace('sending FIN_ACK')\n        void this._sendFlag(Message.Flag.FIN_ACK)\n          .catch(err => {\n            this.log.error('error sending FIN_ACK immediately', err)\n          })\n      }\n\n      if (message.flag === Message.Flag.RESET) {\n        // Stop reading and writing to the stream immediately\n        this.reset()\n      }\n\n      if (message.flag === Message.Flag.STOP_SENDING) {\n        // The remote has stopped reading\n        this.remoteCloseRead()\n      }\n\n      if (message.flag === Message.Flag.FIN_ACK) {\n        this.log.trace('received FIN_ACK')\n        this.receiveFinAck.resolve()\n      }\n    }\n\n    // ignore data messages if we've closed the readable end already\n    if (this.readStatus === 'ready') {\n      return message.message\n    }\n  }\n\n  private async _sendFlag (flag: Message.Flag): Promise<boolean> {\n    if (this.channel.readyState !== 'open') {\n      // flags can be sent while we or the remote are closing the datachannel so\n      // if the channel isn't open, don't try to send it but return false to let\n      // the caller know and act if they need to\n      this.log.trace('not sending flag %s because channel is \"%s\" and not \"open\"', this.channel.readyState, flag.toString())\n      return false\n    }\n\n    this.log.trace('sending flag %s', flag.toString())\n    const msgbuf = Message.encode({ flag })\n    const prefixedBuf = lengthPrefixed.encode.single(msgbuf)\n\n    try {\n      await this._sendMessage(prefixedBuf, false)\n\n      return true\n    } catch (err: any) {\n      this.log.error('could not send flag %s', flag.toString(), err)\n    }\n\n    return false\n  }\n}\n\nexport interface WebRTCStreamOptions extends DataChannelOptions {\n  /**\n   * The network channel used for bidirectional peer-to-peer transfers of\n   * arbitrary data\n   *\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel}\n   */\n  channel: RTCDataChannel\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A callback invoked when the channel ends\n   */\n  onEnd?(err?: Error | undefined): void\n\n  logger: ComponentLogger\n}\n\nexport function createStream (options: WebRTCStreamOptions): WebRTCStream {\n  const { channel, direction } = options\n\n  return new WebRTCStream({\n    id: direction === 'inbound' ? (`i${channel.id}`) : `r${channel.id}`,\n    log: options.logger.forComponent(`libp2p:webrtc:stream:${direction}:${channel.id}`),\n    ...options\n  })\n}\n", "import { createStream } from './stream.js'\nimport { drainAndClose, nopSink, nopSource } from './util.js'\nimport type { DataChannelOptions } from './index.js'\nimport type { ComponentLogger, Logger, Stream, CounterGroup, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\nimport type { AbortOptions } from '@multiformats/multiaddr'\nimport type { Source, Sink } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PROTOCOL = '/webrtc'\n\nexport interface DataChannelMuxerFactoryInit {\n  /**\n   * WebRTC Peer Connection\n   */\n  peerConnection: RTCPeerConnection\n\n  /**\n   * The protocol to use\n   */\n  protocol?: string\n\n  /**\n   * Optional metrics for this data channel muxer\n   */\n  metrics?: CounterGroup\n\n  dataChannelOptions?: DataChannelOptions\n}\n\nexport interface DataChannelMuxerFactoryComponents {\n  logger: ComponentLogger\n}\n\ninterface BufferedStream {\n  stream: Stream\n  channel: RTCDataChannel\n  onEnd(err?: Error): void\n}\n\nexport class DataChannelMuxerFactory implements StreamMuxerFactory {\n  public readonly protocol: string\n\n  /**\n   * WebRTC Peer Connection\n   */\n  private readonly peerConnection: RTCPeerConnection\n  private bufferedStreams: BufferedStream[] = []\n  private readonly metrics?: CounterGroup\n  private readonly dataChannelOptions?: DataChannelOptions\n  private readonly components: DataChannelMuxerFactoryComponents\n  private readonly log: Logger\n\n  constructor (components: DataChannelMuxerFactoryComponents, init: DataChannelMuxerFactoryInit) {\n    this.components = components\n    this.peerConnection = init.peerConnection\n    this.metrics = init.metrics\n    this.protocol = init.protocol ?? PROTOCOL\n    this.dataChannelOptions = init.dataChannelOptions ?? {}\n    this.log = components.logger.forComponent('libp2p:webrtc:datachannelmuxerfactory')\n\n    // store any datachannels opened before upgrade has been completed\n    this.peerConnection.ondatachannel = ({ channel }) => {\n      this.log.trace('incoming early datachannel with channel id %d and label \"%s\"', channel.id)\n\n      // 'init' channel is only used during connection establishment\n      if (channel.label === 'init') {\n        this.log.trace('closing early init channel')\n        channel.close()\n\n        return\n      }\n\n      // @ts-expect-error fields are set below\n      const bufferedStream: BufferedStream = {}\n\n      const stream = createStream({\n        channel,\n        direction: 'inbound',\n        onEnd: (err) => {\n          bufferedStream.onEnd(err)\n        },\n        logger: components.logger,\n        ...this.dataChannelOptions\n      })\n\n      bufferedStream.stream = stream\n      bufferedStream.channel = channel\n      bufferedStream.onEnd = () => {\n        this.bufferedStreams = this.bufferedStreams.filter(s => s.stream.id !== stream.id)\n      }\n\n      this.bufferedStreams.push(bufferedStream)\n    }\n  }\n\n  createStreamMuxer (init?: StreamMuxerInit): StreamMuxer {\n    return new DataChannelMuxer(this.components, {\n      ...init,\n      peerConnection: this.peerConnection,\n      dataChannelOptions: this.dataChannelOptions,\n      metrics: this.metrics,\n      streams: this.bufferedStreams,\n      protocol: this.protocol\n    })\n  }\n}\n\nexport interface DataChannelMuxerInit extends DataChannelMuxerFactoryInit, StreamMuxerInit {\n  streams: BufferedStream[]\n}\n\nexport interface DataChannelMuxerComponents {\n  logger: ComponentLogger\n}\n\n/**\n * A libp2p data channel stream muxer\n */\nexport class DataChannelMuxer implements StreamMuxer {\n  /**\n   * Array of streams in the data channel\n   */\n  public streams: Stream[]\n  public protocol: string\n\n  private readonly log: Logger\n  private readonly peerConnection: RTCPeerConnection\n  private readonly dataChannelOptions: DataChannelOptions\n  private readonly metrics?: CounterGroup\n  private readonly logger: ComponentLogger\n\n  constructor (components: DataChannelMuxerComponents, readonly init: DataChannelMuxerInit) {\n    this.log = components.logger.forComponent('libp2p:webrtc:muxer')\n    this.logger = components.logger\n    this.streams = init.streams.map(s => s.stream)\n    this.peerConnection = init.peerConnection\n    this.protocol = init.protocol ?? PROTOCOL\n    this.metrics = init.metrics\n    this.dataChannelOptions = init.dataChannelOptions ?? {}\n\n    /**\n     * Fired when a data channel has been added to the connection has been\n     * added by the remote peer.\n     *\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/datachannel_event}\n     */\n    this.peerConnection.ondatachannel = ({ channel }) => {\n      this.log.trace('incoming datachannel with channel id %d', channel.id)\n\n      // 'init' channel is only used during connection establishment\n      if (channel.label === 'init') {\n        this.log.trace('closing init channel')\n        channel.close()\n\n        return\n      }\n\n      const stream = createStream({\n        channel,\n        direction: 'inbound',\n        onEnd: () => {\n          this.log('incoming channel %s ended with state %s', channel.id, channel.readyState)\n          this.#onStreamEnd(stream, channel)\n        },\n        logger: this.logger,\n        ...this.dataChannelOptions\n      })\n\n      this.streams.push(stream)\n      this.metrics?.increment({ incoming_stream: true })\n      init?.onIncomingStream?.(stream)\n    }\n\n    // the DataChannelMuxer constructor is called during set up of the\n    // connection by the upgrader.\n    //\n    // If we invoke `init.onIncomingStream` immediately, the connection object\n    // will not be set up yet so add a tiny delay before letting the\n    // connection know about early streams\n    if (this.init.streams.length > 0) {\n      queueMicrotask(() => {\n        this.init.streams.forEach(bufferedStream => {\n          bufferedStream.onEnd = () => {\n            this.log('incoming early channel %s ended with state %s', bufferedStream.channel.id, bufferedStream.channel.readyState)\n            this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel)\n          }\n\n          this.metrics?.increment({ incoming_stream: true })\n          this.init?.onIncomingStream?.(bufferedStream.stream)\n        })\n      })\n    }\n  }\n\n  #onStreamEnd (stream: Stream, channel: RTCDataChannel): void {\n    this.log.trace('stream %s %s %s onEnd', stream.direction, stream.id, stream.protocol)\n    drainAndClose(\n      channel,\n      `${stream.direction} ${stream.id} ${stream.protocol}`,\n      this.dataChannelOptions.drainTimeout, {\n        log: this.log\n      }\n    )\n    this.streams = this.streams.filter(s => s.id !== stream.id)\n    this.metrics?.increment({ stream_end: true })\n    this.init?.onStreamEnd?.(stream)\n  }\n\n  /**\n   * Gracefully close all tracked streams and stop the muxer\n   */\n  async close (options?: AbortOptions): Promise<void> {\n    try {\n      await Promise.all(\n        this.streams.map(async stream => stream.close(options))\n      )\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  /**\n   * Abort all tracked streams and stop the muxer\n   */\n  abort (err: Error): void {\n    for (const stream of this.streams) {\n      stream.abort(err)\n    }\n  }\n\n  /**\n   * The stream source, a no-op as the transport natively supports multiplexing\n   */\n  source: AsyncGenerator<Uint8Array, any, unknown> = nopSource()\n\n  /**\n   * The stream destination, a no-op as the transport natively supports multiplexing\n   */\n  sink: Sink<Source<Uint8Array | Uint8ArrayList>, Promise<void>> = nopSink\n\n  newStream (): Stream {\n    // The spec says the label SHOULD be an empty string: https://github.com/libp2p/specs/blob/master/webrtc/README.md#rtcdatachannel-label\n    const channel = this.peerConnection.createDataChannel('')\n\n    this.log.trace('opened outgoing datachannel with channel id %s', channel.id)\n\n    const stream = createStream({\n      channel,\n      direction: 'outbound',\n      onEnd: () => {\n        this.log('outgoing channel %s ended with state %s', channel.id, channel.readyState)\n        this.#onStreamEnd(stream, channel)\n      },\n      logger: this.logger,\n      ...this.dataChannelOptions\n    })\n    this.streams.push(stream)\n    this.metrics?.increment({ outgoing_stream: true })\n\n    return stream\n  }\n}\n", "export const RTCPeerConnection = globalThis.RTCPeerConnection\nexport const RTCSessionDescription = globalThis.RTCSessionDescription\nexport const RTCIceCandidate = globalThis.RTCIceCandidate\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Message {\n  type?: Message.Type\n  data?: string\n}\n\nexport namespace Message {\n  export enum Type {\n    SDP_OFFER = 'SDP_OFFER',\n    SDP_ANSWER = 'SDP_ANSWER',\n    ICE_CANDIDATE = 'ICE_CANDIDATE'\n  }\n\n  enum __TypeValues {\n    SDP_OFFER = 0,\n    SDP_ANSWER = 1,\n    ICE_CANDIDATE = 2\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<Message>\n\n  export const codec = (): Codec<Message> => {\n    if (_codec == null) {\n      _codec = message<Message>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          Message.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.data != null) {\n          w.uint32(18)\n          w.string(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = Message.Type.codec().decode(reader)\n              break\n            case 2:\n              obj.data = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Message>): Uint8Array => {\n    return encodeMessage(obj, Message.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Message => {\n    return decodeMessage(buf, Message.codec())\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport pDefer from 'p-defer'\nimport { CustomProgressEvent } from 'progress-events'\nimport { isFirefox } from '../util.js'\nimport { RTCIceCandidate } from '../webrtc/index.js'\nimport { Message } from './pb/message.js'\nimport type { WebRTCDialEvents } from './transport.js'\nimport type { LoggerOptions, Stream } from '@libp2p/interface'\nimport type { AbortOptions, MessageStream } from 'it-protobuf-stream'\nimport type { DeferredPromise } from 'p-defer'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface ReadCandidatesOptions extends AbortOptions, LoggerOptions, ProgressOptions<WebRTCDialEvents> {\n  direction: string\n}\n\nexport const readCandidatesUntilConnected = async (pc: RTCPeerConnection, stream: MessageStream<Message, Stream>, options: ReadCandidatesOptions): Promise<void> => {\n  try {\n    const connectedPromise: DeferredPromise<void> = pDefer()\n    resolveOnConnected(pc, connectedPromise)\n\n    // read candidates until we are connected or we reach the end of the stream\n    while (true) {\n      // if we connect, stop trying to read from the stream\n      const message = await Promise.race([\n        connectedPromise.promise,\n        stream.read({\n          signal: options.signal\n        }).catch(() => {})\n      ])\n\n      // stream ended or we became connected\n      if (message == null) {\n        // throw if we timed out\n        options.signal?.throwIfAborted()\n\n        break\n      }\n\n      if (message.type !== Message.Type.ICE_CANDIDATE) {\n        throw new CodeError('ICE candidate message expected', 'ERR_NOT_ICE_CANDIDATE')\n      }\n\n      const candidateInit = JSON.parse(message.data ?? 'null')\n\n      // an empty string means this generation of candidates is complete, a null\n      // candidate means candidate gathering has finished\n      // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent\n      if (candidateInit === '' || candidateInit === null) {\n        options.onProgress?.(new CustomProgressEvent('webrtc:end-of-ice-candidates'))\n        options.log.trace('end-of-candidates received')\n\n        continue\n      }\n\n      const candidate = new RTCIceCandidate(candidateInit)\n\n      options.log.trace('%s received new ICE candidate %o', options.direction, candidateInit)\n\n      try {\n        options.onProgress?.(new CustomProgressEvent<string>('webrtc:add-ice-candidate', candidate.candidate))\n        await pc.addIceCandidate(candidate)\n      } catch (err) {\n        options.log.error('%s bad candidate received', options.direction, candidateInit, err)\n      }\n    }\n  } catch (err) {\n    options.log.error('%s error parsing ICE candidate', options.direction, err)\n\n    if (options.signal?.aborted === true) {\n      throw err\n    }\n  }\n}\n\nfunction getConnectionState (pc: RTCPeerConnection): string {\n  return isFirefox ? pc.iceConnectionState : pc.connectionState\n}\n\nfunction resolveOnConnected (pc: RTCPeerConnection, promise: DeferredPromise<void>): void {\n  pc[isFirefox ? 'oniceconnectionstatechange' : 'onconnectionstatechange'] = (_) => {\n    switch (getConnectionState(pc)) {\n      case 'connected':\n        promise.resolve()\n        break\n      case 'failed':\n      case 'disconnected':\n      case 'closed':\n        promise.reject(new CodeError('RTCPeerConnection was closed', 'ERR_CONNECTION_CLOSED_BEFORE_CONNECTED'))\n        break\n      default:\n        break\n    }\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { pbStream } from 'it-protobuf-stream'\nimport { CustomProgressEvent } from 'progress-events'\nimport { DataChannelMuxerFactory } from '../muxer.js'\nimport { RTCPeerConnection, RTCSessionDescription } from '../webrtc/index.js'\nimport { Message } from './pb/message.js'\nimport { SIGNALING_PROTO_ID, splitAddr, type WebRTCDialEvents, type WebRTCTransportMetrics } from './transport.js'\nimport { readCandidatesUntilConnected } from './util.js'\nimport type { DataChannelOptions } from '../index.js'\nimport type { LoggerOptions, Connection, ComponentLogger } from '@libp2p/interface'\nimport type { ConnectionManager, IncomingStreamData, TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface IncomingStreamOpts extends IncomingStreamData {\n  rtcConfiguration?: RTCConfiguration\n  dataChannelOptions?: Partial<DataChannelOptions>\n  signal: AbortSignal\n}\n\nexport interface ConnectOptions extends LoggerOptions, ProgressOptions<WebRTCDialEvents> {\n  rtcConfiguration?: RTCConfiguration\n  dataChannel?: DataChannelOptions\n  multiaddr: Multiaddr\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  dataChannelOptions?: Partial<DataChannelOptions>\n  signal?: AbortSignal\n  metrics?: WebRTCTransportMetrics\n  logger: ComponentLogger\n}\n\nexport async function initiateConnection ({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log, logger, onProgress }: ConnectOptions): Promise<{ remoteAddress: Multiaddr, peerConnection: RTCPeerConnection, muxerFactory: DataChannelMuxerFactory }> {\n  const { baseAddr } = splitAddr(ma)\n\n  metrics?.dialerEvents.increment({ open: true })\n\n  log.trace('dialing base address: %a', baseAddr)\n\n  const relayPeer = baseAddr.getPeerId()\n\n  if (relayPeer == null) {\n    throw new CodeError('Relay peer was missing', 'ERR_INVALID_ADDRESS')\n  }\n\n  const connections = connectionManager.getConnections(peerIdFromString(relayPeer))\n  let connection: Connection\n  let shouldCloseConnection = false\n\n  if (connections.length === 0) {\n    onProgress?.(new CustomProgressEvent('webrtc:dial-relay'))\n\n    // use the transport manager to open a connection. Initiating a WebRTC\n    // connection takes place in the context of a dial - if we use the\n    // connection manager instead we can end up joining our own dial context\n    connection = await transportManager.dial(baseAddr, {\n      signal,\n      onProgress\n    })\n    // this connection is unmanaged by the connection manager so we should\n    // close it when we are done\n    shouldCloseConnection = true\n  } else {\n    onProgress?.(new CustomProgressEvent('webrtc:reuse-relay-connection'))\n\n    connection = connections[0]\n  }\n\n  try {\n    onProgress?.(new CustomProgressEvent('webrtc:open-signaling-stream'))\n\n    const stream = await connection.newStream(SIGNALING_PROTO_ID, {\n      signal,\n      runOnTransientConnection: true\n    })\n\n    const messageStream = pbStream(stream).pb(Message)\n    const peerConnection = new RTCPeerConnection(rtcConfiguration)\n    const muxerFactory = new DataChannelMuxerFactory({\n      logger\n    }, {\n      peerConnection,\n      dataChannelOptions: dataChannel\n    })\n\n    try {\n      // we create the channel so that the RTCPeerConnection has a component for\n      // which to collect candidates. The label is not relevant to connection\n      // initiation but can be useful for debugging\n      const channel = peerConnection.createDataChannel('init')\n\n      // setup callback to write ICE candidates to the remote peer\n      peerConnection.onicecandidate = ({ candidate }) => {\n        // a null candidate means end-of-candidates, an empty string candidate\n        // means end-of-candidates for this generation, otherwise this should\n        // be a valid candidate object\n        // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent\n        const data = JSON.stringify(candidate?.toJSON() ?? null)\n\n        log.trace('initiator sending ICE candidate %o', candidate)\n\n        void messageStream.write({\n          type: Message.Type.ICE_CANDIDATE,\n          data\n        }, {\n          signal\n        })\n          .catch(err => {\n            log.error('error sending ICE candidate', err)\n          })\n      }\n      peerConnection.onicecandidateerror = (event) => {\n        log.error('initiator ICE candidate error', event)\n      }\n\n      // create an offer\n      const offerSdp = await peerConnection.createOffer().catch(err => {\n        log.error('could not execute createOffer', err)\n        throw new CodeError('Failed to set createOffer', 'ERR_SDP_HANDSHAKE_FAILED')\n      })\n\n      log.trace('initiator send SDP offer %s', offerSdp.sdp)\n\n      onProgress?.(new CustomProgressEvent('webrtc:send-sdp-offer'))\n\n      // write the offer to the stream\n      await messageStream.write({ type: Message.Type.SDP_OFFER, data: offerSdp.sdp }, {\n        signal\n      })\n\n      // set offer as local description\n      await peerConnection.setLocalDescription(offerSdp).catch(err => {\n        log.error('could not execute setLocalDescription', err)\n        throw new CodeError('Failed to set localDescription', 'ERR_SDP_HANDSHAKE_FAILED')\n      })\n\n      onProgress?.(new CustomProgressEvent('webrtc:read-sdp-answer'))\n\n      // read answer\n      const answerMessage = await messageStream.read({\n        signal\n      })\n\n      if (answerMessage.type !== Message.Type.SDP_ANSWER) {\n        throw new CodeError('Remote should send an SDP answer', 'ERR_SDP_HANDSHAKE_FAILED')\n      }\n\n      log.trace('initiator receive SDP answer %s', answerMessage.data)\n\n      const answerSdp = new RTCSessionDescription({ type: 'answer', sdp: answerMessage.data })\n      await peerConnection.setRemoteDescription(answerSdp).catch(err => {\n        log.error('could not execute setRemoteDescription', err)\n        throw new CodeError('Failed to set remoteDescription', 'ERR_SDP_HANDSHAKE_FAILED')\n      })\n\n      log.trace('initiator read candidates until connected')\n\n      onProgress?.(new CustomProgressEvent('webrtc:read-ice-candidates'))\n\n      await readCandidatesUntilConnected(peerConnection, messageStream, {\n        direction: 'initiator',\n        signal,\n        log,\n        onProgress\n      })\n\n      log.trace('initiator connected, closing init channel')\n      channel.close()\n\n      onProgress?.(new CustomProgressEvent('webrtc:close-signaling-stream'))\n\n      log.trace('closing signaling channel')\n      await stream.close({\n        signal\n      })\n\n      log.trace('initiator connected to remote address %s', ma)\n\n      return {\n        remoteAddress: ma,\n        peerConnection,\n        muxerFactory\n      }\n    } catch (err: any) {\n      log.error('outgoing signaling error', err)\n\n      peerConnection.close()\n      stream.abort(err)\n      throw err\n    } finally {\n      peerConnection.onicecandidate = null\n      peerConnection.onicecandidateerror = null\n    }\n  } finally {\n    // if we had to open a connection to perform the SDP handshake\n    // close it because it's not tracked by the connection manager\n    if (shouldCloseConnection) {\n      try {\n        await connection.close({\n          signal\n        })\n      } catch (err: any) {\n        connection.abort(err)\n      }\n    }\n  }\n}\n", "import { TypedEventEmitter } from '@libp2p/interface'\nimport { Circuit } from '@multiformats/mafmt'\nimport type { PeerId, ListenerEvents, Listener } from '@libp2p/interface'\nimport type { TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface WebRTCPeerListenerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n}\n\nexport interface WebRTCPeerListenerInit {\n  shutdownController: AbortController\n}\n\nexport class WebRTCPeerListener extends TypedEventEmitter<ListenerEvents> implements Listener {\n  private readonly peerId: PeerId\n  private readonly transportManager: TransportManager\n  private readonly shutdownController: AbortController\n\n  constructor (components: WebRTCPeerListenerComponents, init: WebRTCPeerListenerInit) {\n    super()\n\n    this.peerId = components.peerId\n    this.transportManager = components.transportManager\n\n    this.shutdownController = init.shutdownController\n  }\n\n  async listen (): Promise<void> {\n    this.safeDispatchEvent('listening', {})\n  }\n\n  getAddrs (): Multiaddr[] {\n    return this.transportManager\n      .getListeners()\n      .filter(l => l !== this)\n      .map(l => l.getAddrs()\n        .filter(ma => Circuit.matches(ma))\n        .map(ma => {\n          return ma.encapsulate(`/webrtc/p2p/${this.peerId}`)\n        })\n      )\n      .flat()\n  }\n\n  async close (): Promise<void> {\n    this.shutdownController.abort()\n    this.safeDispatchEvent('close', {})\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { multiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { pbStream } from 'it-protobuf-stream'\nimport { type RTCPeerConnection, RTCSessionDescription } from '../webrtc/index.js'\nimport { Message } from './pb/message.js'\nimport { readCandidatesUntilConnected } from './util.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { IncomingStreamData } from '@libp2p/interface-internal'\n\nexport interface IncomingStreamOpts extends IncomingStreamData {\n  peerConnection: RTCPeerConnection\n  signal: AbortSignal\n  log: Logger\n}\n\nexport async function handleIncomingStream ({ peerConnection, stream, signal, connection, log }: IncomingStreamOpts): Promise<{ remoteAddress: Multiaddr }> {\n  log.trace('new inbound signaling stream')\n\n  const messageStream = pbStream(stream).pb(Message)\n\n  try {\n    // candidate callbacks\n    peerConnection.onicecandidate = ({ candidate }) => {\n      // a null candidate means end-of-candidates, an empty string candidate\n      // means end-of-candidates for this generation, otherwise this should\n      // be a valid candidate object\n      // see - https://www.w3.org/TR/webrtc/#rtcpeerconnectioniceevent\n      const data = JSON.stringify(candidate?.toJSON() ?? null)\n\n      log.trace('recipient sending ICE candidate %s', data)\n\n      messageStream.write({\n        type: Message.Type.ICE_CANDIDATE,\n        data\n      }, {\n        signal\n      })\n        .catch(err => {\n          log.error('error sending ICE candidate', err)\n        })\n    }\n\n    // read an SDP offer\n    const pbOffer = await messageStream.read({\n      signal\n    })\n\n    if (pbOffer.type !== Message.Type.SDP_OFFER) {\n      throw new CodeError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? 'undefined'} `, 'ERR_SDP_HANDSHAKE_FAILED')\n    }\n\n    log.trace('recipient receive SDP offer %s', pbOffer.data)\n\n    const offer = new RTCSessionDescription({\n      type: 'offer',\n      sdp: pbOffer.data\n    })\n\n    await peerConnection.setRemoteDescription(offer).catch(err => {\n      log.error('could not execute setRemoteDescription', err)\n      throw new CodeError('Failed to set remoteDescription', 'ERR_SDP_HANDSHAKE_FAILED')\n    })\n\n    // create and write an SDP answer\n    const answer = await peerConnection.createAnswer().catch(err => {\n      log.error('could not execute createAnswer', err)\n      throw new CodeError('Failed to create answer', 'ERR_SDP_HANDSHAKE_FAILED')\n    })\n\n    log.trace('recipient send SDP answer %s', answer.sdp)\n\n    // write the answer to the remote\n    await messageStream.write({ type: Message.Type.SDP_ANSWER, data: answer.sdp }, {\n      signal\n    })\n\n    await peerConnection.setLocalDescription(answer).catch(err => {\n      log.error('could not execute setLocalDescription', err)\n      throw new CodeError('Failed to set localDescription', 'ERR_SDP_HANDSHAKE_FAILED')\n    })\n\n    log.trace('recipient read candidates until connected')\n\n    // wait until candidates are connected\n    await readCandidatesUntilConnected(peerConnection, messageStream, {\n      direction: 'recipient',\n      signal,\n      log\n    })\n  } catch (err: any) {\n    if (peerConnection.connectionState !== 'connected') {\n      log.error('error while handling signaling stream from peer %a', connection.remoteAddr, err)\n\n      peerConnection.close()\n      throw err\n    } else {\n      log('error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected', connection.remoteAddr, err)\n    }\n  }\n\n  const remoteAddress = multiaddr(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`)\n\n  log.trace('recipient connected to remote address %s', remoteAddress)\n\n  return { remoteAddress }\n}\n", "import { CodeError, serviceCapabilities, serviceDependencies, setMaxListeners, transportSymbol } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { multiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { WebRTC } from '@multiformats/multiaddr-matcher'\nimport { codes } from '../error.js'\nimport { WebRTCMultiaddrConnection } from '../maconn.js'\nimport { DataChannelMuxerFactory } from '../muxer.js'\nimport { getRtcConfiguration } from '../util.js'\nimport { RTCPeerConnection } from '../webrtc/index.js'\nimport { initiateConnection } from './initiate-connection.js'\nimport { WebRTCPeerListener } from './listener.js'\nimport { handleIncomingStream } from './signaling-stream-handler.js'\nimport type { DataChannelOptions } from '../index.js'\nimport type { OutboundConnectionUpgradeEvents, CreateListenerOptions, DialTransportOptions, Transport, Listener, Upgrader, ComponentLogger, Logger, Connection, PeerId, CounterGroup, Metrics, Startable, OpenConnectionProgressEvents } from '@libp2p/interface'\nimport type { IncomingStreamData, Registrar, ConnectionManager, TransportManager } from '@libp2p/interface-internal'\nimport type { ProgressEvent } from 'progress-events'\n\nconst WEBRTC_TRANSPORT = '/webrtc'\nconst CIRCUIT_RELAY_TRANSPORT = '/p2p-circuit'\nexport const SIGNALING_PROTO_ID = '/webrtc-signaling/0.0.1'\nconst INBOUND_CONNECTION_TIMEOUT = 30 * 1000\n\nexport interface WebRTCTransportInit {\n  rtcConfiguration?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>)\n  dataChannel?: DataChannelOptions\n\n  /**\n   * Inbound connections must complete the upgrade within this many ms\n   * (default: 30s)\n   */\n  inboundConnectionTimeout?: number\n}\n\nexport interface WebRTCTransportComponents {\n  peerId: PeerId\n  registrar: Registrar\n  upgrader: Upgrader\n  transportManager: TransportManager\n  connectionManager: ConnectionManager\n  metrics?: Metrics\n  logger: ComponentLogger\n}\n\nexport interface WebRTCTransportMetrics {\n  dialerEvents: CounterGroup\n  listenerEvents: CounterGroup\n}\n\nexport type WebRTCDialEvents =\n  OutboundConnectionUpgradeEvents |\n  OpenConnectionProgressEvents |\n  ProgressEvent<'webrtc:dial-relay'> |\n  ProgressEvent<'webrtc:reuse-relay-connection'> |\n  ProgressEvent<'webrtc:open-signaling-stream'> |\n  ProgressEvent<'webrtc:send-sdp-offer'> |\n  ProgressEvent<'webrtc:read-sdp-answer'> |\n  ProgressEvent<'webrtc:read-ice-candidates'> |\n  ProgressEvent<'webrtc:add-ice-candidate', string> |\n  ProgressEvent<'webrtc:end-of-ice-candidates'> |\n  ProgressEvent<'webrtc:close-signaling-stream'>\n\nexport class WebRTCTransport implements Transport<WebRTCDialEvents>, Startable {\n  private readonly log: Logger\n  private _started = false\n  private readonly metrics?: WebRTCTransportMetrics\n  private readonly shutdownController: AbortController\n\n  constructor (\n    private readonly components: WebRTCTransportComponents,\n    private readonly init: WebRTCTransportInit = {}\n  ) {\n    this.log = components.logger.forComponent('libp2p:webrtc')\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n\n    if (components.metrics != null) {\n      this.metrics = {\n        dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_dialer_events_total', {\n          label: 'event',\n          help: 'Total count of WebRTC dialer events by type'\n        }),\n        listenerEvents: components.metrics.registerCounterGroup('libp2p_webrtc_listener_events_total', {\n          label: 'event',\n          help: 'Total count of WebRTC listener events by type'\n        })\n      }\n    }\n  }\n\n  readonly [transportSymbol] = true\n\n  readonly [Symbol.toStringTag] = '@libp2p/webrtc'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport'\n  ]\n\n  readonly [serviceDependencies]: string[] = [\n    '@libp2p/identify',\n    '@libp2p/circuit-relay-v2-transport'\n  ]\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  async start (): Promise<void> {\n    await this.components.registrar.handle(SIGNALING_PROTO_ID, (data: IncomingStreamData) => {\n      this._onProtocol(data).catch(err => { this.log.error('failed to handle incoming connect from %p', data.connection.remotePeer, err) })\n    }, {\n      runOnTransientConnection: true\n    })\n    this._started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.components.registrar.unhandle(SIGNALING_PROTO_ID)\n    this._started = false\n  }\n\n  createListener (options: CreateListenerOptions): Listener {\n    return new WebRTCPeerListener(this.components, {\n      shutdownController: this.shutdownController\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return multiaddrs.filter(WebRTC.exactMatch)\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n\n  /*\n   * dial connects to a remote via the circuit relay or any other protocol\n   * and proceeds to upgrade to a webrtc connection.\n   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>\n   * For a circuit relay, this will be of the form\n   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>\n  */\n  async dial (ma: Multiaddr, options: DialTransportOptions<WebRTCDialEvents>): Promise<Connection> {\n    this.log.trace('dialing address: %a', ma)\n\n    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({\n      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),\n      dataChannel: this.init.dataChannel,\n      multiaddr: ma,\n      dataChannelOptions: this.init.dataChannel,\n      signal: options.signal,\n      connectionManager: this.components.connectionManager,\n      transportManager: this.components.transportManager,\n      log: this.log,\n      logger: this.components.logger,\n      onProgress: options.onProgress\n    })\n\n    const webRTCConn = new WebRTCMultiaddrConnection(this.components, {\n      peerConnection,\n      timeline: { open: Date.now() },\n      remoteAddr: remoteAddress,\n      metrics: this.metrics?.dialerEvents\n    })\n\n    const connection = await options.upgrader.upgradeOutbound(webRTCConn, {\n      skipProtection: true,\n      skipEncryption: true,\n      muxerFactory,\n      onProgress: options.onProgress\n    })\n\n    // close the connection on shut down\n    this._closeOnShutdown(peerConnection, webRTCConn)\n\n    return connection\n  }\n\n  async _onProtocol ({ connection, stream }: IncomingStreamData): Promise<void> {\n    const signal = AbortSignal.timeout(this.init.inboundConnectionTimeout ?? INBOUND_CONNECTION_TIMEOUT)\n    const peerConnection = new RTCPeerConnection(await getRtcConfiguration(this.init.rtcConfiguration))\n    const muxerFactory = new DataChannelMuxerFactory(this.components, {\n      peerConnection,\n      dataChannelOptions: this.init.dataChannel\n    })\n\n    try {\n      const { remoteAddress } = await handleIncomingStream({\n        peerConnection,\n        connection,\n        stream,\n        signal,\n        log: this.log\n      })\n\n      // close the stream if SDP messages have been exchanged successfully\n      await stream.close({\n        signal\n      })\n\n      const webRTCConn = new WebRTCMultiaddrConnection(this.components, {\n        peerConnection,\n        timeline: { open: (new Date()).getTime() },\n        remoteAddr: remoteAddress,\n        metrics: this.metrics?.listenerEvents\n      })\n\n      await this.components.upgrader.upgradeInbound(webRTCConn, {\n        skipEncryption: true,\n        skipProtection: true,\n        muxerFactory\n      })\n\n      // close the connection on shut down\n      this._closeOnShutdown(peerConnection, webRTCConn)\n    } catch (err: any) {\n      this.log.error('incoming signaling error', err)\n\n      peerConnection.close()\n      stream.abort(err)\n      throw err\n    }\n  }\n\n  private _closeOnShutdown (pc: RTCPeerConnection, webRTCConn: WebRTCMultiaddrConnection): void {\n    // close the connection on shut down\n    const shutDownListener = (): void => {\n      webRTCConn.close()\n        .catch(err => {\n          this.log.error('could not close WebRTCMultiaddrConnection', err)\n        })\n    }\n\n    this.shutdownController.signal.addEventListener('abort', shutDownListener)\n\n    pc.addEventListener('close', () => {\n      this.shutdownController.signal.removeEventListener('abort', shutDownListener)\n    })\n  }\n}\n\nexport function splitAddr (ma: Multiaddr): { baseAddr: Multiaddr, peerId: PeerId } {\n  const addrs = ma.toString().split(WEBRTC_TRANSPORT + '/')\n  if (addrs.length !== 2) {\n    throw new CodeError('webrtc protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR)\n  }\n\n  if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {\n    throw new CodeError('p2p-circuit protocol was not present in multiaddr', codes.ERR_INVALID_MULTIADDR)\n  }\n\n  // look for remote peerId\n  let remoteAddr = multiaddr(addrs[0])\n  const destination = multiaddr('/' + addrs[1])\n\n  const destinationIdString = destination.getPeerId()\n  if (destinationIdString == null) {\n    throw new CodeError('destination peer id was missing', codes.ERR_INVALID_MULTIADDR)\n  }\n\n  const lastProtoInRemote = remoteAddr.protos().pop()\n  if (lastProtoInRemote === undefined) {\n    throw new CodeError('invalid multiaddr', codes.ERR_INVALID_MULTIADDR)\n  }\n  if (lastProtoInRemote.name !== 'p2p') {\n    remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`)\n  }\n\n  return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) }\n}\n", "import { type Multiaddr } from '@multiformats/multiaddr'\nimport { bases, digest } from 'multiformats/basics'\nimport { inappropriateMultiaddr, invalidArgument, invalidFingerprint, unsupportedHashAlgorithmCode } from '../error.js'\nimport { CERTHASH_CODE } from './transport.js'\nimport type { LoggerOptions } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\n/**\n * Get base2 | identity decoders\n */\n// @ts-expect-error - Not easy to combine these types.\nexport const mbdecoder: any = Object.values(bases).map(b => b.decoder).reduce((d, b) => d.or(b))\n\nexport function getLocalFingerprint (pc: RTCPeerConnection, options: LoggerOptions): string | undefined {\n  // try to fetch fingerprint from local certificate\n  const localCert = pc.getConfiguration().certificates?.at(0)\n  if (localCert?.getFingerprints == null) {\n    options.log.trace('fetching fingerprint from local SDP')\n    const localDescription = pc.localDescription\n    if (localDescription == null) {\n      return undefined\n    }\n    return getFingerprintFromSdp(localDescription.sdp)\n  }\n\n  options.log.trace('fetching fingerprint from local certificate')\n\n  if (localCert.getFingerprints().length === 0) {\n    return undefined\n  }\n\n  const fingerprint = localCert.getFingerprints()[0].value\n  if (fingerprint == null) {\n    throw invalidFingerprint('', 'no fingerprint on local certificate')\n  }\n\n  return fingerprint\n}\n\nconst fingerprintRegex = /^a=fingerprint:(?:\\w+-[0-9]+)\\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m\nexport function getFingerprintFromSdp (sdp: string): string | undefined {\n  const searchResult = sdp.match(fingerprintRegex)\n  return searchResult?.groups?.fingerprint\n}\n/**\n * Get base2 | identity decoders\n */\nfunction ipv (ma: Multiaddr): string {\n  for (const proto of ma.protoNames()) {\n    if (proto.startsWith('ip')) {\n      return proto.toUpperCase()\n    }\n  }\n\n  return 'IP6'\n}\n\n// Extract the certhash from a multiaddr\nexport function certhash (ma: Multiaddr): string {\n  const tups = ma.stringTuples()\n  const certhash = tups.filter((tup) => tup[0] === CERTHASH_CODE).map((tup) => tup[1])[0]\n\n  if (certhash === undefined || certhash === '') {\n    throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`)\n  }\n\n  return certhash\n}\n\n/**\n * Convert a certhash into a multihash\n */\nexport function decodeCerthash (certhash: string): MultihashDigest {\n  return digest.decode(mbdecoder.decode(certhash))\n}\n\n/**\n * Extract the fingerprint from a multiaddr\n */\nexport function ma2Fingerprint (ma: Multiaddr): string[] {\n  const mhdecoded = decodeCerthash(certhash(ma))\n  const prefix = toSupportedHashFunction(mhdecoded.code)\n  const fingerprint = mhdecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')\n  const sdp = fingerprint.match(/.{1,2}/g)\n\n  if (sdp == null) {\n    throw invalidFingerprint(fingerprint, ma.toString())\n  }\n\n  return [`${prefix} ${sdp.join(':').toUpperCase()}`, fingerprint]\n}\n\n/**\n * Normalize the hash name from a given multihash has name\n */\nexport function toSupportedHashFunction (code: number): 'SHA-1' | 'SHA-256' | 'SHA-512' {\n  switch (code) {\n    case 0x11:\n      return 'SHA-1'\n    case 0x12:\n      return 'SHA-256'\n    case 0x13:\n      return 'SHA-512'\n    default:\n      throw unsupportedHashAlgorithmCode(code)\n  }\n}\n\n/**\n * Convert a multiaddr into a SDP\n */\nfunction ma2sdp (ma: Multiaddr, ufrag: string): string {\n  const { host, port } = ma.toOptions()\n  const ipVersion = ipv(ma)\n  const [CERTFP] = ma2Fingerprint(ma)\n\n  return `v=0\no=- 0 0 IN ${ipVersion} ${host}\ns=-\nc=IN ${ipVersion} ${host}\nt=0 0\na=ice-lite\nm=application ${port} UDP/DTLS/SCTP webrtc-datachannel\na=mid:0\na=setup:passive\na=ice-ufrag:${ufrag}\na=ice-pwd:${ufrag}\na=fingerprint:${CERTFP}\na=sctp-port:5000\na=max-message-size:16384\na=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\\r\\n`\n}\n\n/**\n * Create an answer SDP from a multiaddr\n */\nexport function fromMultiAddr (ma: Multiaddr, ufrag: string): RTCSessionDescriptionInit {\n  return {\n    type: 'answer',\n    sdp: ma2sdp(ma, ufrag)\n  }\n}\n\n/**\n * Replace (munge) the ufrag and password values in a SDP\n */\nexport function munge (desc: RTCSessionDescriptionInit, ufrag: string): RTCSessionDescriptionInit {\n  if (desc.sdp === undefined) {\n    throw invalidArgument(\"Can't munge a missing SDP\")\n  }\n\n  desc.sdp = desc.sdp\n    .replace(/\\na=ice-ufrag:[^\\n]*\\n/, '\\na=ice-ufrag:' + ufrag + '\\n')\n    .replace(/\\na=ice-pwd:[^\\n]*\\n/, '\\na=ice-pwd:' + ufrag + '\\n')\n  return desc\n}\n", "const charset = Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')\nexport const genUfrag = (len: number): string => [...Array(len)].map(() => charset.at(Math.floor(Math.random() * charset.length))).join('')\n", "import { noise } from '@chainsafe/libp2p-noise'\nimport { transportSymbol, serviceCapabilities } from '@libp2p/interface'\nimport * as p from '@libp2p/peer-id'\nimport { protocols } from '@multiformats/multiaddr'\nimport { WebRTCDirect } from '@multiformats/multiaddr-matcher'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { concat } from 'uint8arrays/concat'\nimport { fromString as uint8arrayFromString } from 'uint8arrays/from-string'\nimport { dataChannelError, inappropriateMultiaddr, unimplemented, invalidArgument } from '../error.js'\nimport { WebRTCMultiaddrConnection } from '../maconn.js'\nimport { DataChannelMuxerFactory } from '../muxer.js'\nimport { createStream } from '../stream.js'\nimport { getRtcConfiguration, isFirefox } from '../util.js'\nimport { RTCPeerConnection } from '../webrtc/index.js'\nimport * as sdp from './sdp.js'\nimport { genUfrag } from './util.js'\nimport type { WebRTCDialOptions } from './options.js'\nimport type { DataChannelOptions } from '../index.js'\nimport type { CreateListenerOptions, Transport, Listener, ComponentLogger, Logger, Connection, CounterGroup, Metrics, PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * The time to wait, in milliseconds, for the data channel handshake to complete\n */\nconst HANDSHAKE_TIMEOUT_MS = 10_000\n\n/**\n * Created by converting the hexadecimal protocol code to an integer.\n *\n * {@link https://github.com/multiformats/multiaddr/blob/master/protocols.csv}\n */\nexport const WEBRTC_CODE: number = protocols('webrtc-direct').code\n\n/**\n * Created by converting the hexadecimal protocol code to an integer.\n *\n * {@link https://github.com/multiformats/multiaddr/blob/master/protocols.csv}\n */\nexport const CERTHASH_CODE: number = protocols('certhash').code\n\n/**\n * The peer for this transport\n */\nexport interface WebRTCDirectTransportComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  logger: ComponentLogger\n}\n\nexport interface WebRTCMetrics {\n  dialerEvents: CounterGroup\n}\n\nexport interface WebRTCTransportDirectInit {\n  rtcConfiguration?: RTCConfiguration | (() => RTCConfiguration | Promise<RTCConfiguration>)\n  dataChannel?: DataChannelOptions\n}\n\nexport class WebRTCDirectTransport implements Transport {\n  private readonly log: Logger\n  private readonly metrics?: WebRTCMetrics\n  private readonly components: WebRTCDirectTransportComponents\n  private readonly init: WebRTCTransportDirectInit\n  constructor (components: WebRTCDirectTransportComponents, init: WebRTCTransportDirectInit = {}) {\n    this.log = components.logger.forComponent('libp2p:webrtc-direct')\n    this.components = components\n    this.init = init\n    if (components.metrics != null) {\n      this.metrics = {\n        dialerEvents: components.metrics.registerCounterGroup('libp2p_webrtc-direct_dialer_events_total', {\n          label: 'event',\n          help: 'Total count of WebRTC-direct dial events by type'\n        })\n      }\n    }\n  }\n\n  readonly [transportSymbol] = true\n\n  readonly [Symbol.toStringTag] = '@libp2p/webrtc-direct'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport'\n  ]\n\n  /**\n   * Dial a given multiaddr\n   */\n  async dial (ma: Multiaddr, options: WebRTCDialOptions): Promise<Connection> {\n    const rawConn = await this._connect(ma, options)\n    this.log('dialing address: %a', ma)\n    return rawConn\n  }\n\n  /**\n   * Create transport listeners no supported by browsers\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    throw unimplemented('WebRTCTransport.createListener')\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return multiaddrs.filter(WebRTCDirect.exactMatch)\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n\n  /**\n   * Connect to a peer using a multiaddr\n   */\n  async _connect (ma: Multiaddr, options: WebRTCDialOptions): Promise<Connection> {\n    const controller = new AbortController()\n    const signal = controller.signal\n\n    const remotePeerString = ma.getPeerId()\n    if (remotePeerString === null) {\n      throw inappropriateMultiaddr(\"we need to have the remote's PeerId\")\n    }\n    const theirPeerId = p.peerIdFromString(remotePeerString)\n\n    const remoteCerthash = sdp.decodeCerthash(sdp.certhash(ma))\n\n    // ECDSA is preferred over RSA here. From our testing we find that P-256 elliptic\n    // curve is supported by Pion, webrtc-rs, as well as Chromium (P-228 and P-384\n    // was not supported in Chromium). We use the same hash function as found in the\n    // multiaddr if it is supported.\n    const certificate = await RTCPeerConnection.generateCertificate({\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n      hash: sdp.toSupportedHashFunction(remoteCerthash.code)\n    } as any)\n\n    const peerConnection = new RTCPeerConnection({\n      ...(await getRtcConfiguration(this.init.rtcConfiguration)),\n      certificates: [certificate]\n    })\n\n    try {\n      // create data channel for running the noise handshake. Once the data channel is opened,\n      // the remote will initiate the noise handshake. This is used to confirm the identity of\n      // the peer.\n      const dataChannelOpenPromise = new Promise<RTCDataChannel>((resolve, reject) => {\n        const handshakeDataChannel = peerConnection.createDataChannel('', { negotiated: true, id: 0 })\n        const handshakeTimeout = setTimeout(() => {\n          const error = `Data channel was never opened: state: ${handshakeDataChannel.readyState}`\n          this.log.error(error)\n          this.metrics?.dialerEvents.increment({ open_error: true })\n          reject(dataChannelError('data', error))\n        }, HANDSHAKE_TIMEOUT_MS)\n\n        handshakeDataChannel.onopen = (_) => {\n          clearTimeout(handshakeTimeout)\n          resolve(handshakeDataChannel)\n        }\n\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/error_event\n        handshakeDataChannel.onerror = (event: Event) => {\n          clearTimeout(handshakeTimeout)\n          const errorTarget = event.target?.toString() ?? 'not specified'\n          const error = `Error opening a data channel for handshaking: ${errorTarget}`\n          this.log.error(error)\n          // NOTE: We use unknown error here but this could potentially be considered a reset by some standards.\n          this.metrics?.dialerEvents.increment({ unknown_error: true })\n          reject(dataChannelError('data', error))\n        }\n      })\n\n      const ufrag = 'libp2p+webrtc+v1/' + genUfrag(32)\n\n      // Create offer and munge sdp with ufrag == pwd. This allows the remote to\n      // respond to STUN messages without performing an actual SDP exchange.\n      // This is because it can infer the passwd field by reading the USERNAME\n      // attribute of the STUN message.\n      const offerSdp = await peerConnection.createOffer()\n      const mungedOfferSdp = sdp.munge(offerSdp, ufrag)\n      await peerConnection.setLocalDescription(mungedOfferSdp)\n\n      // construct answer sdp from multiaddr and ufrag\n      const answerSdp = sdp.fromMultiAddr(ma, ufrag)\n      await peerConnection.setRemoteDescription(answerSdp)\n\n      // wait for peerconnection.onopen to fire, or for the datachannel to open\n      const handshakeDataChannel = await dataChannelOpenPromise\n\n      const myPeerId = this.components.peerId\n\n      // Do noise handshake.\n      // Set the Noise Prologue to libp2p-webrtc-noise:<FINGERPRINTS> before starting the actual Noise handshake.\n      // <FINGERPRINTS> is the concatenation of the of the two TLS fingerprints of A and B in their multihash byte representation, sorted in ascending order.\n      const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma)\n\n      // Since we use the default crypto interface and do not use a static key or early data,\n      // we pass in undefined for these parameters.\n      const connectionEncrypter = noise({ prologueBytes: fingerprintsPrologue })(this.components)\n\n      const wrappedChannel = createStream({\n        channel: handshakeDataChannel,\n        direction: 'inbound',\n        logger: this.components.logger,\n        ...(this.init.dataChannel ?? {})\n      })\n      const wrappedDuplex = {\n        ...wrappedChannel,\n        sink: wrappedChannel.sink.bind(wrappedChannel),\n        source: (async function * () {\n          for await (const list of wrappedChannel.source) {\n            for (const buf of list) {\n              yield buf\n            }\n          }\n        }())\n      }\n\n      // Creating the connection before completion of the noise\n      // handshake ensures that the stream opening callback is set up\n      const maConn = new WebRTCMultiaddrConnection(this.components, {\n        peerConnection,\n        remoteAddr: ma,\n        timeline: {\n          open: Date.now()\n        },\n        metrics: this.metrics?.dialerEvents\n      })\n\n      const eventListeningName = isFirefox ? 'iceconnectionstatechange' : 'connectionstatechange'\n\n      peerConnection.addEventListener(eventListeningName, () => {\n        switch (peerConnection.connectionState) {\n          case 'failed':\n          case 'disconnected':\n          case 'closed':\n            maConn.close().catch((err) => {\n              this.log.error('error closing connection', err)\n            }).finally(() => {\n              // Remove the event listener once the connection is closed\n              controller.abort()\n            })\n            break\n          default:\n            break\n        }\n      }, { signal })\n\n      // Track opened peer connection\n      this.metrics?.dialerEvents.increment({ peer_connection: true })\n\n      const muxerFactory = new DataChannelMuxerFactory(this.components, {\n        peerConnection,\n        metrics: this.metrics?.dialerEvents,\n        dataChannelOptions: this.init.dataChannel\n      })\n\n      // For outbound connections, the remote is expected to start the noise handshake.\n      // Therefore, we need to secure an inbound noise connection from the remote.\n      await connectionEncrypter.secureInbound(myPeerId, wrappedDuplex, theirPeerId)\n\n      return await options.upgrader.upgradeOutbound(maConn, { skipProtection: true, skipEncryption: true, muxerFactory })\n    } catch (err) {\n      peerConnection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Generate a noise prologue from the peer connection's certificate.\n   * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint\n   */\n  private generateNoisePrologue (pc: RTCPeerConnection, hashCode: number, ma: Multiaddr): Uint8Array {\n    if (pc.getConfiguration().certificates?.length === 0) {\n      throw invalidArgument('no local certificate')\n    }\n\n    const localFingerprint = sdp.getLocalFingerprint(pc, {\n      log: this.log\n    })\n    if (localFingerprint == null) {\n      throw invalidArgument('no local fingerprint found')\n    }\n\n    const localFpString = localFingerprint.trim().toLowerCase().replaceAll(':', '')\n    const localFpArray = uint8arrayFromString(localFpString, 'hex')\n    const local = Digest.create(hashCode, localFpArray)\n    const remote: Uint8Array = sdp.mbdecoder.decode(sdp.certhash(ma))\n    const prefix = uint8arrayFromString('libp2p-webrtc-noise:')\n\n    return concat([prefix, local.bytes, remote])\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebRTC datachannels](https://webrtc.org/).\n *\n * [WebRTC](https://www.w3.org/TR/webrtc/) is a specification that allows real-time communication between nodes - it's commonly used in browser video conferencing applications but it also provides a reliable data transport mechanism called [data channels](https://www.w3.org/TR/webrtc/#peer-to-peer-data-api) which libp2p uses to facilitate [protocol streams](https://docs.libp2p.io/concepts/multiplex/overview/) between peers.\n *\n * There are two transports exposed by this module, [webRTC](https://github.com/libp2p/specs/blob/master/webrtc/webrtc.md) and [webRTCDirect](https://github.com/libp2p/specs/blob/master/webrtc/webrtc-direct.md).\n *\n * ## WebRTC vs WebRTC Direct\n *\n * The connection establishment phase of WebRTC involves a handshake using [SDP](https://en.wikipedia.org/wiki/Session_Description_Protocol) during which two peers will exchange information such as open ports, network addresses and required capabilities.\n *\n * A third party is usually necessary to carry out this handshake, forwarding messages between the two peers until they can make a direct connection between themselves.\n *\n * The WebRTC transport uses libp2p [Circuit Relay](https://docs.libp2p.io/concepts/nat/circuit-relay/)s to forward SDP messages. Once a direct connection is formed the relay plays no further part in the exchange.\n *\n * WebRTC Direct uses a technique known as [SDP munging](https://webrtchacks.com/not-a-guide-to-sdp-munging/) to skip the handshake step, instead encoding enough information in the connection request that the responder can derive what would have been in the handshake messages and so requires no third parties to establish a connection.\n *\n * A WebRTC Direct multiaddr also includes a certhash of the target peer - this is used to allow opening a connection to the remote, which would otherwise be denied due to use of a self-signed certificate.\n *\n * In both cases, once the connection is established a [Noise handshake](https://noiseprotocol.org/noise.html) is carried out to ensure that the remote peer has the private key that corresponds to the public key that makes up their PeerId, giving you both encryption and authentication.\n *\n * ## Support\n *\n * WebRTC is supported in both Node.js and browsers.\n *\n * At the time of writing, WebRTC Direct is dial-only in browsers and not supported in Node.js at all.\n *\n * Support in Node.js is possible but PRs will need to be opened to [libdatachannel](https://github.com/paullouisageneau/libdatachannel) and the appropriate APIs exposed in [node-datachannel](https://github.com/murat-dogan/node-datachannel).\n *\n * WebRTC Direct support is available in rust-libp2p and arriving soon in go-libp2p.\n *\n * See the WebRTC section of https://connectivity.libp2p.io for more information.\n *\n * @example WebRTC\n *\n * WebRTC requires use of a relay to connect two nodes. The listener first discovers a relay server and makes a reservation, then the dialer can connect via the relayed address.\n *\n * ```TypeScript\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { echo } from '@libp2p/echo'\n * import { circuitRelayTransport, circuitRelayServer } from '@libp2p/circuit-relay-v2'\n * import { identify } from '@libp2p/identify'\n * import { webRTC } from '@libp2p/webrtc'\n * import { webSockets } from '@libp2p/websockets'\n * import * as filters from '@libp2p/websockets/filters'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n * import delay from 'delay'\n * import { pipe } from 'it-pipe'\n * import { createLibp2p } from 'libp2p'\n * import type { Multiaddr } from '@multiformats/multiaddr'\n *\n * // the relay server listens on a transport dialable by the listener and the\n * // dialer, and has a relay service configured\n * const relay = await createLibp2p({\n *   addresses: {\n *   listen: ['/ip4/127.0.0.1/tcp/0/ws']\n *   },\n *   transports: [\n *     webSockets({filter: filters.all})\n *   ],\n *   connectionEncryption: [noise()],\n *   streamMuxers: [yamux()],\n *   services: {\n *     identify: identify(),\n *     relay: circuitRelayServer()\n *   }\n * })\n *\n * // the listener has a WebSocket transport to dial the relay, a Circuit Relay\n * // transport to make a reservation, and a WebRTC transport to accept incoming\n * // WebRTC connections\n * const listener = await createLibp2p({\n *   addresses: {\n *   listen: ['/webrtc']\n *   },\n *   transports: [\n *     webSockets({filter: filters.all}),\n *     webRTC(),\n *     circuitRelayTransport({\n *       discoverRelays: 1\n *     })\n *   ],\n *   connectionEncryption: [noise()],\n *   streamMuxers: [yamux()],\n *   services: {\n *     identify: identify(),\n *     echo: echo()\n *   }\n * })\n *\n * // the listener dials the relay (or discovers a public relay via some other\n * // method)\n * await listener.dial(relay.getMultiaddrs(), {\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * let webRTCMultiaddr: Multiaddr | undefined\n *\n * // wait for the listener to make a reservation on the relay\n * while (true) {\n *   webRTCMultiaddr = listener.getMultiaddrs().find(ma => WebRTC.matches(ma))\n *\n *   if (webRTCMultiaddr != null) {\n *     break\n *   }\n *\n *   // try again later\n *   await delay(1000)\n * }\n *\n * // the dialer has Circuit Relay, WebSocket and WebRTC transports to dial\n * // the listener via the relay, complete the SDP handshake and establish a\n * // direct WebRTC connection\n * const dialer = await createLibp2p({\n *   transports: [\n *     webSockets({filter: filters.all}),\n *     webRTC(),\n *     circuitRelayTransport()\n *   ],\n *   connectionEncryption: [noise()],\n *   streamMuxers: [yamux()],\n *   services: {\n *     identify: identify(),\n *     echo: echo()\n *   }\n * })\n *\n * // dial the listener and open an echo protocol stream\n * const stream = await dialer.dialProtocol(webRTCMultiaddr, dialer.services.echo.protocol, {\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * // we can now stop the relay\n * await relay.stop()\n *\n * // send/receive some data from the remote peer via a direct connection\n * await pipe(\n *   [new TextEncoder().encode('hello world')],\n *   stream,\n *   async source => {\n *     for await (const buf of source) {\n *       console.info(new TextDecoder().decode(buf.subarray()))\n *     }\n *   }\n * )\n * ```\n *\n * @example WebRTC Direct\n *\n * At the time of writing WebRTC Direct is dial-only in browsers and unsupported in Node.js.\n *\n * The only implementation that supports a WebRTC Direct listener is go-libp2p and it's not yet enabled by default.\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { pipe } from 'it-pipe'\n * import { fromString, toString } from 'uint8arrays'\n * import { webRTCDirect } from '@libp2p/webrtc'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webRTCDirect()\n *   ],\n *   connectionEncryption: [\n *     noise()\n *   ]\n * })\n *\n * await node.start()\n *\n * // this multiaddr corresponds to a remote node running a WebRTC Direct listener\n * const ma = multiaddr('/ip4/0.0.0.0/udp/56093/webrtc-direct/certhash/uEiByaEfNSLBexWBNFZy_QB1vAKEj7JAXDizRs4_SnTflsQ')\n * const stream = await node.dialProtocol(ma, '/my-protocol/1.0.0', {\n *   signal: AbortSignal.timeout(10_000)\n * })\n *\n * await pipe(\n *   [fromString(`Hello js-libp2p-webrtc\\n`)],\n *   stream,\n *   async function (source) {\n *     for await (const buf of source) {\n *       console.info(toString(buf.subarray()))\n *     }\n *   }\n * )\n * ```\n */\n\nimport { WebRTCTransport } from './private-to-private/transport.js'\nimport { WebRTCDirectTransport, type WebRTCTransportDirectInit, type WebRTCDirectTransportComponents } from './private-to-public/transport.js'\nimport type { WebRTCTransportComponents, WebRTCTransportInit } from './private-to-private/transport.js'\nimport type { Transport } from '@libp2p/interface'\n\nexport interface DataChannelOptions {\n  /**\n   * The maximum message size sendable over the channel in bytes (default 16KB)\n   */\n  maxMessageSize?: number\n\n  /**\n   * If the channel's `bufferedAmount` grows over this amount in bytes, wait\n   * for it to drain before sending more data (default: 16MB)\n   */\n  maxBufferedAmount?: number\n\n  /**\n   * When `bufferedAmount` is above `maxBufferedAmount`, we pause sending until\n   * the `bufferedAmountLow` event fires - this controls how long we wait for\n   * that event in ms (default: 30s)\n   */\n  bufferedAmountLowEventTimeout?: number\n\n  /**\n   * When closing a stream, we wait for `bufferedAmount` to become 0 before\n   * closing the underlying RTCDataChannel - this controls how long we wait\n   * in ms (default: 30s)\n   */\n  drainTimeout?: number\n\n  /**\n   * When closing a stream we first send a FIN flag to the remote and wait\n   * for a FIN_ACK reply before closing the underlying RTCDataChannel - this\n   * controls how long we wait for the acknowledgement in ms (default: 5s)\n   */\n  closeTimeout?: number\n\n  /**\n   * When sending the first data message, if the channel is not in the \"open\"\n   * state, wait this long for the \"open\" event to fire.\n   */\n  openTimeout?: number\n}\n\n/**\n * @param {WebRTCTransportDirectInit} init - WebRTC direct transport configuration\n * @param init.dataChannel - DataChannel configurations\n * @param {number} init.dataChannel.maxMessageSize - Max message size that can be sent through the DataChannel. Larger messages will be chunked into smaller messages below this size (default 16kb)\n * @param {number} init.dataChannel.maxBufferedAmount - Max buffered amount a DataChannel can have (default 16mb)\n * @param {number} init.dataChannel.bufferedAmountLowEventTimeout - If max buffered amount is reached, this is the max time that is waited before the buffer is cleared (default 30 seconds)\n * @returns\n */\nfunction webRTCDirect (init?: WebRTCTransportDirectInit): (components: WebRTCDirectTransportComponents) => Transport {\n  return (components: WebRTCDirectTransportComponents) => new WebRTCDirectTransport(components, init)\n}\n\n/**\n * @param {WebRTCTransportInit} init - WebRTC transport configuration\n * @param {RTCConfiguration} init.rtcConfiguration - RTCConfiguration\n * @param init.dataChannel - DataChannel configurations\n * @param {number} init.dataChannel.maxMessageSize - Max message size that can be sent through the DataChannel. Larger messages will be chunked into smaller messages below this size (default 16kb)\n * @param {number} init.dataChannel.maxBufferedAmount - Max buffered amount a DataChannel can have (default 16mb)\n * @param {number} init.dataChannel.bufferedAmountLowEventTimeout - If max buffered amount is reached, this is the max time that is waited before the buffer is cleared (default 30 seconds)\n * @returns\n */\nfunction webRTC (init?: WebRTCTransportInit): (components: WebRTCTransportComponents) => Transport {\n  return (components: WebRTCTransportComponents) => new WebRTCTransport(components, init)\n}\n\nexport { webRTC, webRTCDirect }\n"],
  "mappings": "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",
  "names": ["codes", "BrowserInfo", "NodeInfo", "SearchBotDeviceInfo", "BotInfo", "ReactNativeInfo", "browser", "event", "Message", "Flag", "__FlagValues", "err", "message", "Message", "Type", "__TypeValues", "message", "Message", "Message", "Message", "certhash", "handshakeDataChannel"]
}
