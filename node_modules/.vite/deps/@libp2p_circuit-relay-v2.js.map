{
  "version": 3,
  "sources": ["../../../../../node_modules/@libp2p/circuit-relay-v2/src/constants.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/pb/index.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/utils.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/reservation-store.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/reservation-voucher.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/server/index.ts", "../../../../../node_modules/@libp2p/utils/src/stream-to-ma-conn.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/discovery.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/listener.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/reservation-store.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/transport.ts", "../../../../../node_modules/@libp2p/circuit-relay-v2/src/transport/index.ts"],
  "sourcesContent": ["const second = 1000\nconst minute = 60 * second\n\n/**\n * Multicodec code\n */\nexport const CIRCUIT_PROTO_CODE = 290\n\n/**\n * The maximum number of relay reservations the relay server will accept\n */\nexport const DEFAULT_MAX_RESERVATION_STORE_SIZE = 15\n\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second\n\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute\n\n/**\n * How many reservation attempts to make in parallel\n */\nexport const DEFAULT_RESERVATION_CONCURRENCY = 1\n\n/**\n * How long to wait for a reservation attempt to finsih\n */\nexport const DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 1000\n\n/**\n * How long to let the reservation attempt queue to grow\n */\nexport const DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100\n\nexport const RELAY_SOURCE_TAG = 'circuit-relay-source'\n\nexport const RELAY_TAG = 'circuit-relay-relay'\n\n// circuit v2 connection limits\n// https://github.com/libp2p/go-libp2p/blob/master/p2p/protocol/circuitv2/relay/resources.go#L61-L66\n\n// 2 min is the default connection duration\nexport const DEFAULT_DURATION_LIMIT = 2 * minute\n\n// 128k is the default data limit\nexport const DEFAULT_DATA_LIMIT = BigInt(1 << 17)\n\n/**\n * The hop protocol\n */\nexport const RELAY_V2_HOP_CODEC = '/libp2p/circuit/relay/0.2.0/hop'\n\n/**\n * the stop protocol\n */\nexport const RELAY_V2_STOP_CODEC = '/libp2p/circuit/relay/0.2.0/stop'\n\n/**\n * Hop messages must be exchanged inside this timeout\n */\nexport const DEFAULT_HOP_TIMEOUT = 30 * second\n\n/**\n * How long to wait before starting to advertise the relay service\n */\nexport const DEFAULT_ADVERT_BOOT_DELAY = 30 * second\n\nexport const MAX_CONNECTIONS = 300\n\nexport const ERR_NO_ROUTERS_AVAILABLE = 'ERR_NO_ROUTERS_AVAILABLE'\nexport const ERR_RELAYED_DIAL = 'ERR_RELAYED_DIAL'\nexport const ERR_HOP_REQUEST_FAILED = 'ERR_HOP_REQUEST_FAILED'\nexport const ERR_TRANSFER_LIMIT_EXCEEDED = 'ERR_TRANSFER_LIMIT_EXCEEDED'\n\nexport const DEFAULT_DISCOVERY_FILTER_SIZE = 4096\nexport const DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 0.001\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, CodeError, decodeMessage, type DecodeOptions, encodeMessage, enumeration, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface HopMessage {\n  type?: HopMessage.Type\n  peer?: Peer\n  reservation?: Reservation\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace HopMessage {\n  export enum Type {\n    RESERVE = 'RESERVE',\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    RESERVE = 0,\n    CONNECT = 1,\n    STATUS = 2\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<HopMessage>\n\n  export const codec = (): Codec<HopMessage> => {\n    if (_codec == null) {\n      _codec = message<HopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          HopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.reservation != null) {\n          w.uint32(26)\n          Reservation.codec().encode(obj.reservation, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(34)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(40)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.type = HopMessage.Type.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.peer = Peer.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.peer\n              })\n              break\n            }\n            case 3: {\n              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.reservation\n              })\n              break\n            }\n            case 4: {\n              obj.limit = Limit.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.limit\n              })\n              break\n            }\n            case 5: {\n              obj.status = Status.codec().decode(reader)\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<HopMessage>): Uint8Array => {\n    return encodeMessage(obj, HopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<HopMessage>): HopMessage => {\n    return decodeMessage(buf, HopMessage.codec(), opts)\n  }\n}\n\nexport interface StopMessage {\n  type?: StopMessage.Type\n  peer?: Peer\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace StopMessage {\n  export enum Type {\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    CONNECT = 0,\n    STATUS = 1\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<StopMessage>\n\n  export const codec = (): Codec<StopMessage> => {\n    if (_codec == null) {\n      _codec = message<StopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          StopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(26)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(32)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.type = StopMessage.Type.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.peer = Peer.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.peer\n              })\n              break\n            }\n            case 3: {\n              obj.limit = Limit.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.limit\n              })\n              break\n            }\n            case 4: {\n              obj.status = Status.codec().decode(reader)\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<StopMessage>): Uint8Array => {\n    return encodeMessage(obj, StopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<StopMessage>): StopMessage => {\n    return decodeMessage(buf, StopMessage.codec(), opts)\n  }\n}\n\nexport interface Peer {\n  id: Uint8Array\n  addrs: Uint8Array[]\n}\n\nexport namespace Peer {\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.id != null && obj.id.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          id: uint8ArrayAlloc(0),\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.id = reader.bytes()\n              break\n            }\n            case 2: {\n              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {\n                throw new CodeError('decode error - map field \"addrs\" had too many elements', 'ERR_MAX_LENGTH')\n              }\n\n              obj.addrs.push(reader.bytes())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer>): Peer => {\n    return decodeMessage(buf, Peer.codec(), opts)\n  }\n}\n\nexport interface Reservation {\n  expire: bigint\n  addrs: Uint8Array[]\n  voucher?: Uint8Array\n}\n\nexport namespace Reservation {\n  let _codec: Codec<Reservation>\n\n  export const codec = (): Codec<Reservation> => {\n    if (_codec == null) {\n      _codec = message<Reservation>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.expire != null && obj.expire !== 0n)) {\n          w.uint32(8)\n          w.uint64(obj.expire)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.voucher != null) {\n          w.uint32(26)\n          w.bytes(obj.voucher)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          expire: 0n,\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.expire = reader.uint64()\n              break\n            }\n            case 2: {\n              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {\n                throw new CodeError('decode error - map field \"addrs\" had too many elements', 'ERR_MAX_LENGTH')\n              }\n\n              obj.addrs.push(reader.bytes())\n              break\n            }\n            case 3: {\n              obj.voucher = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Reservation>): Uint8Array => {\n    return encodeMessage(obj, Reservation.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Reservation>): Reservation => {\n    return decodeMessage(buf, Reservation.codec(), opts)\n  }\n}\n\nexport interface Limit {\n  duration?: number\n  data?: bigint\n}\n\nexport namespace Limit {\n  let _codec: Codec<Limit>\n\n  export const codec = (): Codec<Limit> => {\n    if (_codec == null) {\n      _codec = message<Limit>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.duration != null) {\n          w.uint32(8)\n          w.uint32(obj.duration)\n        }\n\n        if (obj.data != null) {\n          w.uint32(16)\n          w.uint64(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.duration = reader.uint32()\n              break\n            }\n            case 2: {\n              obj.data = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Limit>): Uint8Array => {\n    return encodeMessage(obj, Limit.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Limit>): Limit => {\n    return decodeMessage(buf, Limit.codec(), opts)\n  }\n}\n\nexport enum Status {\n  UNUSED = 'UNUSED',\n  OK = 'OK',\n  RESERVATION_REFUSED = 'RESERVATION_REFUSED',\n  RESOURCE_LIMIT_EXCEEDED = 'RESOURCE_LIMIT_EXCEEDED',\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  CONNECTION_FAILED = 'CONNECTION_FAILED',\n  NO_RESERVATION = 'NO_RESERVATION',\n  MALFORMED_MESSAGE = 'MALFORMED_MESSAGE',\n  UNEXPECTED_MESSAGE = 'UNEXPECTED_MESSAGE'\n}\n\nenum __StatusValues {\n  UNUSED = 0,\n  OK = 100,\n  RESERVATION_REFUSED = 200,\n  RESOURCE_LIMIT_EXCEEDED = 201,\n  PERMISSION_DENIED = 202,\n  CONNECTION_FAILED = 203,\n  NO_RESERVATION = 204,\n  MALFORMED_MESSAGE = 400,\n  UNEXPECTED_MESSAGE = 401\n}\n\nexport namespace Status {\n  export const codec = (): Codec<Status> => {\n    return enumeration<Status>(__StatusValues)\n  }\n}\nexport interface ReservationVoucher {\n  relay: Uint8Array\n  peer: Uint8Array\n  expiration: bigint\n}\n\nexport namespace ReservationVoucher {\n  let _codec: Codec<ReservationVoucher>\n\n  export const codec = (): Codec<ReservationVoucher> => {\n    if (_codec == null) {\n      _codec = message<ReservationVoucher>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.relay != null && obj.relay.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.relay)\n        }\n\n        if ((obj.peer != null && obj.peer.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.peer)\n        }\n\n        if ((obj.expiration != null && obj.expiration !== 0n)) {\n          w.uint32(24)\n          w.uint64(obj.expiration)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          relay: uint8ArrayAlloc(0),\n          peer: uint8ArrayAlloc(0),\n          expiration: 0n\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.relay = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.peer = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.expiration = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ReservationVoucher>): Uint8Array => {\n    return encodeMessage(obj, ReservationVoucher.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ReservationVoucher>): ReservationVoucher => {\n    return decodeMessage(buf, ReservationVoucher.codec(), opts)\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { anySignal } from 'any-signal'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { ERR_TRANSFER_LIMIT_EXCEEDED } from './constants.js'\nimport type { Limit } from './pb/index.js'\nimport type { LoggerOptions, Stream } from '@libp2p/interface'\nimport type { Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nasync function * countStreamBytes (source: Source<Uint8Array | Uint8ArrayList>, limit: { remaining: bigint }, options: LoggerOptions): AsyncGenerator<Uint8Array | Uint8ArrayList, void, unknown> {\n  const limitBytes = limit.remaining\n\n  for await (const buf of source) {\n    const len = BigInt(buf.byteLength)\n\n    if ((limit.remaining - len) < 0) {\n      // this is a safe downcast since len is guarantee to be in the range for a number\n      const remaining = Number(limit.remaining)\n      limit.remaining = 0n\n\n      try {\n        if (remaining !== 0) {\n          yield buf.subarray(0, remaining)\n        }\n      } catch (err: any) {\n        options.log.error(err)\n      }\n\n      throw new CodeError(`data limit of ${limitBytes} bytes exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED)\n    }\n\n    limit.remaining -= len\n    yield buf\n  }\n}\n\nexport function createLimitedRelay (src: Stream, dst: Stream, abortSignal: AbortSignal, limit: Limit | undefined, options: LoggerOptions): void {\n  function abortStreams (err: Error): void {\n    src.abort(err)\n    dst.abort(err)\n  }\n\n  const signals = [abortSignal]\n\n  if (limit?.duration != null) {\n    signals.push(AbortSignal.timeout(limit.duration))\n  }\n\n  const signal = anySignal(signals)\n\n  let srcDstFinished = false\n  let dstSrcFinished = false\n\n  let dataLimit: { remaining: bigint } | undefined\n\n  if (limit?.data != null) {\n    dataLimit = {\n      remaining: limit.data\n    }\n  }\n\n  queueMicrotask(() => {\n    const onAbort = (): void => {\n      dst.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    void dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options))\n      .catch(err => {\n        options.log.error('error while relaying streams src -> dst', err)\n        abortStreams(err)\n      })\n      .finally(() => {\n        srcDstFinished = true\n\n        if (dstSrcFinished) {\n          signal.removeEventListener('abort', onAbort)\n          signal.clear()\n        }\n      })\n  })\n\n  queueMicrotask(() => {\n    const onAbort = (): void => {\n      src.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    void src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options))\n      .catch(err => {\n        options.log.error('error while relaying streams dst -> src', err)\n        abortStreams(err)\n      })\n      .finally(() => {\n        dstSrcFinished = true\n\n        if (srcDstFinished) {\n          signal.removeEventListener('abort', onAbort)\n          signal.clear()\n        }\n      })\n  })\n}\n\n/**\n * Convert a namespace string into a cid\n */\nexport async function namespaceToCid (namespace: string): Promise<CID> {\n  const bytes = new TextEncoder().encode(namespace)\n  const hash = await sha256.digest(bytes)\n\n  return CID.createV0(hash)\n}\n\n/**\n * returns number of ms between now and expiration time\n */\nexport function getExpirationMilliseconds (expireTimeSeconds: bigint): number {\n  const expireTimeMillis = expireTimeSeconds * BigInt(1000)\n  const currentTime = new Date().getTime()\n\n  // downcast to number to use with setTimeout\n  return Number(expireTimeMillis - BigInt(currentTime))\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT, DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL, DEFAULT_MAX_RESERVATION_STORE_SIZE, DEFAULT_MAX_RESERVATION_TTL } from '../constants.js'\nimport { type Limit, Status } from '../pb/index.js'\nimport type { RelayReservation } from '../index.js'\nimport type { PeerId, Startable } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type ReservationStatus = Status.OK | Status.PERMISSION_DENIED | Status.RESERVATION_REFUSED\n\nexport interface ReservationStoreInit {\n  /*\n   * maximum number of reservations allowed, default: 15\n   */\n  maxReservations?: number\n  /*\n   * interval after which stale reservations are cleared, default: 300s\n   */\n  reservationClearInterval?: number\n  /*\n   * apply default relay limits to a new reservation, default: true\n   */\n  applyDefaultLimit?: boolean\n  /**\n   * reservation ttl, default: 2 hours\n   */\n  reservationTtl?: number\n  /**\n   * The maximum time a relayed connection can be open for\n   */\n  defaultDurationLimit?: number\n  /**\n   * The maximum amount of data allowed to be transferred over a relayed connection\n   */\n  defaultDataLimit?: bigint\n}\n\nexport class ReservationStore implements Startable {\n  public readonly reservations = new PeerMap<RelayReservation>()\n  private _started = false\n  private interval: any\n  private readonly maxReservations: number\n  private readonly reservationClearInterval: number\n  private readonly applyDefaultLimit: boolean\n  private readonly reservationTtl: number\n  private readonly defaultDurationLimit: number\n  private readonly defaultDataLimit: bigint\n\n  constructor (options: ReservationStoreInit = {}) {\n    this.maxReservations = options.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE\n    this.reservationClearInterval = options.reservationClearInterval ?? DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL\n    this.applyDefaultLimit = options.applyDefaultLimit !== false\n    this.reservationTtl = options.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL\n    this.defaultDurationLimit = options.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT\n    this.defaultDataLimit = options.defaultDataLimit ?? DEFAULT_DATA_LIMIT\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  start (): void {\n    if (this._started) {\n      return\n    }\n    this._started = true\n    this.interval = setInterval(\n      () => {\n        const now = (new Date()).getTime()\n        this.reservations.forEach((r, k) => {\n          if (r.expire.getTime() < now) {\n            this.reservations.delete(k)\n          }\n        })\n      },\n      this.reservationClearInterval\n    )\n  }\n\n  stop (): void {\n    clearInterval(this.interval)\n  }\n\n  reserve (peer: PeerId, addr: Multiaddr, limit?: Limit): { status: ReservationStatus, expire?: number } {\n    if (this.reservations.size >= this.maxReservations && !this.reservations.has(peer)) {\n      return { status: Status.RESERVATION_REFUSED }\n    }\n\n    const expire = new Date(Date.now() + this.reservationTtl)\n    let checkedLimit: Limit | undefined\n\n    if (this.applyDefaultLimit) {\n      checkedLimit = limit ?? { data: this.defaultDataLimit, duration: this.defaultDurationLimit }\n    }\n\n    this.reservations.set(peer, { addr, expire, limit: checkedLimit })\n\n    // return expiry time in seconds\n    return { status: Status.OK, expire: Math.round(expire.getTime() / 1000) }\n  }\n\n  removeReservation (peer: PeerId): void {\n    this.reservations.delete(peer)\n  }\n\n  hasReservation (dst: PeerId): boolean {\n    return this.reservations.has(dst)\n  }\n\n  get (peer: PeerId): RelayReservation | undefined {\n    return this.reservations.get(peer)\n  }\n}\n", "import { ReservationVoucher } from '../pb/index.js'\nimport type { PeerId, Record } from '@libp2p/interface'\n\nexport interface ReservationVoucherOptions {\n  relay: PeerId\n  peer: PeerId\n  expiration: number\n}\n\nexport class ReservationVoucherRecord implements Record {\n  public readonly domain = 'libp2p-relay-rsvp'\n  public readonly codec = new Uint8Array([0x03, 0x02])\n\n  private readonly relay: PeerId\n  private readonly peer: PeerId\n  private readonly expiration: number\n\n  constructor ({ relay, peer, expiration }: ReservationVoucherOptions) {\n    this.relay = relay\n    this.peer = peer\n    this.expiration = expiration\n  }\n\n  marshal (): Uint8Array {\n    return ReservationVoucher.encode({\n      relay: this.relay.toBytes(),\n      peer: this.peer.toBytes(),\n      expiration: BigInt(this.expiration)\n    })\n  }\n\n  equals (other: Record): boolean {\n    if (!(other instanceof ReservationVoucherRecord)) {\n      return false\n    }\n    if (!this.peer.equals(other.peer)) {\n      return false\n    }\n\n    if (!this.relay.equals(other.relay)) {\n      return false\n    }\n\n    if (this.expiration !== other.expiration) {\n      return false\n    }\n\n    return true\n  }\n}\n", "import { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { RecordEnvelope } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { pbStream, type ProtobufStream } from 'it-protobuf-stream'\nimport pDefer from 'p-defer'\nimport {\n  CIRCUIT_PROTO_CODE,\n  DEFAULT_HOP_TIMEOUT,\n  MAX_CONNECTIONS,\n  RELAY_SOURCE_TAG,\n  RELAY_V2_HOP_CODEC,\n  RELAY_V2_STOP_CODEC\n} from '../constants.js'\nimport { HopMessage, type Reservation, Status, StopMessage } from '../pb/index.js'\nimport { createLimitedRelay } from '../utils.js'\nimport { ReservationStore, type ReservationStoreInit } from './reservation-store.js'\nimport { ReservationVoucherRecord } from './reservation-voucher.js'\nimport type { CircuitRelayService, RelayReservation } from '../index.js'\nimport type { ComponentLogger, Logger, Connection, Stream, ConnectionGater, PeerId, PeerStore, Startable } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, IncomingStreamData, Registrar } from '@libp2p/interface-internal'\nimport type { PeerMap } from '@libp2p/peer-collections'\n\nconst isRelayAddr = (ma: Multiaddr): boolean => ma.protoCodes().includes(CIRCUIT_PROTO_CODE)\n\nexport interface CircuitRelayServerInit {\n  /**\n   * Incoming hop requests must complete within this time in ms otherwise\n   * the stream will be reset (default: 30s)\n   */\n  hopTimeout?: number\n\n  /**\n   * Configuration of reservations\n   */\n  reservations?: ReservationStoreInit\n\n  /**\n   * The maximum number of simultaneous HOP inbound streams that can be open at once\n   */\n  maxInboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous HOP outbound streams that can be open at once\n   */\n  maxOutboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open at\n   * once. (default: 300)\n   */\n  maxOutboundStopStreams?: number\n}\n\nexport interface HopProtocolOptions {\n  connection: Connection\n  request: HopMessage\n  stream: ProtobufStream<Stream>\n}\n\nexport interface StopOptions {\n  connection: Connection\n  request: StopMessage\n}\n\nexport interface CircuitRelayServerComponents {\n  registrar: Registrar\n  peerStore: PeerStore\n  addressManager: AddressManager\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n}\n\nexport interface RelayServerEvents {\n  'relay:reservation': CustomEvent<RelayReservation>\n  'relay:advert:success': CustomEvent<unknown>\n  'relay:advert:error': CustomEvent<Error>\n}\n\nconst defaults = {\n  maxOutboundStopStreams: MAX_CONNECTIONS\n}\n\nclass CircuitRelayServer extends TypedEventEmitter<RelayServerEvents> implements Startable, CircuitRelayService {\n  private readonly registrar: Registrar\n  private readonly peerStore: PeerStore\n  private readonly addressManager: AddressManager\n  private readonly peerId: PeerId\n  private readonly connectionManager: ConnectionManager\n  private readonly connectionGater: ConnectionGater\n  private readonly reservationStore: ReservationStore\n  private started: boolean\n  private readonly hopTimeout: number\n  private readonly shutdownController: AbortController\n  private readonly maxInboundHopStreams?: number\n  private readonly maxOutboundHopStreams?: number\n  private readonly maxOutboundStopStreams: number\n  private readonly log: Logger\n\n  /**\n   * Creates an instance of Relay\n   */\n  constructor (components: CircuitRelayServerComponents, init: CircuitRelayServerInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:server')\n    this.registrar = components.registrar\n    this.peerStore = components.peerStore\n    this.addressManager = components.addressManager\n    this.peerId = components.peerId\n    this.connectionManager = components.connectionManager\n    this.connectionGater = components.connectionGater\n    this.started = false\n    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT\n    this.maxInboundHopStreams = init.maxInboundHopStreams\n    this.maxOutboundHopStreams = init.maxOutboundHopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n    this.reservationStore = new ReservationStore(init.reservations)\n\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/circuit-relay-v2-server'\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Start Relay service\n   */\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {\n      void this.onHop(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundHopStreams,\n      maxOutboundStreams: this.maxOutboundHopStreams,\n      runOnTransientConnection: true\n    })\n\n    this.reservationStore.start()\n\n    this.started = true\n  }\n\n  /**\n   * Stop Relay service\n   */\n  async stop (): Promise<void> {\n    this.reservationStore.stop()\n    this.shutdownController.abort()\n    await this.registrar.unhandle(RELAY_V2_HOP_CODEC)\n\n    this.started = false\n  }\n\n  async onHop ({ connection, stream }: IncomingStreamData): Promise<void> {\n    this.log('received circuit v2 hop protocol stream from %p', connection.remotePeer)\n\n    const hopTimeoutPromise = pDefer<HopMessage>()\n    const timeout = setTimeout(() => {\n      hopTimeoutPromise.reject('timed out')\n    }, this.hopTimeout)\n    const pbstr = pbStream(stream)\n\n    try {\n      const request: HopMessage = await Promise.race([\n        pbstr.pb(HopMessage).read(),\n        hopTimeoutPromise.promise\n      ])\n\n      if (request?.type == null) {\n        throw new Error('request was invalid, could not read from stream')\n      }\n\n      this.log('received', request.type)\n\n      await Promise.race([\n        this.handleHopProtocol({\n          connection,\n          stream: pbstr,\n          request\n        }),\n        hopTimeoutPromise.promise\n      ])\n    } catch (err: any) {\n      this.log.error('error while handling hop', err)\n      await pbstr.pb(HopMessage).write({\n        type: HopMessage.Type.STATUS,\n        status: Status.MALFORMED_MESSAGE\n      })\n      stream.abort(err)\n    } finally {\n      clearTimeout(timeout)\n    }\n  }\n\n  async handleHopProtocol ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    this.log('received hop message')\n    switch (request.type) {\n      case HopMessage.Type.RESERVE: await this.handleReserve({ stream, request, connection }); break\n      case HopMessage.Type.CONNECT: await this.handleConnect({ stream, request, connection }); break\n      default: {\n        this.log.error('invalid hop request type %s via peer %p', request.type, connection.remotePeer)\n        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE })\n      }\n    }\n  }\n\n  async handleReserve ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n    this.log('hop reserve request from %p', connection.remotePeer)\n\n    if (isRelayAddr(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    if ((await this.connectionGater.denyInboundRelayReservation?.(connection.remotePeer)) === true) {\n      this.log.error('reservation for %p denied by connection gater', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr)\n\n    if (result.status !== Status.OK) {\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status })\n      return\n    }\n\n    try {\n      // tag relay target peer\n      // result.expire is non-null if `ReservationStore.reserve` returns with status == OK\n      if (result.expire != null) {\n        const ttl = (result.expire * 1000) - Date.now()\n        await this.peerStore.merge(connection.remotePeer, {\n          tags: {\n            [RELAY_SOURCE_TAG]: { value: 1, ttl }\n          }\n        })\n      }\n\n      await hopstr.write({\n        type: HopMessage.Type.STATUS,\n        status: Status.OK,\n        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),\n        limit: this.reservationStore.get(connection.remotePeer)?.limit\n      })\n      this.log('sent confirmation response to %s', connection.remotePeer)\n    } catch (err) {\n      this.log.error('failed to send confirmation response to %p', connection.remotePeer, err)\n      this.reservationStore.removeReservation(connection.remotePeer)\n    }\n  }\n\n  async makeReservation (\n    remotePeer: PeerId,\n    expire: bigint\n  ): Promise<Reservation> {\n    const addrs = []\n\n    for (const relayAddr of this.addressManager.getAddresses()) {\n      if (relayAddr.toString().includes('/p2p-circuit')) {\n        continue\n      }\n\n      addrs.push(relayAddr.bytes)\n    }\n\n    const voucher = await RecordEnvelope.seal(new ReservationVoucherRecord({\n      peer: remotePeer,\n      relay: this.peerId,\n      expiration: Number(expire)\n    }), this.peerId)\n\n    return {\n      addrs,\n      expire,\n      voucher: voucher.marshal()\n    }\n  }\n\n  async handleConnect ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n\n    if (isRelayAddr(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    this.log('hop connect request from %p', connection.remotePeer)\n\n    let dstPeer: PeerId\n\n    try {\n      if (request.peer == null) {\n        this.log.error('no peer info in hop connect request')\n        throw new Error('no peer info in request')\n      }\n\n      request.peer.addrs.forEach(multiaddr)\n      dstPeer = peerIdFromBytes(request.peer.id)\n    } catch (err) {\n      this.log.error('invalid hop connect request via peer %p %s', connection.remotePeer, err)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE })\n      return\n    }\n\n    if (!this.reservationStore.hasReservation(dstPeer)) {\n      this.log.error('hop connect denied for destination peer %p not having a reservation for %p with status %s', dstPeer, connection.remotePeer, Status.NO_RESERVATION)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION })\n      return\n    }\n\n    if ((await this.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer)) === true) {\n      this.log.error('hop connect for %p to %p denied by connection gater', connection.remotePeer, dstPeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    const connections = this.connectionManager.getConnections(dstPeer)\n\n    if (connections.length === 0) {\n      this.log('hop connect denied for destination peer %p not having a connection for %p as there is no destination connection', dstPeer, connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION })\n      return\n    }\n\n    const limit = this.reservationStore.get(dstPeer)?.limit\n    const destinationConnection = connections[0]\n\n    const destinationStream = await this.stopHop({\n      connection: destinationConnection,\n      request: {\n        type: StopMessage.Type.CONNECT,\n        peer: {\n          id: connection.remotePeer.toBytes(),\n          addrs: []\n        },\n        limit\n      }\n    })\n\n    if (destinationStream == null) {\n      this.log.error('failed to open stream to destination peer %p', destinationConnection?.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED })\n      return\n    }\n\n    await hopstr.write({\n      type: HopMessage.Type.STATUS,\n      status: Status.OK,\n      limit\n    })\n    const sourceStream = stream.unwrap()\n\n    this.log('connection from %p to %p established - merging streams', connection.remotePeer, dstPeer)\n    // Short circuit the two streams to create the relayed connection\n    createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, limit, {\n      log: this.log\n    })\n  }\n\n  /**\n   * Send a STOP request to the target peer that the dialing peer wants to contact\n   */\n  async stopHop ({\n    connection,\n    request\n  }: StopOptions): Promise<Stream | undefined> {\n    this.log('starting circuit relay v2 stop request to %s', connection.remotePeer)\n    const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnTransientConnection: true\n    })\n    const pbstr = pbStream(stream)\n    const stopstr = pbstr.pb(StopMessage)\n    await stopstr.write(request)\n    let response\n\n    try {\n      response = await stopstr.read()\n    } catch (err) {\n      this.log.error('error parsing stop message response from %p', connection.remotePeer)\n    }\n\n    if (response == null) {\n      this.log.error('could not read response from %p', connection.remotePeer)\n      await stream.close()\n      return\n    }\n\n    if (response.status === Status.OK) {\n      this.log('stop request to %p was successful', connection.remotePeer)\n      return pbstr.unwrap()\n    }\n\n    this.log('stop request failed with code %d', response.status)\n    await stream.close()\n  }\n\n  get reservations (): PeerMap<RelayReservation> {\n    return this.reservationStore.reservations\n  }\n}\n\nexport function circuitRelayServer (init: CircuitRelayServerInit = {}): (components: CircuitRelayServerComponents) => CircuitRelayService {\n  return (components) => {\n    return new CircuitRelayServer(components, init)\n  }\n}\n", "import type { ComponentLogger, MultiaddrConnection, Stream } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface StreamProperties {\n  stream: Stream\n  remoteAddr: Multiaddr\n  localAddr: Multiaddr\n  logger: ComponentLogger\n}\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection (props: StreamProperties): MultiaddrConnection {\n  const { stream, remoteAddr, logger } = props\n  const log = logger.forComponent('libp2p:stream:converter')\n\n  let closedRead = false\n  let closedWrite = false\n\n  // piggyback on `stream.close` invocations to close maconn\n  const streamClose = stream.close.bind(stream)\n  stream.close = async (options) => {\n    await streamClose(options)\n    close(true)\n  }\n\n  // piggyback on `stream.abort` invocations to close maconn\n  const streamAbort = stream.abort.bind(stream)\n  stream.abort = (err) => {\n    streamAbort(err)\n    close(true)\n  }\n\n  // piggyback on `stream.sink` invocations to close maconn\n  const streamSink = stream.sink.bind(stream)\n  stream.sink = async (source) => {\n    try {\n      await streamSink(source)\n    } catch (err: any) {\n      // If aborted we can safely ignore\n      if (err.type !== 'aborted') {\n        // If the source errored the socket will already have been destroyed by\n        // toIterable.duplex(). If the socket errored it will already be\n        // destroyed. There's nothing to do here except log the error & return.\n        log.error('%s error in sink', remoteAddr, err)\n      }\n    } finally {\n      closedWrite = true\n      close()\n    }\n  }\n\n  const maConn: MultiaddrConnection = {\n    log,\n    sink: stream.sink,\n    source: (async function * () {\n      try {\n        for await (const list of stream.source) {\n          if (list instanceof Uint8Array) {\n            yield list\n          } else {\n            yield * list\n          }\n        }\n      } finally {\n        closedRead = true\n        close()\n      }\n    }()),\n    remoteAddr,\n    timeline: { open: Date.now(), close: undefined },\n    close: stream.close,\n    abort: stream.abort\n  }\n\n  function close (force?: boolean): void {\n    if (force === true) {\n      closedRead = true\n      closedWrite = true\n    }\n\n    if (closedRead && closedWrite && maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  return maConn\n}\n", "import { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport { anySignal } from 'any-signal'\nimport { raceSignal } from 'race-signal'\nimport {\n  RELAY_V2_HOP_CODEC\n} from '../constants.js'\nimport type { ComponentLogger, Logger, PeerId, PeerStore, Startable, TopologyFilter } from '@libp2p/interface'\nimport type { ConnectionManager, RandomWalk, Registrar, TransportManager } from '@libp2p/interface-internal'\n\nexport interface RelayDiscoveryEvents {\n  'relay:discover': CustomEvent<PeerId>\n}\n\nexport interface RelayDiscoveryComponents {\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  registrar: Registrar\n  logger: ComponentLogger\n  randomWalk: RandomWalk\n}\n\nexport interface RelayDiscoveryInit {\n  filter?: TopologyFilter\n}\n\n/**\n * ReservationManager automatically makes a circuit v2 reservation on any connected\n * peers that support the circuit v2 HOP protocol.\n */\nexport class RelayDiscovery extends TypedEventEmitter<RelayDiscoveryEvents> implements Startable {\n  private readonly peerStore: PeerStore\n  private readonly registrar: Registrar\n  private readonly connectionManager: ConnectionManager\n  private readonly randomWalk: RandomWalk\n  private started: boolean\n  private running: boolean\n  private topologyId?: string\n  private readonly log: Logger\n  private discoveryController: AbortController\n  private readonly filter?: TopologyFilter\n\n  constructor (components: RelayDiscoveryComponents, init: RelayDiscoveryInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:discover-relays')\n    this.started = false\n    this.running = false\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.connectionManager = components.connectionManager\n    this.randomWalk = components.randomWalk\n    this.filter = init.filter\n    this.discoveryController = new AbortController()\n    setMaxListeners(Infinity, this.discoveryController.signal)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    // register a topology listener for when new peers are encountered\n    // that support the hop protocol\n    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {\n      filter: this.filter,\n      onConnect: (peerId) => {\n        this.log('discovered relay %p', peerId)\n        this.safeDispatchEvent('relay:discover', { detail: peerId })\n      }\n    })\n\n    this.started = true\n  }\n\n  stop (): void {\n    if (this.topologyId != null) {\n      this.registrar.unregister(this.topologyId)\n    }\n\n    this.discoveryController?.abort()\n    this.started = false\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays:\n   *\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected\n   * 3. Search the network\n   */\n  startDiscovery (): void {\n    if (this.running) {\n      return\n    }\n\n    this.log('start discovery')\n    this.running = true\n    this.discoveryController = new AbortController()\n    setMaxListeners(Infinity, this.discoveryController.signal)\n\n    Promise.resolve()\n      .then(async () => {\n        this.log('searching peer store for relays')\n\n        const peers = (await this.peerStore.all({\n          filters: [\n            // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on\n            (peer) => {\n              return peer.protocols.includes(RELAY_V2_HOP_CODEC)\n            }\n          ],\n          orders: [\n            () => Math.random() < 0.5 ? 1 : -1\n          ]\n        }))\n\n        for (const peer of peers) {\n          this.log.trace('found relay peer %p in peer store', peer.id)\n          this.safeDispatchEvent('relay:discover', { detail: peer.id })\n        }\n\n        this.log('found %d relay peers in peer store', peers.length)\n\n        // perform random walk and dial peers - after identify has run, the network\n        // topology will be notified of new relays\n        const queue = new PeerQueue({\n          concurrency: 5\n        })\n\n        this.log('start random walk')\n        for await (const peer of this.randomWalk.walk({ signal: this.discoveryController.signal })) {\n          this.log.trace('found random peer %p', peer.id)\n\n          if (queue.has(peer.id)) {\n            this.log.trace('random peer %p was already in queue', peer.id)\n\n            // skip peers already in the queue\n            continue\n          }\n\n          if (this.connectionManager.getConnections(peer.id)?.length > 0) {\n            this.log.trace('random peer %p was already connected', peer.id)\n\n            // skip peers we are already connected to\n            continue\n          }\n\n          if (!(await this.connectionManager.isDialable(peer.multiaddrs))) {\n            this.log.trace('random peer %p was not dialable', peer.id, peer.multiaddrs.map(ma => ma.toString()))\n\n            // skip peers we can't dial\n            continue\n          }\n\n          this.log.trace('wait for space in queue for %p', peer.id)\n\n          // pause the random walk until there is space in the queue\n          await raceSignal(queue.onSizeLessThan(10), this.discoveryController.signal)\n\n          this.log('adding random peer %p to dial queue (length: %d)', peer.id, queue.size)\n\n          // dial the peer - this will cause identify to run and our topology to\n          // be notified and we'll attempt to create reservations\n          queue.add(async () => {\n            const signal = anySignal([this.discoveryController.signal, AbortSignal.timeout(5000)])\n            setMaxListeners(Infinity, signal)\n\n            try {\n              await this.connectionManager.openConnection(peer.id, { signal })\n            } finally {\n              signal.clear()\n            }\n          }, {\n            peerId: peer.id,\n            signal: this.discoveryController.signal\n          })\n            .catch(err => {\n              this.log.error('error opening connection to random peer %p', peer.id, err)\n            })\n        }\n\n        await queue.onIdle()\n      })\n      .catch(err => {\n        if (!this.discoveryController.signal.aborted) {\n          this.log.error('failed when finding relays on the network', err)\n        }\n      })\n  }\n\n  stopDiscovery (): void {\n    this.log('stop discovery')\n    this.running = false\n    this.discoveryController?.abort()\n  }\n}\n", "import { CodeError, TypedEventEmitter } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { ReservationStore } from './reservation-store.js'\nimport type { ComponentLogger, Logger, PeerId, Listener, ListenerEvents } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface CircuitRelayTransportListenerComponents {\n  connectionManager: ConnectionManager\n  relayStore: ReservationStore\n  logger: ComponentLogger\n}\n\nclass CircuitRelayTransportListener extends TypedEventEmitter<ListenerEvents> implements Listener {\n  private readonly connectionManager: ConnectionManager\n  private readonly relayStore: ReservationStore\n  private readonly listeningAddrs: PeerMap<Multiaddr[]>\n  private readonly log: Logger\n\n  constructor (components: CircuitRelayTransportListenerComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:listener')\n    this.connectionManager = components.connectionManager\n    this.relayStore = components.relayStore\n    this.listeningAddrs = new PeerMap()\n\n    // remove listening addrs when a relay is removed\n    this.relayStore.addEventListener('relay:removed', this._onRemoveRelayPeer)\n  }\n\n  _onRemoveRelayPeer = (evt: CustomEvent<PeerId>): void => {\n    this.#removeRelayPeer(evt.detail)\n  }\n\n  async listen (addr: Multiaddr): Promise<void> {\n    this.log('listen on %a', addr)\n\n    // remove the circuit part to get the peer id of the relay\n    const relayAddr = addr.decapsulate('/p2p-circuit')\n    const relayConn = await this.connectionManager.openConnection(relayAddr)\n\n    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {\n      this.log('making reservation on peer %p', relayConn.remotePeer)\n      // addRelay calls transportManager.listen which calls this listen method\n      await this.relayStore.addRelay(relayConn.remotePeer, 'configured')\n      return\n    }\n\n    const reservation = this.relayStore.getReservation(relayConn.remotePeer)\n\n    if (reservation == null) {\n      throw new CodeError('Did not have reservation after making reservation', 'ERR_NO_RESERVATION')\n    }\n\n    if (this.listeningAddrs.has(relayConn.remotePeer)) {\n      this.log('already listening on relay %p', relayConn.remotePeer)\n      return\n    }\n\n    // add all addresses from the relay reservation\n    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map(buf => {\n      return multiaddr(buf).encapsulate('/p2p-circuit')\n    }))\n\n    this.safeDispatchEvent('listening', {})\n  }\n\n  getAddrs (): Multiaddr[] {\n    return [...this.listeningAddrs.values()].flat()\n  }\n\n  async close (): Promise<void> {\n\n  }\n\n  #removeRelayPeer (peerId: PeerId): void {\n    const had = this.listeningAddrs.has(peerId)\n\n    this.log('relay peer removed %p - had reservation', peerId, had)\n\n    this.listeningAddrs.delete(peerId)\n\n    if (had) {\n      this.log.trace('removing relay event listener for peer %p', peerId)\n      this.relayStore.removeEventListener('relay:removed', this._onRemoveRelayPeer)\n      // Announce listen addresses change\n      this.safeDispatchEvent('close', {})\n    }\n  }\n}\n\nexport function createListener (options: CircuitRelayTransportListenerComponents): Listener {\n  return new CircuitRelayTransportListener(options)\n}\n", "import { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { createBloomFilter } from '@libp2p/utils/filters'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { pbStream } from 'it-protobuf-stream'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { DEFAULT_MAX_RESERVATION_QUEUE_LENGTH, DEFAULT_RESERVATION_COMPLETION_TIMEOUT, DEFAULT_RESERVATION_CONCURRENCY, RELAY_TAG, RELAY_V2_HOP_CODEC } from '../constants.js'\nimport { HopMessage, Status } from '../pb/index.js'\nimport { getExpirationMilliseconds } from '../utils.js'\nimport type { Reservation } from '../pb/index.js'\nimport type { TypedEventTarget, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, PeerId, PeerStore, Startable, Metrics } from '@libp2p/interface'\nimport type { ConnectionManager, TransportManager } from '@libp2p/interface-internal'\nimport type { Filter } from '@libp2p/utils/filters'\n\n// allow refreshing a relay reservation if it will expire in the next 10 minutes\nconst REFRESH_WINDOW = (60 * 1000) * 10\n\n// try to refresh relay reservations 5 minutes before expiry\nconst REFRESH_TIMEOUT = (60 * 1000) * 5\n\n// minimum duration before which a reservation must not be refreshed\nconst REFRESH_TIMEOUT_MIN = 30 * 1000\n\nexport interface RelayStoreComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface RelayStoreInit {\n  /**\n   * Multiple relays may be discovered simultaneously - to prevent listening\n   * on too many relays, this value controls how many to attempt to reserve a\n   * slot on at once. If set to more than one, we may end up listening on\n   * more relays than the `maxReservations` value, but on networks with poor\n   * connectivity the user may wish to attempt to reserve on multiple relays\n   * simultaneously. (default: 1)\n   */\n  reservationConcurrency?: number\n\n  /**\n   * How many discovered relays to allow in the reservation store\n   */\n  discoverRelays?: number\n\n  /**\n   * Limit the number of potential relays we will dial (default: 100)\n   */\n  maxReservationQueueLength?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   * (default: 5000)\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport type RelayType = 'discovered' | 'configured'\n\ninterface RelayEntry {\n  timeout: ReturnType<typeof setTimeout>\n  type: RelayType\n  reservation: Reservation\n}\n\nexport interface ReservationStoreEvents {\n  'relay:not-enough-relays': CustomEvent\n  'relay:removed': CustomEvent<PeerId>\n  'relay:created-reservation': CustomEvent<PeerId>\n}\n\nexport class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {\n  private readonly peerId: PeerId\n  private readonly connectionManager: ConnectionManager\n  private readonly transportManager: TransportManager\n  private readonly peerStore: PeerStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly reserveQueue: PeerQueue\n  private readonly reservations: PeerMap<RelayEntry>\n  private readonly maxDiscoveredRelays: number\n  private readonly maxReservationQueueLength: number\n  private readonly reservationCompletionTimeout: number\n  private started: boolean\n  private readonly log: Logger\n  private readonly relayFilter: Filter\n\n  constructor (components: RelayStoreComponents, init?: RelayStoreInit) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:reservation-store')\n    this.peerId = components.peerId\n    this.connectionManager = components.connectionManager\n    this.transportManager = components.transportManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.reservations = new PeerMap()\n    this.maxDiscoveredRelays = init?.discoverRelays ?? 0\n    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH\n    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT\n    this.started = false\n    this.relayFilter = createBloomFilter(100)\n\n    // ensure we don't listen on multiple relays simultaneously\n    this.reserveQueue = new PeerQueue({\n      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,\n      metricName: 'libp2p_relay_reservation_queue',\n      metrics: components.metrics\n    })\n\n    // When a peer disconnects, if we had a reservation on that peer\n    // remove the reservation and multiaddr and maybe trigger search\n    // for new relays\n    this.events.addEventListener('peer:disconnect', (evt) => {\n      this.#removeRelay(evt.detail)\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  afterStart (): void {\n    if (this.reservations.size < this.maxDiscoveredRelays) {\n      this.log('not enough relays %d/%d', this.reservations.size, this.maxDiscoveredRelays)\n      this.safeDispatchEvent('relay:not-enough-relays', {})\n    }\n  }\n\n  stop (): void {\n    this.reserveQueue.clear()\n    this.reservations.forEach(({ timeout }) => {\n      clearTimeout(timeout)\n    })\n    this.reservations.clear()\n    this.started = false\n  }\n\n  /**\n   * If the number of current relays is beneath the configured `maxReservations`\n   * value, and the passed peer id is not our own, and we have a non-relayed\n   * connection to the remote, and the remote peer speaks the hop protocol, try\n   * to reserve a slot on the remote peer\n   */\n  async addRelay (peerId: PeerId, type: RelayType): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      this.log('not trying to use self as relay')\n      return\n    }\n\n    if (this.reserveQueue.size > this.maxReservationQueueLength) {\n      this.log('not adding potential relay peer %p as the queue is full', peerId)\n      return\n    }\n\n    if (this.reserveQueue.has(peerId)) {\n      this.log('potential relay peer %p is already in the reservation queue', peerId)\n      return\n    }\n\n    if (this.relayFilter.has(peerId.toBytes())) {\n      this.log('potential relay peer %p has failed previously, not trying again', peerId)\n      return\n    }\n\n    this.log('try to reserve relay slot with %p', peerId)\n\n    await this.reserveQueue.add(async () => {\n      const start = Date.now()\n\n      try {\n        // allow refresh of an existing reservation if it is about to expire\n        const existingReservation = this.reservations.get(peerId)\n\n        if (existingReservation != null) {\n          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {\n            this.log('already have reservation on relay peer %p and it expires in more than 10 minutes', peerId)\n            return\n          }\n\n          clearTimeout(existingReservation.timeout)\n          this.reservations.delete(peerId)\n        }\n\n        if (type === 'discovered' && [...this.reservations.values()].reduce((acc, curr) => {\n          if (curr.type === 'discovered') {\n            acc++\n          }\n\n          return acc\n        }, 0) >= this.maxDiscoveredRelays) {\n          this.log('already have enough discovered relays')\n          return\n        }\n\n        const signal = AbortSignal.timeout(this.reservationCompletionTimeout)\n        setMaxListeners(Infinity, signal)\n\n        const connection = await this.connectionManager.openConnection(peerId, {\n          signal\n        })\n\n        if (connection.remoteAddr.protoNames().includes('p2p-circuit')) {\n          this.log('not creating reservation over relayed connection')\n          return\n        }\n\n        const reservation = await this.#createReservation(connection, {\n          signal\n        })\n\n        this.log('created reservation on relay peer %p', peerId)\n\n        const expiration = getExpirationMilliseconds(reservation.expire)\n\n        // sets a lower bound on the timeout, and also don't let it go over\n        // 2^31 - 1 (setTimeout will only accept signed 32 bit integers)\n        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1)\n\n        const timeout = setTimeout(() => {\n          this.addRelay(peerId, type).catch(err => {\n            this.log.error('could not refresh reservation to relay %p', peerId, err)\n          })\n        }, timeoutDuration)\n\n        // we've managed to create a reservation successfully\n        this.reservations.set(peerId, {\n          timeout,\n          reservation,\n          type\n        })\n\n        // ensure we don't close the connection to the relay\n        await this.peerStore.merge(peerId, {\n          tags: {\n            [RELAY_TAG]: {\n              value: 1,\n              ttl: expiration\n            }\n          }\n        })\n\n        // listen on multiaddr that only the circuit transport is listening for\n        await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)])\n\n        this.safeDispatchEvent('relay:created-reservation', {\n          detail: peerId\n        })\n      } catch (err) {\n        this.log.error('could not reserve slot on %p after %dms', peerId, Date.now() - start, err)\n\n        // cancel the renewal timeout if it's been set\n        const reservation = this.reservations.get(peerId)\n\n        if (reservation != null) {\n          clearTimeout(reservation.timeout)\n        }\n\n        // if listening failed, remove the reservation\n        this.reservations.delete(peerId)\n\n        // don't try this peer again\n        this.relayFilter.add(peerId.toBytes())\n      }\n    }, {\n      peerId\n    })\n  }\n\n  hasReservation (peerId: PeerId): boolean {\n    return this.reservations.has(peerId)\n  }\n\n  getReservation (peerId: PeerId): Reservation | undefined {\n    return this.reservations.get(peerId)?.reservation\n  }\n\n  reservationCount (): number {\n    return this.reservations.size\n  }\n\n  async #createReservation (connection: Connection, options: AbortOptions): Promise<Reservation> {\n    options.signal?.throwIfAborted()\n\n    this.log('requesting reservation from %p', connection.remotePeer)\n    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options)\n    const pbstr = pbStream(stream)\n    const hopstr = pbstr.pb(HopMessage)\n    await hopstr.write({ type: HopMessage.Type.RESERVE }, options)\n\n    let response: HopMessage\n\n    try {\n      response = await hopstr.read(options)\n    } catch (err: any) {\n      stream.abort(err)\n      throw err\n    } finally {\n      if (stream.status !== 'closed') {\n        await stream.close(options)\n      }\n    }\n\n    if (response.status === Status.OK && (response.reservation != null)) {\n      // check that the returned relay has the relay address - this can be\n      // omitted when requesting a reservation from a go-libp2p relay we\n      // already have a reservation on\n      let hasRelayAddress = false\n      const relayAddressBytes = connection.remoteAddr.bytes\n\n      for (const buf of response.reservation.addrs) {\n        if (uint8ArrayEquals(relayAddressBytes, buf)) {\n          hasRelayAddress = true\n          break\n        }\n      }\n\n      if (!hasRelayAddress) {\n        response.reservation.addrs.push(relayAddressBytes)\n      }\n\n      return response.reservation\n    }\n\n    const errMsg = `reservation failed with status ${response.status ?? 'undefined'}`\n    this.log.error(errMsg)\n\n    throw new Error(errMsg)\n  }\n\n  /**\n   * Remove listen relay\n   */\n  #removeRelay (peerId: PeerId): void {\n    const existingReservation = this.reservations.get(peerId)\n\n    if (existingReservation == null) {\n      return\n    }\n\n    this.log('connection to relay %p closed, removing reservation from local store', peerId)\n\n    clearTimeout(existingReservation.timeout)\n    this.reservations.delete(peerId)\n\n    this.safeDispatchEvent('relay:removed', { detail: peerId })\n\n    if (this.reservations.size < this.maxDiscoveredRelays) {\n      this.log('not enough relays %d/%d', this.reservations.size, this.maxDiscoveredRelays)\n      this.safeDispatchEvent('relay:not-enough-relays', {})\n    }\n  }\n}\n", "import { CodeError, serviceCapabilities, serviceDependencies, start, stop, transportSymbol } from '@libp2p/interface'\nimport { peerFilter } from '@libp2p/peer-collections'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn'\nimport * as mafmt from '@multiformats/mafmt'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { pbStream } from 'it-protobuf-stream'\nimport { CustomProgressEvent } from 'progress-events'\nimport { CIRCUIT_PROTO_CODE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE, DEFAULT_DISCOVERY_FILTER_SIZE, ERR_HOP_REQUEST_FAILED, ERR_RELAYED_DIAL, MAX_CONNECTIONS, RELAY_V2_HOP_CODEC, RELAY_V2_STOP_CODEC } from '../constants.js'\nimport { StopMessage, HopMessage, Status } from '../pb/index.js'\nimport { RelayDiscovery } from './discovery.js'\nimport { createListener } from './listener.js'\nimport { ReservationStore } from './reservation-store.js'\nimport type { CircuitRelayTransportComponents, CircuitRelayTransportInit } from './index.js'\nimport type { Transport, CreateListenerOptions, Listener, Upgrader, ComponentLogger, Logger, Connection, Stream, ConnectionGater, PeerId, PeerStore, OutboundConnectionUpgradeEvents, DialTransportOptions, OpenConnectionProgressEvents } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, IncomingStreamData, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\nconst isValidStop = (request: StopMessage): request is Required<StopMessage> => {\n  if (request.peer == null) {\n    return false\n  }\n\n  try {\n    request.peer.addrs.forEach(multiaddr)\n  } catch {\n    return false\n  }\n\n  return true\n}\n\ninterface ConnectOptions extends ProgressOptions<CircuitRelayDialEvents> {\n  stream: Stream\n  connection: Connection\n  destinationPeer: PeerId\n  destinationAddr: Multiaddr\n  relayAddr: Multiaddr\n  ma: Multiaddr\n  disconnectOnFailure: boolean\n}\n\nconst defaults = {\n  maxInboundStopStreams: MAX_CONNECTIONS,\n  maxOutboundStopStreams: MAX_CONNECTIONS,\n  stopTimeout: 30000\n}\n\nexport type CircuitRelayDialEvents =\n  OutboundConnectionUpgradeEvents |\n  OpenConnectionProgressEvents |\n  ProgressEvent<'circuit-relay:open-connection'> |\n  ProgressEvent<'circuit-relay:reuse-connection'> |\n  ProgressEvent<'circuit-relay:open-hop-stream'> |\n  ProgressEvent<'circuit-relay:write-connect-message'> |\n  ProgressEvent<'circuit-relay:read-connect-response'>\n\nexport class CircuitRelayTransport implements Transport<CircuitRelayDialEvents> {\n  private readonly discovery?: RelayDiscovery\n  private readonly registrar: Registrar\n  private readonly peerStore: PeerStore\n  private readonly connectionManager: ConnectionManager\n  private readonly transportManager: TransportManager\n  private readonly peerId: PeerId\n  private readonly upgrader: Upgrader\n  private readonly addressManager: AddressManager\n  private readonly connectionGater: ConnectionGater\n  public readonly reservationStore: ReservationStore\n  private readonly logger: ComponentLogger\n  private readonly maxInboundStopStreams: number\n  private readonly maxOutboundStopStreams?: number\n  private readonly stopTimeout: number\n  private started: boolean\n  private readonly log: Logger\n\n  constructor (components: CircuitRelayTransportComponents, init: CircuitRelayTransportInit) {\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport')\n    this.registrar = components.registrar\n    this.peerStore = components.peerStore\n    this.connectionManager = components.connectionManager\n    this.transportManager = components.transportManager\n    this.logger = components.logger\n    this.peerId = components.peerId\n    this.upgrader = components.upgrader\n    this.addressManager = components.addressManager\n    this.connectionGater = components.connectionGater\n    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n    this.stopTimeout = init.stopTimeout ?? defaults.stopTimeout\n\n    const discoverRelays = init.discoverRelays ?? 0\n\n    if (discoverRelays > 0) {\n      this.discovery = new RelayDiscovery(components, {\n        filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)\n      })\n      this.discovery.addEventListener('relay:discover', (evt) => {\n        this.reservationStore.addRelay(evt.detail, 'discovered')\n          .catch(err => {\n            this.log.error('could not add discovered relay %p', evt.detail, err)\n          })\n      })\n    }\n\n    this.reservationStore = new ReservationStore(components, init)\n    this.reservationStore.addEventListener('relay:not-enough-relays', () => {\n      this.discovery?.startDiscovery()\n    })\n    this.reservationStore.addEventListener('relay:created-reservation', () => {\n      if (this.reservationStore.reservationCount() >= discoverRelays) {\n        this.discovery?.stopDiscovery()\n      }\n    })\n\n    this.started = false\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/circuit-relay-v2-transport'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/transport',\n    '@libp2p/circuit-relay-v2-transport'\n  ]\n\n  get [serviceDependencies] (): string[] {\n    // we only need identify if discovery is enabled\n    if (this.discovery != null) {\n      return [\n        '@libp2p/identify'\n      ]\n    }\n\n    return []\n  }\n\n  readonly [transportSymbol] = true\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {\n      void this.onStop(data).catch(err => {\n        this.log.error('error while handling STOP protocol', err)\n        data.stream.abort(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStopStreams,\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnTransientConnection: true\n    })\n\n    await start(this.discovery, this.reservationStore)\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await stop(this.discovery, this.reservationStore)\n    await this.registrar.unhandle(RELAY_V2_STOP_CODEC)\n\n    this.started = false\n  }\n\n  /**\n   * Dial a peer over a relay\n   */\n  async dial (ma: Multiaddr, options: DialTransportOptions<CircuitRelayDialEvents>): Promise<Connection> {\n    if (ma.protoCodes().filter(code => code === CIRCUIT_PROTO_CODE).length !== 1) {\n      const errMsg = 'Invalid circuit relay address'\n      this.log.error(errMsg, ma)\n      throw new CodeError(errMsg, ERR_RELAYED_DIAL)\n    }\n\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayId = relayAddr.getPeerId()\n    const destinationId = destinationAddr.getPeerId()\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`\n      this.log.error(errMsg)\n      throw new CodeError(errMsg, ERR_RELAYED_DIAL)\n    }\n\n    const relayPeer = peerIdFromString(relayId)\n    const destinationPeer = peerIdFromString(destinationId)\n\n    let disconnectOnFailure = false\n    const relayConnections = this.connectionManager.getConnections(relayPeer)\n    let relayConnection = relayConnections[0]\n\n    if (relayConnection == null) {\n      await this.peerStore.merge(relayPeer, {\n        multiaddrs: [relayAddr]\n      })\n\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:open-connection'))\n      relayConnection = await this.connectionManager.openConnection(relayPeer, options)\n      disconnectOnFailure = true\n    } else {\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:reuse-connection'))\n    }\n\n    let stream: Stream | undefined\n\n    try {\n      options.onProgress?.(new CustomProgressEvent('circuit-relay:open-hop-stream'))\n      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC)\n\n      return await this.connectV2({\n        stream,\n        connection: relayConnection,\n        destinationPeer,\n        destinationAddr,\n        relayAddr,\n        ma,\n        disconnectOnFailure,\n        onProgress: options.onProgress\n      })\n    } catch (err: any) {\n      this.log.error('circuit relay dial to destination %p via relay %p failed', destinationPeer, relayPeer, err)\n\n      if (stream != null) {\n        stream.abort(err)\n      }\n      disconnectOnFailure && await relayConnection.close()\n      throw err\n    }\n  }\n\n  async connectV2 (\n    {\n      stream, connection, destinationPeer,\n      destinationAddr, relayAddr, ma,\n      disconnectOnFailure,\n      onProgress\n    }: ConnectOptions\n  ): Promise<Connection> {\n    try {\n      const pbstr = pbStream(stream)\n      const hopstr = pbstr.pb(HopMessage)\n\n      onProgress?.(new CustomProgressEvent('circuit-relay:write-connect-message'))\n      await hopstr.write({\n        type: HopMessage.Type.CONNECT,\n        peer: {\n          id: destinationPeer.toBytes(),\n          addrs: [multiaddr(destinationAddr).bytes]\n        }\n      })\n\n      onProgress?.(new CustomProgressEvent('circuit-relay:read-connect-response'))\n      const status = await hopstr.read()\n\n      if (status.status !== Status.OK) {\n        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? 'undefined'}`, ERR_HOP_REQUEST_FAILED)\n      }\n\n      const maConn = streamToMaConnection({\n        stream: pbstr.unwrap(),\n        remoteAddr: ma,\n        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),\n        logger: this.logger\n      })\n\n      this.log('new outbound relayed connection %a', maConn.remoteAddr)\n      return await this.upgrader.upgradeOutbound(maConn, {\n        transient: status.limit != null,\n        onProgress\n      })\n    } catch (err: any) {\n      this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err)\n      disconnectOnFailure && await connection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      connectionManager: this.connectionManager,\n      relayStore: this.reservationStore,\n      logger: this.logger\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n\n  /**\n   * An incoming STOP request means a remote peer wants to dial us via a relay\n   */\n  async onStop ({ connection, stream }: IncomingStreamData): Promise<void> {\n    if (!this.reservationStore.hasReservation(connection.remotePeer)) {\n      try {\n        this.log('dialed via relay we did not have a reservation on, start listening on that relay address')\n        await this.transportManager.listen([connection.remoteAddr.encapsulate('/p2p-circuit')])\n      } catch (err: any) {\n        // failed to refresh our hitherto unknown relay reservation but allow the connection attempt anyway\n        this.log.error('failed to listen on a relay peer we were dialed via but did not have a reservation on', err)\n      }\n    }\n\n    const signal = AbortSignal.timeout(this.stopTimeout)\n    const pbstr = pbStream(stream).pb(StopMessage)\n    const request = await pbstr.read({\n      signal\n    })\n\n    this.log('new circuit relay v2 stop stream from %p with type %s', connection.remotePeer, request.type)\n\n    if (request?.type === undefined) {\n      this.log.error('type was missing from circuit v2 stop protocol request from %s', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    // Validate the STOP request has the required input\n    if (request.type !== StopMessage.Type.CONNECT) {\n      this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    if (!isValidStop(request)) {\n      this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    const remotePeerId = peerIdFromBytes(request.peer.id)\n\n    if ((await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId)) === true) {\n      this.log.error('connection gater denied inbound relayed connection from %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    this.log.trace('sending success response to %p', connection.remotePeer)\n    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {\n      signal\n    })\n\n    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`)\n    const localAddr = this.addressManager.getAddresses()[0]\n    const maConn = streamToMaConnection({\n      stream: pbstr.unwrap().unwrap(),\n      remoteAddr,\n      localAddr,\n      logger: this.logger\n    })\n\n    this.log('new inbound relayed connection %a', maConn.remoteAddr)\n    await this.upgrader.upgradeInbound(maConn, {\n      transient: request.limit != null\n    })\n    this.log('%s connection %a upgraded', 'inbound', maConn.remoteAddr)\n  }\n}\n", "import { CircuitRelayTransport } from './transport.js'\nimport type { RelayDiscoveryComponents } from './discovery.js'\nimport type { RelayStoreInit } from './reservation-store.js'\nimport type { Transport, Upgrader, Libp2pEvents, ConnectionGater, TypedEventTarget, PeerId, TopologyFilter } from '@libp2p/interface'\nimport type { AddressManager, Registrar } from '@libp2p/interface-internal'\n\nexport interface CircuitRelayTransportComponents extends RelayDiscoveryComponents {\n  peerId: PeerId\n  registrar: Registrar\n  upgrader: Upgrader\n  addressManager: AddressManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n}\n\n/**\n * RelayConfig configures the circuit v2 relay transport.\n */\nexport interface CircuitRelayTransportInit extends RelayStoreInit {\n  /**\n   * The number of peers running diable relays to search for and connect to\n   *\n   * @default 0\n   */\n  discoverRelays?: number\n\n  /**\n   * An optional filter used to prevent duplicate attempts to reserve relay\n   * slots on the same peer\n   */\n  discoveryFilter?: TopologyFilter\n\n  /**\n   * The maximum number of simultaneous STOP inbound streams that can be open at\n   * once - each inbound relayed connection uses a STOP stream\n   *\n   * @default 300\n   */\n  maxInboundStopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open\n   * at once. If this transport is used along with the relay server these\n   * settings should be set to the same value\n   *\n   * @default 300\n   */\n  maxOutboundStopStreams?: number\n\n  /**\n   * Incoming STOP requests (e.g. when a remote peer wants to dial us via a\n   * relay) must finish the initial protocol negotiation within this timeout in\n   * ms\n   *\n   * @default 30000\n   */\n  stopTimeout?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   *\n   * @default 10000\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport function circuitRelayTransport (init: CircuitRelayTransportInit = {}): (components: CircuitRelayTransportComponents) => Transport {\n  return (components) => {\n    return new CircuitRelayTransport(components, init)\n  }\n}\n"],
  "mappings": "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",
  "names": ["HopMessage", "Type", "__TypeValues", "StopMessage", "Peer", "CodeError", "Reservation", "Limit", "Status", "__StatusValues", "ReservationVoucher", "ReservationStore", "start", "defaults", "ReservationStore"]
}
