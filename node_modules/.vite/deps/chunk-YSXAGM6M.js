import {
  Uint8ArrayList
} from "./chunk-R26WB7BE.js";
import {
  decode,
  encode,
  encodingLength
} from "./chunk-WM3KG47V.js";
import {
  raceSignal
} from "./chunk-64K5UDI7.js";
import {
  pDefer
} from "./chunk-O4JBUFYC.js";

// ../../../../node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  readNext;
  haveNext;
  ended;
  nextResult;
  constructor() {
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    await this._push(void 0);
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options?.signal, options);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

// ../../../../node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError = class extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
};

// ../../../../node_modules/it-byte-stream/dist/src/index.js
var CodeError = class extends Error {
  code;
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
var AbortError = class extends CodeError {
  type;
  constructor(message) {
    super(message, "ABORT_ERR");
    this.type = "aborted";
    this.name = "AbortError";
  }
};
function byteStream(duplex, opts) {
  const write = queuelessPushable();
  duplex.sink(write).catch(async (err) => {
    await write.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write.push(buf);
    }
    await write.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes, options) => {
      options?.signal?.throwIfAborted();
      let listener;
      const abortPromise = new Promise((resolve, reject) => {
        listener = () => {
          reject(new AbortError("Read aborted"));
        };
        options?.signal?.addEventListener("abort", listener);
      });
      try {
        if (bytes == null) {
          const { done, value } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            return new Uint8ArrayList();
          }
          return value;
        }
        while (readBuffer.byteLength < bytes) {
          const { value, done } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            throw new UnexpectedEOFError("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, bytes);
        readBuffer.consume(bytes);
        return buf;
      } finally {
        if (listener != null) {
          options?.signal?.removeEventListener("abort", listener);
        }
      }
    },
    write: async (data, options) => {
      options?.signal?.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write.push(data, options);
      } else {
        await write.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if (opts?.yieldBytes === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// ../../../../node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
var InvalidDataLengthError = class extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
var InvalidDataLengthLengthError = class extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};

// ../../../../node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = opts?.lengthDecoder ?? decode;
  const encodeLength = opts?.lengthEncoder ?? encode;
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read(1, options));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError("Invalid message length");
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError("message length too long");
      }
      return bytes.read(dataLength, options);
    },
    write: async (data, options) => {
      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

export {
  byteStream,
  lpStream
};
//# sourceMappingURL=chunk-YSXAGM6M.js.map
