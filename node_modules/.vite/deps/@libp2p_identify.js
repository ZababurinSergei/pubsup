import {
  parallel,
  src_default
} from "./chunk-JRLFXGJD.js";
import {
  PeerRecord,
  RecordEnvelope
} from "./chunk-VLW6LXF7.js";
import {
  peerIdFromKeys
} from "./chunk-FWKVHZX5.js";
import {
  IP_OR_DOMAIN
} from "./chunk-MKDOG3EI.js";
import {
  pbStream
} from "./chunk-NKTJNKYB.js";
import "./chunk-YSXAGM6M.js";
import {
  decodeMessage,
  encodeMessage,
  message
} from "./chunk-6YCMPVGL.js";
import "./chunk-R26WB7BE.js";
import {
  isBrowser,
  isElectronMain,
  isElectronRenderer,
  isNode,
  isReactNative,
  isWebWorker
} from "./chunk-FJLIX5LN.js";
import {
  multiaddr
} from "./chunk-YX37ODEY.js";
import {
  getProtocol
} from "./chunk-BMBYA5Y7.js";
import "./chunk-WM3KG47V.js";
import {
  fromString,
  toString
} from "./chunk-7WZMQG6K.js";
import "./chunk-64K5UDI7.js";
import "./chunk-O4JBUFYC.js";
import {
  CodeError,
  serviceCapabilities,
  setMaxListeners
} from "./chunk-YWZAGWS3.js";
import "./chunk-X4MUZPSZ.js";

// ../../../../node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;

// ../../../../node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader.string();
              break;
            case 6:
              obj.agentVersion = reader.string();
              break;
            case 1:
              obj.publicKey = reader.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader.bytes());
              break;
            case 4:
              obj.observedAddr = reader.bytes();
              break;
            case 3:
              obj.protocols.push(reader.string());
              break;
            case 8:
              obj.signedPeerRecord = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf) => {
    return decodeMessage(buf, Identify3.codec());
  };
})(Identify || (Identify = {}));

// ../../../../node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnTransientConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
function getAgentVersion(nodeInfo, agentVersion) {
  if (agentVersion != null) {
    return agentVersion;
  }
  agentVersion = `${nodeInfo.name}/${nodeInfo.version}`;
  if (isNode || isElectronMain) {
    agentVersion += ` UserAgent=${globalThis.process.version}`;
  } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
    agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
  }
  return agentVersion;
}
async function consumeIdentifyMessage(peerStore, events, log, connection, message2) {
  log("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new CodeError("message was null or undefined", "ERR_INVALID_MESSAGE");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    peer.publicKey = message2.publicKey;
    const peerId = await peerIdFromKeys(message2.publicKey);
    if (!peerId.equals(connection.remotePeer)) {
      throw new CodeError("public key did not match remote PeerId", "ERR_INVALID_PUBLIC_KEY");
    }
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);
    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    if (!peerRecord.peerId.equals(envelope.peerId)) {
      throw new CodeError("signing key does not match PeerId in the PeerRecord", "ERR_INVALID_SIGNING_KEY");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new CodeError("signing key does not match remote PeerId", "ERR_INVALID_PEER_RECORD_KEY");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log("%p did not send a signed peer record", connection.remotePeer);
  }
  log("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    log("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  host;
  protocol;
  started;
  timeout;
  peerId;
  peerStore;
  registrar;
  addressManager;
  maxInboundStreams;
  maxOutboundStreams;
  maxMessageSize;
  maxObservedAddresses;
  events;
  runOnTransientConnection;
  log;
  constructor(components, init) {
    this.protocol = init.protocol;
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.events = components.events;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
    };
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.protocol, (data) => {
      void this.handleProtocol(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// ../../../../node_modules/@libp2p/identify/dist/src/identify-push.js
var IdentifyPush = class extends AbstractIdentify {
  connectionManager;
  concurrency;
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues.concurrency;
    if (init.runOnSelfUpdate ?? defaultValues.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        void this.push().catch((err) => {
          this.log.error(err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify-push"
  ];
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
    const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
    const self = this;
    async function* pushToConnections() {
      for (const connection of self.connectionManager.getConnections()) {
        const peer2 = await self.peerStore.get(connection.remotePeer);
        if (!peer2.protocols.includes(self.protocol)) {
          continue;
        }
        yield async () => {
          let stream;
          const signal = AbortSignal.timeout(self.timeout);
          setMaxListeners(Infinity, signal);
          try {
            stream = await connection.newStream(self.protocol, {
              signal,
              runOnTransientConnection: self.runOnTransientConnection
            });
            const pb = pbStream(stream, {
              maxDataLength: self.maxMessageSize
            }).pb(Identify);
            await pb.write({
              listenAddrs: listenAddresses.map((ma) => ma.bytes),
              signedPeerRecord: signedPeerRecord.marshal(),
              protocols: supportedProtocols,
              agentVersion,
              protocolVersion
            }, {
              signal
            });
            await stream.close({
              signal
            });
          } catch (err) {
            self.log.error("could not push identify update to peer", err);
            stream?.abort(err);
          }
        };
      }
    }
    await src_default(parallel(pushToConnections(), {
      concurrency: this.concurrency
    }));
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log("handled push from %p", connection.remotePeer);
  }
};

// ../../../../node_modules/@libp2p/identify/dist/src/identify.js
var Identify2 = class extends AbstractIdentify {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify"
  ];
  async _identify(connection, options = {}) {
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      return message2;
    } catch (err) {
      this.log.error("error while reading identify message", err);
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new CodeError("public key was missing from identify message", "ERR_MISSING_PUBLIC_KEY");
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw new CodeError("identified peer does not match the expected peer", "ERR_INVALID_PEER");
    }
    if (this.peerId.equals(id)) {
      throw new CodeError("identified peer is our own peer id?", "ERR_INVALID_PEER");
    }
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols);
    this.log("our observed address is %a", cleanObservedAddr);
    if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
      this.log("storing our observed address %a", cleanObservedAddr);
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
};

// ../../../../node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}
export {
  identify,
  identifyPush
};
//# sourceMappingURL=@libp2p_identify.js.map
