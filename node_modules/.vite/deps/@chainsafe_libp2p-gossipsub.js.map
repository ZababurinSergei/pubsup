{
  "version": 3,
  "sources": ["../../../../../../../node_modules/denque/index.js", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/constants.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/message/decodeRpc.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/float.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/longbits.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/utf8.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/reader.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/decode.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/pool.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/utils/writer.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/encode.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/codec.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/codecs/message.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/protons-runtime/src/index.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/message/rpc.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/message-cache.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/types.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/metrics.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/constants.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/peer-score-params.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/peer-score-thresholds.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/set.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/compute-score.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/message-deliveries.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/peer-score.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/score/scoreMetrics.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/stream.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/tracer.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/buildRawMessage.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/create-gossip-rpc.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/shuffle.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/messageIdToString.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/publishConfig.ts", "../../../../../../../node_modules/@libp2p/pubsub/src/utils.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/msgIdFn.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/multiaddr.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/utils/time-cache.ts", "../../../../../../../node_modules/@chainsafe/libp2p-gossipsub/src/index.ts"],
  "sourcesContent": ["'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n  this._capacity = options.capacity;\n\n  this._head = 0;\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  } else {\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n}\n\n/**\n * --------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (arguments.length === 0) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (arguments.length === 0) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._list = new Array(this._list.length);\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  var length = array.length;\n  var capacity = this._nextPowerOf2(length);\n\n  this._list = new Array(capacity);\n  this._capacityMask = capacity - 1;\n  this._tail = length;\n\n  for (var i = 0; i < length; i++) this._list[i] = array[i];\n};\n\n/**\n *\n * @param fullCopy\n * @param size Initialize the array with a specific size. Will default to the current list size\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy, size) {\n  var src = this._list;\n  var capacity = src.length;\n  var length = this.length;\n  size = size | length;\n\n  // No prealloc requested and the buffer is contiguous\n  if (size == length && this._head < this._tail) {\n    // Simply do a fast slice copy\n    return this._list.slice(this._head, this._tail);\n  }\n\n  var dest = new Array(size);\n\n  var k = 0;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < capacity; i++) dest[k++] = src[i];\n    for (i = 0; i < this._tail; i++) dest[k++] = src[i];\n  } else {\n    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];\n  }\n\n  return dest;\n}\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head != 0) {\n    // double array size and copy existing data, head to end, then beginning to tail.\n    var newList = this._copyArray(true, this._list.length << 1);\n\n    this._tail = this._list.length;\n    this._head = 0;\n\n    this._list = newList;\n  } else {\n    this._tail = this._list.length;\n    this._list.length <<= 1;\n  }\n\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n/**\n * Find the next power of 2, at least 4\n * @private\n * @param {number} num \n * @returns {number}\n */\nDenque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {\n  var log2 = Math.log(num) / Math.log(2);\n  var nextPow2 = 1 << (log2 + 1);\n\n  return Math.max(nextPow2, 4);\n}\n\nmodule.exports = Denque;\n", "export const second = 1000\nexport const minute = 60 * second\n\n// Protocol identifiers\n\nexport const FloodsubID = '/floodsub/1.0.0'\n\n/**\n * The protocol ID for version 1.0.0 of the Gossipsub protocol\n * It is advertised along with GossipsubIDv11 for backwards compatability\n */\nexport const GossipsubIDv10 = '/meshsub/1.0.0'\n\n/**\n * The protocol ID for version 1.1.0 of the Gossipsub protocol\n * See the spec for details about how v1.1.0 compares to v1.0.0:\n * https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md\n */\nexport const GossipsubIDv11 = '/meshsub/1.1.0'\n\n// Overlay parameters\n\n/**\n * GossipsubD sets the optimal degree for a Gossipsub topic mesh. For example, if GossipsubD == 6,\n * each peer will want to have about six peers in their mesh for each topic they're subscribed to.\n * GossipsubD should be set somewhere between GossipsubDlo and GossipsubDhi.\n */\nexport const GossipsubD = 6\n\n/**\n * GossipsubDlo sets the lower bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have fewer than GossipsubDlo peers, we will attempt to graft some more into the mesh at\n * the next heartbeat.\n */\nexport const GossipsubDlo = 4\n\n/**\n * GossipsubDhi sets the upper bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have more than GossipsubDhi peers, we will select some to prune from the mesh at the next heartbeat.\n */\nexport const GossipsubDhi = 12\n\n/**\n * GossipsubDscore affects how peers are selected when pruning a mesh due to over subscription.\n * At least GossipsubDscore of the retained peers will be high-scoring, while the remainder are\n * chosen randomly.\n */\nexport const GossipsubDscore = 4\n\n/**\n * GossipsubDout sets the quota for the number of outbound connections to maintain in a topic mesh.\n * When the mesh is pruned due to over subscription, we make sure that we have outbound connections\n * to at least GossipsubDout of the survivor peers. This prevents sybil attackers from overwhelming\n * our mesh with incoming connections.\n *\n * GossipsubDout must be set below GossipsubDlo, and must not exceed GossipsubD / 2.\n */\nexport const GossipsubDout = 2\n\n// Gossip parameters\n\n/**\n * GossipsubHistoryLength controls the size of the message cache used for gossip.\n * The message cache will remember messages for GossipsubHistoryLength heartbeats.\n */\nexport const GossipsubHistoryLength = 5\n\n/**\n * GossipsubHistoryGossip controls how many cached message ids we will advertise in\n * IHAVE gossip messages. When asked for our seen message IDs, we will return\n * only those from the most recent GossipsubHistoryGossip heartbeats. The slack between\n * GossipsubHistoryGossip and GossipsubHistoryLength allows us to avoid advertising messages\n * that will be expired by the time they're requested.\n *\n * GossipsubHistoryGossip must be less than or equal to GossipsubHistoryLength to\n * avoid a runtime panic.\n */\nexport const GossipsubHistoryGossip = 3\n\n/**\n * GossipsubDlazy affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to at least GossipsubDlazy peers outside our mesh. The actual\n * number may be more, depending on GossipsubGossipFactor and how many peers we're\n * connected to.\n */\nexport const GossipsubDlazy = 6\n\n/**\n * GossipsubGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to GossipsubGossipFactor * (total number of non-mesh peers), or\n * GossipsubDlazy, whichever is greater.\n */\nexport const GossipsubGossipFactor = 0.25\n\n/**\n * GossipsubGossipRetransmission controls how many times we will allow a peer to request\n * the same message id through IWANT gossip before we start ignoring them. This is designed\n * to prevent peers from spamming us with requests and wasting our resources.\n */\nexport const GossipsubGossipRetransmission = 3\n\n// Heartbeat interval\n\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexport const GossipsubHeartbeatInitialDelay = 100\n\n/**\n * GossipsubHeartbeatInterval controls the time between heartbeats.\n */\nexport const GossipsubHeartbeatInterval = second\n\n/**\n * GossipsubFanoutTTL controls how long we keep track of the fanout state. If it's been\n * GossipsubFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexport const GossipsubFanoutTTL = minute\n\n/**\n * GossipsubPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to GossipsubPrunePeers other peers that we\n * know of.\n */\nexport const GossipsubPrunePeers = 16\n\n/**\n * GossipsubPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of GossipsubPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least GossipsubPruneBackoff\n * before attempting to re-graft.\n */\nexport const GossipsubPruneBackoff = minute\n\n/**\n * Backoff to use when unsuscribing from a topic. Should not resubscribe to this topic before it expired.\n */\nexport const GossipsubUnsubscribeBackoff = 10 * second\n\n/**\n * GossipsubPruneBackoffTicks is the number of heartbeat ticks for attempting to prune expired\n * backoff timers.\n */\nexport const GossipsubPruneBackoffTicks = 15\n\n/**\n * GossipsubConnectors controls the number of active connection attempts for peers obtained through PX.\n */\nexport const GossipsubConnectors = 8\n\n/**\n * GossipsubMaxPendingConnections sets the maximum number of pending connections for peers attempted through px.\n */\nexport const GossipsubMaxPendingConnections = 128\n\n/**\n * GossipsubConnectionTimeout controls the timeout for connection attempts.\n */\nexport const GossipsubConnectionTimeout = 30 * second\n\n/**\n * GossipsubDirectConnectTicks is the number of heartbeat ticks for attempting to reconnect direct peers\n * that are not currently connected.\n */\nexport const GossipsubDirectConnectTicks = 300\n\n/**\n * GossipsubDirectConnectInitialDelay is the initial delay before opening connections to direct peers\n */\nexport const GossipsubDirectConnectInitialDelay = second\n\n/**\n * GossipsubOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every GossipsubOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexport const GossipsubOpportunisticGraftTicks = 60\n\n/**\n * GossipsubOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexport const GossipsubOpportunisticGraftPeers = 2\n\n/**\n * If a GRAFT comes before GossipsubGraftFloodThreshold has elapsed since the last PRUNE,\n * then there is an extra score penalty applied to the peer through P7.\n */\nexport const GossipsubGraftFloodThreshold = 10 * second\n\n/**\n * GossipsubMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexport const GossipsubMaxIHaveLength = 5000\n\n/**\n * GossipsubMaxIHaveMessages is the maximum number of IHAVE messages to accept from a peer within a heartbeat.\n */\nexport const GossipsubMaxIHaveMessages = 10\n\n/**\n * Time to wait for a message requested through IWANT following an IHAVE advertisement.\n * If the message is not received within this window, a broken promise is declared and\n * the router may apply bahavioural penalties.\n */\nexport const GossipsubIWantFollowupTime = 3 * second\n\n/**\n * Time in milliseconds to keep message ids in the seen cache\n */\nexport const GossipsubSeenTTL = 2 * minute\n\nexport const TimeCacheDuration = 120 * 1000\n\nexport const ERR_TOPIC_VALIDATOR_REJECT = 'ERR_TOPIC_VALIDATOR_REJECT'\nexport const ERR_TOPIC_VALIDATOR_IGNORE = 'ERR_TOPIC_VALIDATOR_IGNORE'\n\n/**\n * If peer score is better than this, we accept messages from this peer\n * within ACCEPT_FROM_WHITELIST_DURATION_MS from the last time computing score.\n **/\nexport const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept up to this\n * number of messages from that peer.\n */\nexport const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept messages from\n * this peer up to this time duration.\n */\nexport const ACCEPT_FROM_WHITELIST_DURATION_MS = 1000\n\n/**\n * The default MeshMessageDeliveriesWindow to be used in metrics.\n */\nexport const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1000\n\n/** Wait for 1 more heartbeats before clearing a backoff */\nexport const BACKOFF_SLACK = 1\n", "export interface DecodeRPCLimits {\n  maxSubscriptions: number\n  maxMessages: number\n  maxIhaveMessageIDs: number\n  maxIwantMessageIDs: number\n  maxControlMessages: number\n  maxPeerInfos: number\n}\n\nexport const defaultDecodeRpcLimits: DecodeRPCLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n}\n", "const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n", "// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n", "/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n", "import { decodeUint8Array, encodingLength } from 'uint8-varint'\nimport { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    const value = decodeUint8Array(this.buf, this.pos)\n    this.pos += encodingLength(value)\n    return value\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n", "import { createReader } from './utils/reader.js'\nimport type { Codec, DecodeOptions } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Pick<Codec<T>, 'decode'>, opts?: DecodeOptions<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader, undefined, opts)\n}\n", "import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n", "import { encodeUint8Array, encodingLength } from 'uint8-varint'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    return this._push(encodeUint8Array, encodingLength(value), value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n", "import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: Partial<T>, codec: Pick<Codec<T>, 'encode'>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\n// protobuf types that contain multiple values\ntype CollectionTypes = any[] | Map<any, any>\n\n// protobuf types that are not collections or messages\ntype PrimitiveTypes = boolean | number | string | bigint | Uint8Array\n\n// recursive array/map field length limits\ntype CollectionLimits <T> = {\n  [K in keyof T]: T[K] extends CollectionTypes ? number :\n    T[K] extends PrimitiveTypes ? never : Limits<T[K]>\n}\n\n// recursive array member array/map field length limits\ntype ArrayElementLimits <T> = {\n  [K in keyof T as `${string & K}$`]: T[K] extends Array<infer ElementType> ?\n      (ElementType extends PrimitiveTypes ? never : Limits<ElementType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// recursive map value array/map field length limits\ntype MapValueLimits <T> = {\n  [K in keyof T as `${string & K}$value`]: T[K] extends Map<any, infer MapValueType> ?\n      (MapValueType extends PrimitiveTypes ? never : Limits<MapValueType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// union of collection and array elements\ntype Limits<T> = Partial<CollectionLimits<T> & ArrayElementLimits<T> & MapValueLimits<T>>\n\nexport interface DecodeOptions<T> {\n  /**\n   * Runtime-specified limits for lengths of repeated/map fields\n   */\n  limits?: Limits<T>\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number, opts?: DecodeOptions<T>): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES, type EncodeFunction, type DecodeFunction, type Codec } from '../codec.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains serialization/deserialization code used when encoding/decoding protobufs.\n *\n * It should be declared as a dependency of your project:\n *\n * ```console\n * npm i protons-runtime\n * ```\n */\n\nimport type { Codec } from './codec.js'\n\nexport interface FieldDef {\n  name: string\n  codec: Codec<any>\n  optional?: true\n  repeats?: true\n  packed?: true\n}\n\nexport {\n  decodeMessage\n} from './decode.js'\n\nexport {\n  encodeMessage\n} from './encode.js'\n\nexport { enumeration } from './codecs/enum.js'\nexport { message } from './codecs/message.js'\nexport { createReader as reader } from './utils/reader.js'\nexport { createWriter as writer } from './utils/writer.js'\nexport type { Codec, EncodeOptions, DecodeOptions } from './codec.js'\n\nexport interface Writer {\n  /**\n   * Current length\n   */\n  len: number\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32(value: number): this\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32(value: number): this\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64(value: bigint): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String(value: string): this\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool(value: boolean): this\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32(value: number): this\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64(value: bigint): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String(value: string): this\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float(value: number): this\n\n  /**\n   * Writes a double (64 bit float)\n   */\n  double(value: number): this\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes(value: Uint8Array): this\n\n  /**\n   * Writes a string\n   */\n  string(value: string): this\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork(): this\n\n  /**\n   * Resets this instance to the last state.\n   */\n  reset(): this\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim(): this\n\n  /**\n   * Finishes the write operation\n   */\n  finish(): Uint8Array\n}\n\nexport interface Reader {\n  /**\n   * Read buffer\n   */\n  buf: Uint8Array\n\n  /**\n   * Read buffer position\n   */\n  pos: number\n\n  /**\n   * Read buffer length\n   */\n  len: number\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32(): number\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32(): number\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32(): number\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool(): boolean\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32(): number\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32(): number\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float(): number\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double(): number\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes(): Uint8Array\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string(): string\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varints`\n   */\n  skip(length?: number): void\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType(wireType: number): void\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64(): bigint\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64Number(): number\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64String(): string\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64(): bigint\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64Number(): number\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64String(): string\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64(): bigint\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64Number(): number\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64String(): string\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64(): bigint\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64Number(): number\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64String(): string\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64(): bigint\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64Number(): number\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64String(): string\n}\n\nexport class CodeError extends Error {\n  public code: string\n\n  constructor (message: string, code: string, options?: ErrorOptions) {\n    super(message, options)\n\n    this.code = code\n  }\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, CodeError, decodeMessage, type DecodeOptions, encodeMessage, message } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface RPC {\n  subscriptions: RPC.SubOpts[]\n  messages: RPC.Message[]\n  control?: RPC.ControlMessage\n}\n\nexport namespace RPC {\n  export interface SubOpts {\n    subscribe?: boolean\n    topic?: string\n  }\n\n  export namespace SubOpts {\n    let _codec: Codec<SubOpts>\n\n    export const codec = (): Codec<SubOpts> => {\n      if (_codec == null) {\n        _codec = message<SubOpts>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.subscribe != null) {\n            w.uint32(8)\n            w.bool(obj.subscribe)\n          }\n\n          if (obj.topic != null) {\n            w.uint32(18)\n            w.string(obj.topic)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.subscribe = reader.bool()\n                break\n              }\n              case 2: {\n                obj.topic = reader.string()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<SubOpts>): Uint8Array => {\n      return encodeMessage(obj, SubOpts.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<SubOpts>): SubOpts => {\n      return decodeMessage(buf, SubOpts.codec(), opts)\n    }\n  }\n\n  export interface Message {\n    from?: Uint8Array\n    data?: Uint8Array\n    seqno?: Uint8Array\n    topic: string\n    signature?: Uint8Array\n    key?: Uint8Array\n  }\n\n  export namespace Message {\n    let _codec: Codec<Message>\n\n    export const codec = (): Codec<Message> => {\n      if (_codec == null) {\n        _codec = message<Message>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.from != null) {\n            w.uint32(10)\n            w.bytes(obj.from)\n          }\n\n          if (obj.data != null) {\n            w.uint32(18)\n            w.bytes(obj.data)\n          }\n\n          if (obj.seqno != null) {\n            w.uint32(26)\n            w.bytes(obj.seqno)\n          }\n\n          if ((obj.topic != null && obj.topic !== '')) {\n            w.uint32(34)\n            w.string(obj.topic)\n          }\n\n          if (obj.signature != null) {\n            w.uint32(42)\n            w.bytes(obj.signature)\n          }\n\n          if (obj.key != null) {\n            w.uint32(50)\n            w.bytes(obj.key)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            topic: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.from = reader.bytes()\n                break\n              }\n              case 2: {\n                obj.data = reader.bytes()\n                break\n              }\n              case 3: {\n                obj.seqno = reader.bytes()\n                break\n              }\n              case 4: {\n                obj.topic = reader.string()\n                break\n              }\n              case 5: {\n                obj.signature = reader.bytes()\n                break\n              }\n              case 6: {\n                obj.key = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Message>): Uint8Array => {\n      return encodeMessage(obj, Message.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Message>): Message => {\n      return decodeMessage(buf, Message.codec(), opts)\n    }\n  }\n\n  export interface ControlMessage {\n    ihave: RPC.ControlIHave[]\n    iwant: RPC.ControlIWant[]\n    graft: RPC.ControlGraft[]\n    prune: RPC.ControlPrune[]\n  }\n\n  export namespace ControlMessage {\n    let _codec: Codec<ControlMessage>\n\n    export const codec = (): Codec<ControlMessage> => {\n      if (_codec == null) {\n        _codec = message<ControlMessage>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.ihave != null) {\n            for (const value of obj.ihave) {\n              w.uint32(10)\n              RPC.ControlIHave.codec().encode(value, w)\n            }\n          }\n\n          if (obj.iwant != null) {\n            for (const value of obj.iwant) {\n              w.uint32(18)\n              RPC.ControlIWant.codec().encode(value, w)\n            }\n          }\n\n          if (obj.graft != null) {\n            for (const value of obj.graft) {\n              w.uint32(26)\n              RPC.ControlGraft.codec().encode(value, w)\n            }\n          }\n\n          if (obj.prune != null) {\n            for (const value of obj.prune) {\n              w.uint32(34)\n              RPC.ControlPrune.codec().encode(value, w)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            ihave: [],\n            iwant: [],\n            graft: [],\n            prune: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {\n                  throw new CodeError('decode error - map field \"ihave\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.ihave.push(RPC.ControlIHave.codec().decode(reader, reader.uint32()))\n                break\n              }\n              case 2: {\n                if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {\n                  throw new CodeError('decode error - map field \"iwant\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.iwant.push(RPC.ControlIWant.codec().decode(reader, reader.uint32()))\n                break\n              }\n              case 3: {\n                if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {\n                  throw new CodeError('decode error - map field \"graft\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.graft.push(RPC.ControlGraft.codec().decode(reader, reader.uint32()))\n                break\n              }\n              case 4: {\n                if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {\n                  throw new CodeError('decode error - map field \"prune\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.prune.push(RPC.ControlPrune.codec().decode(reader, reader.uint32()))\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlMessage>): Uint8Array => {\n      return encodeMessage(obj, ControlMessage.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlMessage>): ControlMessage => {\n      return decodeMessage(buf, ControlMessage.codec(), opts)\n    }\n  }\n\n  export interface ControlIHave {\n    topicID?: string\n    messageIDs: Uint8Array[]\n  }\n\n  export namespace ControlIHave {\n    let _codec: Codec<ControlIHave>\n\n    export const codec = (): Codec<ControlIHave> => {\n      if (_codec == null) {\n        _codec = message<ControlIHave>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (obj.messageIDs != null) {\n            for (const value of obj.messageIDs) {\n              w.uint32(18)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            messageIDs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              case 2: {\n                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                  throw new CodeError('decode error - map field \"messageIDs\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.messageIDs.push(reader.bytes())\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlIHave>): Uint8Array => {\n      return encodeMessage(obj, ControlIHave.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIHave>): ControlIHave => {\n      return decodeMessage(buf, ControlIHave.codec(), opts)\n    }\n  }\n\n  export interface ControlIWant {\n    messageIDs: Uint8Array[]\n  }\n\n  export namespace ControlIWant {\n    let _codec: Codec<ControlIWant>\n\n    export const codec = (): Codec<ControlIWant> => {\n      if (_codec == null) {\n        _codec = message<ControlIWant>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.messageIDs != null) {\n            for (const value of obj.messageIDs) {\n              w.uint32(10)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            messageIDs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                  throw new CodeError('decode error - map field \"messageIDs\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.messageIDs.push(reader.bytes())\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlIWant>): Uint8Array => {\n      return encodeMessage(obj, ControlIWant.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIWant>): ControlIWant => {\n      return decodeMessage(buf, ControlIWant.codec(), opts)\n    }\n  }\n\n  export interface ControlGraft {\n    topicID?: string\n  }\n\n  export namespace ControlGraft {\n    let _codec: Codec<ControlGraft>\n\n    export const codec = (): Codec<ControlGraft> => {\n      if (_codec == null) {\n        _codec = message<ControlGraft>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlGraft>): Uint8Array => {\n      return encodeMessage(obj, ControlGraft.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlGraft>): ControlGraft => {\n      return decodeMessage(buf, ControlGraft.codec(), opts)\n    }\n  }\n\n  export interface ControlPrune {\n    topicID?: string\n    peers: RPC.PeerInfo[]\n    backoff?: number\n  }\n\n  export namespace ControlPrune {\n    let _codec: Codec<ControlPrune>\n\n    export const codec = (): Codec<ControlPrune> => {\n      if (_codec == null) {\n        _codec = message<ControlPrune>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (obj.peers != null) {\n            for (const value of obj.peers) {\n              w.uint32(18)\n              RPC.PeerInfo.codec().encode(value, w)\n            }\n          }\n\n          if (obj.backoff != null) {\n            w.uint32(24)\n            w.uint64Number(obj.backoff)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            peers: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              case 2: {\n                if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {\n                  throw new CodeError('decode error - map field \"peers\" had too many elements', 'ERR_MAX_LENGTH')\n                }\n\n                obj.peers.push(RPC.PeerInfo.codec().decode(reader, reader.uint32()))\n                break\n              }\n              case 3: {\n                obj.backoff = reader.uint64Number()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlPrune>): Uint8Array => {\n      return encodeMessage(obj, ControlPrune.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlPrune>): ControlPrune => {\n      return decodeMessage(buf, ControlPrune.codec(), opts)\n    }\n  }\n\n  export interface PeerInfo {\n    peerID?: Uint8Array\n    signedPeerRecord?: Uint8Array\n  }\n\n  export namespace PeerInfo {\n    let _codec: Codec<PeerInfo>\n\n    export const codec = (): Codec<PeerInfo> => {\n      if (_codec == null) {\n        _codec = message<PeerInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.peerID != null) {\n            w.uint32(10)\n            w.bytes(obj.peerID)\n          }\n\n          if (obj.signedPeerRecord != null) {\n            w.uint32(18)\n            w.bytes(obj.signedPeerRecord)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.peerID = reader.bytes()\n                break\n              }\n              case 2: {\n                obj.signedPeerRecord = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<PeerInfo>): Uint8Array => {\n      return encodeMessage(obj, PeerInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerInfo>): PeerInfo => {\n      return decodeMessage(buf, PeerInfo.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<RPC>\n\n  export const codec = (): Codec<RPC> => {\n    if (_codec == null) {\n      _codec = message<RPC>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.subscriptions != null) {\n          for (const value of obj.subscriptions) {\n            w.uint32(10)\n            RPC.SubOpts.codec().encode(value, w)\n          }\n        }\n\n        if (obj.messages != null) {\n          for (const value of obj.messages) {\n            w.uint32(18)\n            RPC.Message.codec().encode(value, w)\n          }\n        }\n\n        if (obj.control != null) {\n          w.uint32(26)\n          RPC.ControlMessage.codec().encode(obj.control, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          subscriptions: [],\n          messages: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {\n                throw new CodeError('decode error - map field \"subscriptions\" had too many elements', 'ERR_MAX_LENGTH')\n              }\n\n              obj.subscriptions.push(RPC.SubOpts.codec().decode(reader, reader.uint32()))\n              break\n            }\n            case 2: {\n              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {\n                throw new CodeError('decode error - map field \"messages\" had too many elements', 'ERR_MAX_LENGTH')\n              }\n\n              obj.messages.push(RPC.Message.codec().decode(reader, reader.uint32()))\n              break\n            }\n            case 3: {\n              obj.control = RPC.ControlMessage.codec().decode(reader, reader.uint32())\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<RPC>): Uint8Array => {\n    return encodeMessage(obj, RPC.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<RPC>): RPC => {\n    return decodeMessage(buf, RPC.codec(), opts)\n  }\n}\n", "import type { RPC } from './message/rpc.js'\nimport type { MessageId, MsgIdStr, PeerIdStr, TopicStr, MsgIdToStrFn } from './types.js'\n\nexport type CacheEntry = MessageId & {\n  topic: TopicStr\n}\n\nexport type MessageCacheRecord = Pick<MessageCacheEntry, 'message' | 'originatingPeers'>\n\ninterface MessageCacheEntry {\n  message: RPC.Message\n  /**\n   * Tracks if the message has been validated by the app layer and thus forwarded\n   */\n  validated: boolean\n  /**\n   * Tracks peers that sent this message before it has been validated by the app layer\n   */\n  originatingPeers: Set<PeerIdStr>\n  /**\n   * For every message and peer the number of times this peer asked for the message\n   */\n  iwantCounts: Map<PeerIdStr, number>\n}\n\nexport class MessageCache {\n  msgs = new Map<MsgIdStr, MessageCacheEntry>()\n\n  msgIdToStrFn: MsgIdToStrFn\n\n  history: CacheEntry[][] = []\n\n  /** Track with accounting of messages in the mcache that are not yet validated */\n  notValidatedCount = 0\n\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor (\n    /**\n     * The number of indices in the cache history used for gossiping. That means that a message\n     * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n     * message in the cache.\n     */\n    private readonly gossip: number,\n    historyCapacity: number,\n    msgIdToStrFn: MsgIdToStrFn\n  ) {\n    this.msgIdToStrFn = msgIdToStrFn\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = []\n    }\n  }\n\n  get size (): number {\n    return this.msgs.size\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n  put (messageId: MessageId, msg: RPC.Message, validated = false): boolean {\n    const { msgIdStr } = messageId\n    // Don't add duplicate entries to the cache.\n    if (this.msgs.has(msgIdStr)) {\n      return false\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    })\n\n    this.history[0].push({ ...messageId, topic: msg.topic })\n\n    if (!validated) {\n      this.notValidatedCount++\n    }\n\n    return true\n  }\n\n  observeDuplicate (msgId: MsgIdStr, fromPeerIdStr: PeerIdStr): void {\n    const entry = this.msgs.get(msgId)\n\n    if (\n      (entry != null) &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated\n    ) {\n      entry.originatingPeers.add(fromPeerIdStr)\n    }\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n  get (msgId: Uint8Array): RPC.Message | undefined {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message\n  }\n\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n  getWithIWantCount (msgIdStr: string, p: string): { msg: RPC.Message, count: number } | null {\n    const msg = this.msgs.get(msgIdStr)\n    if (msg == null) {\n      return null\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1\n    msg.iwantCounts.set(p, count)\n\n    return { msg: msg.message, count }\n  }\n\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n  getGossipIDs (topics: Set<string>): Map<string, Uint8Array[]> {\n    const msgIdsByTopic = new Map<string, Uint8Array[]>()\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        const msg = this.msgs.get(entry.msgIdStr)\n        if ((msg?.validated ?? false) && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic)\n          if (msgIds == null) {\n            msgIds = []\n            msgIdsByTopic.set(entry.topic, msgIds)\n          }\n          msgIds.push(entry.msgId)\n        }\n      })\n    }\n\n    return msgIdsByTopic\n  }\n\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n  validate (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--\n    }\n\n    const { message, originatingPeers } = entry\n    entry.validated = true\n    // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n    entry.originatingPeers = new Set()\n    return { message, originatingPeers }\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n  shift (): void {\n    const lastCacheEntries = this.history[this.history.length - 1]\n    lastCacheEntries.forEach((cacheEntry) => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr)\n      if (entry != null) {\n        this.msgs.delete(cacheEntry.msgIdStr)\n        if (!entry.validated) {\n          this.notValidatedCount--\n        }\n      }\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n\n  remove (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    // Keep the message on the history vector, it will be dropped on a shift()\n    this.msgs.delete(msgId)\n    return entry\n  }\n}\n", "import { type Message, TopicValidatorResult, type PrivateKey, type PeerId } from '@libp2p/interface'\nimport type { RPC } from './message/rpc.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type MsgIdStr = string\nexport type PeerIdStr = string\nexport type TopicStr = string\nexport type IPStr = string\n\nexport interface AddrInfo {\n  id: PeerId\n  addrs: Multiaddr[]\n}\n\n/**\n * Compute a local non-spec'ed msg-id for faster de-duplication of seen messages.\n * Used exclusively for a local seen_cache\n */\nexport interface FastMsgIdFn { (msg: RPC.Message): string | number }\n\n/**\n * By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n * Application could use this option to provide a more efficient function.\n */\nexport interface MsgIdToStrFn { (msgId: Uint8Array): string }\n\n/**\n * Compute spec'ed msg-id. Used for IHAVE / IWANT messages\n */\nexport interface MsgIdFn {\n  (msg: Message): Promise<Uint8Array> | Uint8Array\n}\n\nexport interface DataTransform {\n  /**\n   * Takes the data published by peers on a topic and transforms the data.\n   * Should be the reverse of outboundTransform(). Example:\n   * - `inboundTransform()`: decompress snappy payload\n   * - `outboundTransform()`: compress snappy payload\n   */\n  inboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n\n  /**\n   * Takes the data to be published (a topic and associated data) transforms the data. The\n   * transformed data will then be used to create a `RawGossipsubMessage` to be sent to peers.\n   */\n  outboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n}\n\nexport enum SignaturePolicy {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign = 'StrictSign',\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign = 'StrictNoSign'\n}\n\nexport interface PublishOpts {\n  /**\n   * Do not throw `PublishError.NoPeersSubscribedToTopic` error if there are no\n   * peers listening on the topic.\n   *\n   * N.B. if you sent this option to true, and you publish a message on a topic\n   * with no peers listening on that topic, no other network node will ever\n   * receive the message.\n   */\n  allowPublishToZeroTopicPeers?: boolean\n  ignoreDuplicatePublishError?: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish?: boolean\n}\n\nexport enum PublishConfigType {\n  Signing,\n  Anonymous\n}\n\nexport type PublishConfig =\n  | {\n    type: PublishConfigType.Signing\n    author: PeerId\n    key: Uint8Array\n    privateKey: PrivateKey\n  }\n  | { type: PublishConfigType.Anonymous }\n\nexport type RejectReasonObj =\n  | { reason: RejectReason.Error, error: ValidateError }\n  | { reason: Exclude<RejectReason, RejectReason.Error> }\n\nexport enum RejectReason {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  Error = 'error',\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n  Ignore = 'ignore',\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n  Reject = 'reject',\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n  Blacklisted = 'blacklisted'\n}\n\nexport enum ValidateError {\n  /// The message has an invalid signature,\n  InvalidSignature = 'invalid_signature',\n  /// The sequence number was the incorrect size\n  InvalidSeqno = 'invalid_seqno',\n  /// The PeerId was invalid\n  InvalidPeerId = 'invalid_peerid',\n  /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SignaturePresent = 'signature_present',\n  /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SeqnoPresent = 'seqno_present',\n  /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  FromPresent = 'from_present',\n  /// The data transformation failed.\n  TransformFailed = 'transform_failed'\n}\n\nexport enum MessageStatus {\n  duplicate = 'duplicate',\n  invalid = 'invalid',\n  valid = 'valid'\n}\n\n/**\n * Store both Uint8Array and string message id so that we don't have to convert data between the two.\n * See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/274\n */\nexport interface MessageId {\n  msgId: Uint8Array\n  msgIdStr: MsgIdStr\n}\n\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance (\n  acceptance: Exclude<TopicValidatorResult, TopicValidatorResult.Accept>\n): RejectReason.Ignore | RejectReason.Reject {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "import { TopicValidatorResult } from '@libp2p/interface'\nimport {\n  MessageStatus,\n  type PeerIdStr,\n  RejectReason,\n  type RejectReasonObj,\n  type TopicStr,\n  type ValidateError\n} from './types.js'\nimport type { RPC } from './message/rpc.js'\nimport type { PeerScoreThresholds } from './score/peer-score-thresholds.js'\n\n/** Topic label as provided in `topicStrToLabel` */\nexport type TopicLabel = string\nexport type TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport enum MessageSource {\n  forward = 'forward',\n  publish = 'publish'\n}\n\ntype NoLabels = Record<string, never>\ntype LabelsGeneric = Record<string, string | number>\ntype LabelKeys<Labels extends LabelsGeneric> = Extract<keyof Labels, string>\ninterface CollectFn<Labels extends LabelsGeneric> { (metric: Gauge<Labels>): void }\n\nexport interface Gauge<Labels extends LabelsGeneric = NoLabels> {\n  inc: NoLabels extends Labels ? (value?: number) => void : (labels: Labels, value?: number) => void\n  set: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  addCollect(collectFn: CollectFn<Labels>): void\n}\n\nexport interface Histogram<Labels extends LabelsGeneric = NoLabels> {\n  startTimer(): () => void\n\n  observe: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  reset(): void\n}\n\nexport interface AvgMinMax<Labels extends LabelsGeneric = NoLabels> {\n  set: NoLabels extends Labels ? (values: number[]) => void : (labels: Labels, values: number[]) => void\n}\n\nexport type GaugeConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n} & (NoLabels extends Labels ? { labelNames?: never } : { labelNames: [LabelKeys<Labels>, ...Array<LabelKeys<Labels>>] })\n\nexport type HistogramConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels> & {\n  buckets?: number[]\n}\n\nexport type AvgMinMaxConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels>\n\nexport interface MetricsRegister {\n  gauge<Labels extends LabelsGeneric = NoLabels>(config: GaugeConfig<Labels>): Gauge<Labels>\n  histogram<Labels extends LabelsGeneric = NoLabels>(config: HistogramConfig<Labels>): Histogram<Labels>\n  avgMinMax<Labels extends LabelsGeneric = NoLabels>(config: AvgMinMaxConfig<Labels>): AvgMinMax<Labels>\n}\n\nexport enum InclusionReason {\n  /** Peer was a fanaout peer. */\n  Fanout = 'fanout',\n  /** Included from random selection. */\n  Random = 'random',\n  /** Peer subscribed. */\n  Subscribed = 'subscribed',\n  /** On heartbeat, peer was included to fill the outbound quota. */\n  Outbound = 'outbound',\n  /** On heartbeat, not enough peers in mesh */\n  NotEnough = 'not_enough',\n  /** On heartbeat opportunistic grafting due to low mesh score */\n  Opportunistic = 'opportunistic'\n}\n\n/// Reasons why a peer was removed from the mesh.\nexport enum ChurnReason {\n  /// Peer disconnected.\n  Dc = 'disconnected',\n  /// Peer had a bad score.\n  BadScore = 'bad_score',\n  /// Peer sent a PRUNE.\n  Prune = 'prune',\n  /// Too many peers.\n  Excess = 'excess'\n}\n\n/// Kinds of reasons a peer's score has been penalized\nexport enum ScorePenalty {\n  /// A peer grafted before waiting the back-off time.\n  GraftBackoff = 'graft_backoff',\n  /// A Peer did not respond to an IWANT request in time.\n  BrokenPromise = 'broken_promise',\n  /// A Peer did not send enough messages as expected.\n  MessageDeficit = 'message_deficit',\n  /// Too many peers under one IP address.\n  IPColocation = 'IP_colocation'\n}\n\nexport enum IHaveIgnoreReason {\n  LowScore = 'low_score',\n  MaxIhave = 'max_ihave',\n  MaxIasked = 'max_iasked'\n}\n\nexport enum ScoreThreshold {\n  graylist = 'graylist',\n  publish = 'publish',\n  gossip = 'gossip',\n  mesh = 'mesh'\n}\n\nexport type PeersByScoreThreshold = Record<ScoreThreshold, number>\n\nexport interface ToSendGroupCount {\n  direct: number\n  floodsub: number\n  mesh: number\n  fanout: number\n}\n\nexport interface ToAddGroupCount {\n  fanout: number\n  random: number\n}\n\nexport type PromiseDeliveredStats =\n  | { expired: false, requestedCount: number, maxDeliverMs: number }\n  | { expired: true, maxDeliverMs: number }\n\nexport interface TopicScoreWeights<T> { p1w: T, p2w: T, p3w: T, p3bw: T, p4w: T }\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport type Metrics = ReturnType<typeof getMetrics>\n\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n * NOTE: except for special reasons, do not add more than 1 label for frequent metrics,\n * there's a performance penalty as of June 2023.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type\nexport function getMetrics (\n  register: MetricsRegister,\n  topicStrToLabel: TopicStrToLabel,\n  opts: { gossipPromiseExpireSec: number, behaviourPenaltyThreshold: number, maxMeshMessageDeliveriesWindowSec: number }\n) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n    /**\n     * Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     * filtered by our current subscription status.\n     * = rust-libp2p `topic_subscription_status` */\n    topicSubscriptionStatus: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status. */\n    topicPeersCount: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n    /**\n     * Number of peers in our mesh. This metric should be updated with the count of peers for a\n     * topic in the mesh regardless of inclusion and churn events.\n     * = rust-libp2p `mesh_peer_counts` */\n    meshPeerCounts: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n    /**\n     * Number of times we include peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_inclusion_events` */\n    meshPeerInclusionEventsFanout: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_fanout_total',\n      help: 'Number of times we include peers in a topic mesh for fanout reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsRandom: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_random_total',\n      help: 'Number of times we include peers in a topic mesh for random reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsSubscribed: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_subscribed_total',\n      help: 'Number of times we include peers in a topic mesh for subscribed reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOutbound: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_outbound_total',\n      help: 'Number of times we include peers in a topic mesh for outbound reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsNotEnough: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_not_enough_total',\n      help: 'Number of times we include peers in a topic mesh for not_enough reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOpportunistic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_opportunistic_total',\n      help: 'Number of times we include peers in a topic mesh for opportunistic reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_unknown_total',\n      help: 'Number of times we include peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n    /**\n     * Number of times we remove peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_churn_events` */\n    meshPeerChurnEventsDisconnected: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_disconnected_total',\n      help: 'Number of times we remove peers in a topic mesh for disconnected reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsBadScore: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_bad_score_total',\n      help: 'Number of times we remove peers in a topic mesh for bad_score reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsPrune: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_prune_total',\n      help: 'Number of times we remove peers in a topic mesh for prune reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsExcess: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_excess_total',\n      help: 'Number of times we remove peers in a topic mesh for excess reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_unknown_total',\n      help: 'Number of times we remove peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n\n    /* General Metrics */\n    /**\n     * Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n     * on which protocol they support. This metric keeps track of the number of peers that are\n     * connected of each type. */\n    peersPerProtocol: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /**\n     * Message validation results for each topic.\n     * Invalid == Reject?\n     * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n    acceptedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_accepted_messages_total',\n      help: 'Total accepted messages for each topic',\n      labelNames: ['topic']\n    }),\n    ignoredMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ignored_messages_total',\n      help: 'Total ignored messages for each topic',\n      labelNames: ['topic']\n    }),\n    rejectedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_rejected_messages_total',\n      help: 'Total rejected messages for each topic',\n      labelNames: ['topic']\n    }),\n    unknownValidationResultsTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_unknown_validation_results_total',\n      help: 'Total unknown validation results for each topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     * message expires from the memcache before it can be validated, we count this a cache miss\n     * and it is an indicator that the memcache size should be increased.\n     * = rust-libp2p `mcache_misses` */\n    asyncValidationMcacheHit: register.gauge<{ hit: 'hit' | 'miss' }>({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n\n    asyncValidationDelayFromFirstSeenSec: register.histogram({\n      name: 'gossipsub_async_validation_delay_from_first_seen',\n      help: 'Async validation report delay from first seen in second',\n      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]\n    }),\n\n    asyncValidationUnknownFirstSeen: register.gauge({\n      name: 'gossipsub_async_validation_unknown_first_seen_count_total',\n      help: 'Async validation report unknown first seen value for message'\n    }),\n\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n    rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n    rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n    rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n    rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n    rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n    rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n    rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n    rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n    rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n    rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n    rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n    rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n    rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n    rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n    rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n    rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n    rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n    rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n\n    // publish message. Track peers sent to and bytes\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeersByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers (by group) that we publish a msg to */\n    directPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_direct_peers_published_total',\n      help: 'Total direct peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    floodsubPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_floodsub_peers_published_total',\n      help: 'Total floodsub peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    meshPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peers_published_total',\n      help: 'Total mesh peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    fanoutPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_fanout_peers_published_total',\n      help: 'Total fanout peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n    /** Total time in seconds to publish a message */\n    msgPublishTime: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_seconds',\n      help: 'Total time in seconds to publish a message',\n      buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    prevalidationInvalidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_invalid_total',\n      help: 'Total count of invalid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationValidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_valid_total',\n      help: 'Total count of valid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationDuplicateTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_duplicate_total',\n      help: 'Total count of duplicate messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationUnknownTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_unknown_status_total',\n      help: 'Total count of unknown_status messages received',\n      labelNames: ['topic']\n    }),\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge<{ error: RejectReason | ValidateError }>({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['error']\n    }),\n    msgReceivedInvalidByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_invalid_by_topic_total',\n      help: 'Tracks specific invalid message by topic',\n      labelNames: ['topic']\n    }),\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [\n        0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n        0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n        Number(opts.maxMeshMessageDeliveriesWindowSec),\n        2 * opts.maxMeshMessageDeliveriesWindowSec,\n        4 * opts.maxMeshMessageDeliveriesWindowSec\n      ]\n    }),\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n\n    duplicateMsgIgnored: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge<{ threshold: ScoreThreshold }>({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores'\n    }),\n    /**\n     * Separate score weights\n     * Need to use 2-label metrics in this case to debug the score weights\n     **/\n    scoreWeights: register.avgMinMax<{ topic?: TopicLabel, p: string }>({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax<{ topic: TopicLabel }>({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge<{ penalty: ScorePenalty }>({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [\n        0.25 * opts.behaviourPenaltyThreshold,\n        0.5 * opts.behaviourPenaltyThreshold,\n        Number(opts.behaviourPenaltyThreshold),\n        2 * opts.behaviourPenaltyThreshold,\n        4 * opts.behaviourPenaltyThreshold\n      ]\n    }),\n\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge<{ reason: IHaveIgnoreReason }>({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * Total messages per topic we don't have. Not actual requests.\n     * The number of times we have decided that an IWANT control message is required for this\n     * topic. A very high metric might indicate an underperforming network.\n     * = rust-libp2p `topic_iwant_msgs` */\n    ihaveRcvNotSeenMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [\n        0.5 * opts.gossipPromiseExpireSec,\n        Number(opts.gossipPromiseExpireSec),\n        2 * opts.gossipPromiseExpireSec,\n        4 * opts.gossipPromiseExpireSec\n      ]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n    /** Backoff time */\n    connectedPeersBackoffSec: register.histogram({\n      name: 'gossipsub_connected_peers_backoff_seconds',\n      help: 'Backoff time in seconds',\n      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.\n      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.\n      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case\n      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters\n      buckets: [1, 2, 4, 10, 20, 60, 120]\n    }),\n\n    /* Data structure sizes */\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge<{ cache: string }>({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n\n    newConnectionCount: register.gauge<{ status: string }>({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n\n    topicStrToLabel,\n\n    toTopic (topicStr: TopicStr): TopicLabel {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr\n    },\n\n    /** We joined a topic */\n    onJoin (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 1)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** We left a topic */\n    onLeave (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 0)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh (topicStr: TopicStr, reason: InclusionReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case InclusionReason.Fanout:\n          this.meshPeerInclusionEventsFanout.inc({ topic }, count)\n          break\n        case InclusionReason.Random:\n          this.meshPeerInclusionEventsRandom.inc({ topic }, count)\n          break\n        case InclusionReason.Subscribed:\n          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count)\n          break\n        case InclusionReason.Outbound:\n          this.meshPeerInclusionEventsOutbound.inc({ topic }, count)\n          break\n        case InclusionReason.NotEnough:\n          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count)\n          break\n        case InclusionReason.Opportunistic:\n          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerInclusionEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh (topicStr: TopicStr, reason: ChurnReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case ChurnReason.Dc:\n          this.meshPeerChurnEventsDisconnected.inc({ topic }, count)\n          break\n        case ChurnReason.BadScore:\n          this.meshPeerChurnEventsBadScore.inc({ topic }, count)\n          break\n        case ChurnReason.Prune:\n          this.meshPeerChurnEventsPrune.inc({ topic }, count)\n          break\n        case ChurnReason.Excess:\n          this.meshPeerChurnEventsExcess.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerChurnEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /**\n     * Update validation result to metrics\n     *\n     * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report\n     */\n    onReportValidation (\n      messageRecord: { message: { topic: TopicStr } } | null,\n      acceptance: TopicValidatorResult,\n      firstSeenTimestampMs: number | null\n    ): void {\n      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? 'hit' : 'miss' })\n\n      if (messageRecord != null) {\n        const topic = this.toTopic(messageRecord.message.topic)\n        switch (acceptance) {\n          case TopicValidatorResult.Accept:\n            this.acceptedMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Ignore:\n            this.ignoredMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Reject:\n            this.rejectedMessagesTotal.inc({ topic })\n            break\n          default:\n            this.unknownValidationResultsTotal.inc({ topic })\n            break\n        }\n      }\n\n      if (firstSeenTimestampMs != null) {\n        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000)\n      } else {\n        this.asyncValidationUnknownFirstSeen.inc()\n      }\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty (penalty: ScorePenalty): void {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({ penalty }, 1)\n    },\n\n    onIhaveRcv (topicStr: TopicStr, ihave: number, idonthave: number): void {\n      const topic = this.toTopic(topicStr)\n      this.ihaveRcvMsgids.inc({ topic }, ihave)\n      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave)\n    },\n\n    onIwantRcv (iwantByTopic: Map<TopicStr, number>, iwantDonthave: number): void {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr)\n        this.iwantRcvMsgids.inc({ topic }, iwant)\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave)\n    },\n\n    onForwardMsg (topicStr: TopicStr, tosendCount: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgForwardCount.inc({ topic }, 1)\n      this.msgForwardPeers.inc({ topic }, tosendCount)\n    },\n\n    onPublishMsg (\n      topicStr: TopicStr,\n      tosendGroupCount: ToSendGroupCount,\n      tosendCount: number,\n      dataLen: number,\n      ms: number\n    ): void {\n      const topic = this.toTopic(topicStr)\n      this.msgPublishCount.inc({ topic }, 1)\n      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen)\n      this.msgPublishPeersByTopic.inc({ topic }, tosendCount)\n      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct)\n      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub)\n      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh)\n      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout)\n      this.msgPublishTime.observe({ topic }, ms / 1000)\n    },\n\n    onMsgRecvPreValidation (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedPreValidation.inc({ topic }, 1)\n    },\n\n    onMsgRecvError (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedError.inc({ topic }, 1)\n    },\n\n    onPrevalidationResult (topicStr: TopicStr, status: MessageStatus): void {\n      const topic = this.toTopic(topicStr)\n      switch (status) {\n        case MessageStatus.duplicate:\n          this.prevalidationDuplicateTotal.inc({ topic })\n          break\n        case MessageStatus.invalid:\n          this.prevalidationInvalidTotal.inc({ topic })\n          break\n        case MessageStatus.valid:\n          this.prevalidationValidTotal.inc({ topic })\n          break\n        default:\n          this.prevalidationUnknownTotal.inc({ topic })\n          break\n      }\n    },\n\n    onMsgRecvInvalid (topicStr: TopicStr, reason: RejectReasonObj): void {\n      const topic = this.toTopic(topicStr)\n\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason\n      this.msgReceivedInvalid.inc({ error }, 1)\n      this.msgReceivedInvalidByTopic.inc({ topic }, 1)\n    },\n\n    onDuplicateMsgDelivery (topicStr: TopicStr, deliveryDelayMs: number, isLateDelivery: boolean): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1000)\n      if (isLateDelivery) {\n        this.duplicateMsgLateDelivery.inc({ topic }, 1)\n      }\n    },\n\n    onPublishDuplicateMsg (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgIgnored.inc({ topic }, 1)\n    },\n\n    onPeerReadStreamError (): void {\n      this.peerReadStreamError.inc(1)\n    },\n\n    onRpcRecvError (): void {\n      this.rpcRecvError.inc(1)\n    },\n\n    onRpcDataError (): void {\n      this.rpcDataError.inc(1)\n    },\n\n    onRpcRecv (rpc: RPC, rpcBytes: number): void {\n      this.rpcRecvBytes.inc(rpcBytes)\n      this.rpcRecvCount.inc(1)\n      if (rpc.subscriptions != null) this.rpcRecvSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages != null) this.rpcRecvMessage.inc(rpc.messages.length)\n      if (rpc.control != null) {\n        this.rpcRecvControl.inc(1)\n        if (rpc.control.ihave != null) this.rpcRecvIHave.inc(rpc.control.ihave.length)\n        if (rpc.control.iwant != null) this.rpcRecvIWant.inc(rpc.control.iwant.length)\n        if (rpc.control.graft != null) this.rpcRecvGraft.inc(rpc.control.graft.length)\n        if (rpc.control.prune != null) this.rpcRecvPrune.inc(rpc.control.prune.length)\n      }\n    },\n\n    onRpcSent (rpc: RPC, rpcBytes: number): void {\n      this.rpcSentBytes.inc(rpcBytes)\n      this.rpcSentCount.inc(1)\n      if (rpc.subscriptions != null) this.rpcSentSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages != null) this.rpcSentMessage.inc(rpc.messages.length)\n      if (rpc.control != null) {\n        const ihave = rpc.control.ihave?.length ?? 0\n        const iwant = rpc.control.iwant?.length ?? 0\n        const graft = rpc.control.graft?.length ?? 0\n        const prune = rpc.control.prune?.length ?? 0\n        if (ihave > 0) this.rpcSentIHave.inc(ihave)\n        if (iwant > 0) this.rpcSentIWant.inc(iwant)\n        if (graft > 0) this.rpcSentGraft.inc(graft)\n        if (prune > 0) this.rpcSentPrune.inc(prune)\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0) this.rpcSentControl.inc(1)\n      }\n    },\n\n    registerScores (scores: number[], scoreThresholds: PeerScoreThresholds): void {\n      let graylist = 0\n      let publish = 0\n      let gossip = 0\n      let mesh = 0\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) graylist++\n        if (score >= scoreThresholds.publishThreshold) publish++\n        if (score >= scoreThresholds.gossipThreshold) gossip++\n        if (score >= 0) mesh++\n      }\n\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh)\n\n      // Register full score too\n      this.score.set(scores)\n    },\n\n    registerScoreWeights (sw: ScoreWeights<number[]>): void {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w)\n        this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w)\n        this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w)\n        this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw)\n        this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w)\n      }\n\n      this.scoreWeights.set({ p: 'p5' }, sw.p5w)\n      this.scoreWeights.set({ p: 'p6' }, sw.p6w)\n      this.scoreWeights.set({ p: 'p7' }, sw.p7w)\n    },\n\n    registerScorePerMesh (mesh: Map<TopicStr, Set<PeerIdStr>>, scoreByPeer: Map<PeerIdStr, number>): void {\n      const peersPerTopicLabel = new Map<TopicLabel, Set<PeerIdStr>>()\n\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown'\n        let peersInMesh = peersPerTopicLabel.get(topicLabel)\n        if (peersInMesh == null) {\n          peersInMesh = new Set()\n          peersPerTopicLabel.set(topicLabel, peersInMesh)\n        }\n        peers.forEach((p) => peersInMesh?.add(p))\n      })\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores: number[] = []\n        peers.forEach((peer) => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0)\n        })\n        this.scorePerMesh.set({ topic }, meshScores)\n      }\n    }\n  }\n}\n", "export const ERR_INVALID_PEER_SCORE_PARAMS = 'ERR_INVALID_PEER_SCORE_PARAMS'\nexport const ERR_INVALID_PEER_SCORE_THRESHOLDS = 'ERR_INVALID_PEER_SCORE_THRESHOLDS'\n", "import { CodeError } from '@libp2p/interface'\nimport { ERR_INVALID_PEER_SCORE_PARAMS } from './constants.js'\n\n// This file defines PeerScoreParams and TopicScoreParams interfaces\n// as well as constructors, default constructors, and validation functions\n// for these interfaces\n\nexport interface PeerScoreParams {\n  /**\n   * Score parameters per topic.\n   */\n  topics: Record<string, TopicScoreParams>\n\n  /**\n   * Aggregate topic score cap; this limits the total contribution of topics towards a positive\n   * score. It must be positive (or 0 for no cap).\n   */\n  topicScoreCap: number\n\n  /**\n   * P5: Application-specific peer scoring\n   */\n  appSpecificScore(p: string): number\n  appSpecificWeight: number\n\n  /**\n   * P6: IP-colocation factor.\n   * The parameter has an associated counter which counts the number of peers with the same IP.\n   * If the number of peers in the same IP exceeds IPColocationFactorThreshold, then the value\n   * is the square of the difference, ie (PeersInSameIP - IPColocationThreshold)^2.\n   * If the number of peers in the same IP is less than the threshold, then the value is 0.\n   * The weight of the parameter MUST be negative, unless you want to disable for testing.\n   * Note: In order to simulate many IPs in a managable manner when testing, you can set the weight to 0\n   * thus disabling the IP colocation penalty.\n   */\n  IPColocationFactorWeight: number\n  IPColocationFactorThreshold: number\n  IPColocationFactorWhitelist: Set<string>\n\n  /**\n   * P7: behavioural pattern penalties.\n   * This parameter has an associated counter which tracks misbehaviour as detected by the\n   * router. The router currently applies penalties for the following behaviors:\n   * - attempting to re-graft before the prune backoff time has elapsed.\n   * - not following up in IWANT requests for messages advertised with IHAVE.\n   *\n   * The value of the parameter is the square of the counter, which decays with  BehaviourPenaltyDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  behaviourPenaltyWeight: number\n  behaviourPenaltyThreshold: number\n  behaviourPenaltyDecay: number\n\n  /**\n   * the decay interval for parameter counters.\n   */\n  decayInterval: number\n\n  /**\n   * counter value below which it is considered 0.\n   */\n  decayToZero: number\n\n  /**\n   * time to remember counters for a disconnected peer.\n   */\n  retainScore: number\n}\n\nexport interface TopicScoreParams {\n  /**\n   * The weight of the topic.\n   */\n  topicWeight: number\n\n  /**\n   * P1: time in the mesh\n   * This is the time the peer has ben grafted in the mesh.\n   * The value of the parameter is the time/TimeInMeshQuantum, capped by TimeInMeshCap\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  timeInMeshWeight: number\n  timeInMeshQuantum: number\n  timeInMeshCap: number\n\n  /**\n   * P2: first message deliveries\n   * This is the number of message deliveries in the topic.\n   * The value of the parameter is a counter, decaying with FirstMessageDeliveriesDecay, and capped\n   * by FirstMessageDeliveriesCap.\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  firstMessageDeliveriesWeight: number\n  firstMessageDeliveriesDecay: number\n  firstMessageDeliveriesCap: number\n\n  /**\n   * P3: mesh message deliveries\n   * This is the number of message deliveries in the mesh, within the MeshMessageDeliveriesWindow of\n   * message validation; deliveries during validation also count and are retroactively applied\n   * when validation succeeds.\n   * This window accounts for the minimum time before a hostile mesh peer trying to game the score\n   * could replay back a valid message we just sent them.\n   * It effectively tracks first and near-first deliveries, ie a message seen from a mesh peer\n   * before we have forwarded it to them.\n   * The parameter has an associated counter, decaying with MeshMessageDeliveriesDecay.\n   * If the counter exceeds the threshold, its value is 0.\n   * If the counter is below the MeshMessageDeliveriesThreshold, the value is the square of\n   * the deficit, ie (MessageDeliveriesThreshold - counter)^2\n   * The penalty is only activated after MeshMessageDeliveriesActivation time in the mesh.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  meshMessageDeliveriesWeight: number\n  meshMessageDeliveriesDecay: number\n  meshMessageDeliveriesCap: number\n  meshMessageDeliveriesThreshold: number\n  meshMessageDeliveriesWindow: number\n  meshMessageDeliveriesActivation: number\n\n  /**\n   * P3b: sticky mesh propagation failures\n   * This is a sticky penalty that applies when a peer gets pruned from the mesh with an active\n   * mesh message delivery penalty.\n   * The weight of the parameter MUST be negative (or zero to disable)\n   */\n  meshFailurePenaltyWeight: number\n  meshFailurePenaltyDecay: number\n\n  /**\n   * P4: invalid messages\n   * This is the number of invalid messages in the topic.\n   * The value of the parameter is the square of the counter, decaying with\n   * InvalidMessageDeliveriesDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  invalidMessageDeliveriesWeight: number\n  invalidMessageDeliveriesDecay: number\n}\n\nexport const defaultPeerScoreParams: PeerScoreParams = {\n  topics: {},\n  topicScoreCap: 10.0,\n  appSpecificScore: () => 0.0,\n  appSpecificWeight: 10.0,\n  IPColocationFactorWeight: -5.0,\n  IPColocationFactorThreshold: 10.0,\n  IPColocationFactorWhitelist: new Set(),\n  behaviourPenaltyWeight: -10.0,\n  behaviourPenaltyThreshold: 0.0,\n  behaviourPenaltyDecay: 0.2,\n  decayInterval: 1000.0,\n  decayToZero: 0.1,\n  retainScore: 3600 * 1000\n}\n\nexport const defaultTopicScoreParams: TopicScoreParams = {\n  topicWeight: 0.5,\n  timeInMeshWeight: 1,\n  timeInMeshQuantum: 1,\n  timeInMeshCap: 3600,\n\n  firstMessageDeliveriesWeight: 1,\n  firstMessageDeliveriesDecay: 0.5,\n  firstMessageDeliveriesCap: 2000,\n\n  meshMessageDeliveriesWeight: -1,\n  meshMessageDeliveriesDecay: 0.5,\n  meshMessageDeliveriesCap: 100,\n  meshMessageDeliveriesThreshold: 20,\n  meshMessageDeliveriesWindow: 10,\n  meshMessageDeliveriesActivation: 5000,\n\n  meshFailurePenaltyWeight: -1,\n  meshFailurePenaltyDecay: 0.5,\n\n  invalidMessageDeliveriesWeight: -1,\n  invalidMessageDeliveriesDecay: 0.3\n}\n\nexport function createPeerScoreParams (p: Partial<PeerScoreParams> = {}): PeerScoreParams {\n  return {\n    ...defaultPeerScoreParams,\n    ...p,\n    topics: (p.topics != null)\n      ? Object.entries(p.topics).reduce<Record<string, TopicScoreParams>>((topics, [topic, topicScoreParams]) => {\n        topics[topic] = createTopicScoreParams(topicScoreParams)\n        return topics\n      }, {})\n      : {}\n  }\n}\n\nexport function createTopicScoreParams (p: Partial<TopicScoreParams> = {}): TopicScoreParams {\n  return {\n    ...defaultTopicScoreParams,\n    ...p\n  }\n}\n\n// peer score parameter validation\nexport function validatePeerScoreParams (p: PeerScoreParams): void {\n  for (const [topic, params] of Object.entries(p.topics)) {\n    try {\n      validateTopicScoreParams(params)\n    } catch (e) {\n      throw new CodeError(\n        `invalid score parameters for topic ${topic}: ${(e as Error).message}`,\n        ERR_INVALID_PEER_SCORE_PARAMS\n      )\n    }\n  }\n\n  // check that the topic score is 0 or something positive\n  if (p.topicScoreCap < 0) {\n    throw new CodeError('invalid topic score cap; must be positive (or 0 for no cap)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check that we have an app specific score; the weight can be anything (but expected positive)\n  if (p.appSpecificScore === null || p.appSpecificScore === undefined) {\n    throw new CodeError('missing application specific score function', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the IP colocation factor\n  if (p.IPColocationFactorWeight > 0) {\n    throw new CodeError(\n      'invalid IPColocationFactorWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {\n    throw new CodeError('invalid IPColocationFactorThreshold; must be at least 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the behaviour penalty\n  if (p.behaviourPenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {\n    throw new CodeError('invalid BehaviourPenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the decay parameters\n  if (p.decayInterval < 1000) {\n    throw new CodeError('invalid DecayInterval; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.decayToZero <= 0 || p.decayToZero >= 1) {\n    throw new CodeError('invalid DecayToZero; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // no need to check the score retention; a value of 0 means that we don't retain scores\n}\n\n// eslint-disable-next-line complexity\nexport function validateTopicScoreParams (p: TopicScoreParams): void {\n  // make sure we have a sane topic weight\n  if (p.topicWeight < 0) {\n    throw new CodeError('invalid topic weight; must be >= 0', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P1\n  if (p.timeInMeshQuantum === 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be non zero', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight < 0) {\n    throw new CodeError('invalid TimeInMeshWeight; must be positive (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {\n    throw new CodeError('invalid TimeInMeshCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P2\n  if (p.firstMessageDeliveriesWeight < 0) {\n    throw new CodeError(\n      'invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (\n    p.firstMessageDeliveriesWeight !== 0 &&\n    (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)\n  ) {\n    throw new CodeError('invalid FirstMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid FirstMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3\n  if (p.meshMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {\n    throw new CodeError('invalid MeshMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesThreshold; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWindow < 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesWindow; must be non-negative', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {\n    throw new CodeError('invalid MeshMessageDeliveriesActivation; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3b\n  if (p.meshFailurePenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {\n    throw new CodeError('invalid MeshFailurePenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P4\n  if (p.invalidMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {\n    throw new CodeError('invalid InvalidMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { ERR_INVALID_PEER_SCORE_THRESHOLDS } from './constants.js'\n\n// This file defines PeerScoreThresholds interface\n// as well as a constructor, default constructor, and validation function\n// for this interface\n\nexport interface PeerScoreThresholds {\n  /**\n   * gossipThreshold is the score threshold below which gossip propagation is supressed;\n   * should be negative.\n   */\n  gossipThreshold: number\n\n  /**\n   * publishThreshold is the score threshold below which we shouldn't publish when using flood\n   * publishing (also applies to fanout and floodsub peers); should be negative and <= GossipThreshold.\n   */\n  publishThreshold: number\n\n  /**\n   * graylistThreshold is the score threshold below which message processing is supressed altogether,\n   * implementing an effective graylist according to peer score; should be negative and <= PublisThreshold.\n   */\n  graylistThreshold: number\n\n  /**\n   * acceptPXThreshold is the score threshold below which PX will be ignored; this should be positive\n   * and limited to scores attainable by bootstrappers and other trusted nodes.\n   */\n  acceptPXThreshold: number\n\n  /**\n   * opportunisticGraftThreshold is the median mesh score threshold before triggering opportunistic\n   * grafting; this should have a small positive value.\n   */\n  opportunisticGraftThreshold: number\n}\n\nexport const defaultPeerScoreThresholds: PeerScoreThresholds = {\n  gossipThreshold: -10,\n  publishThreshold: -50,\n  graylistThreshold: -80,\n  acceptPXThreshold: 10,\n  opportunisticGraftThreshold: 20\n}\n\nexport function createPeerScoreThresholds (p: Partial<PeerScoreThresholds> = {}): PeerScoreThresholds {\n  return {\n    ...defaultPeerScoreThresholds,\n    ...p\n  }\n}\n\nexport function validatePeerScoreThresholds (p: PeerScoreThresholds): void {\n  if (p.gossipThreshold > 0) {\n    throw new CodeError('invalid gossip threshold; it must be <= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {\n    throw new CodeError(\n      'invalid publish threshold; it must be <= 0 and <= gossip threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {\n    throw new CodeError(\n      'invalid graylist threshold; it must be <= 0 and <= publish threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.acceptPXThreshold < 0) {\n    throw new CodeError('invalid accept PX threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.opportunisticGraftThreshold < 0) {\n    throw new CodeError('invalid opportunistic grafting threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n}\n", "/**\n * Exclude up to `ineed` items from a set if item meets condition `cond`\n */\nexport function removeItemsFromSet<T> (\n  superSet: Set<T>,\n  ineed: number,\n  cond: (peer: T) => boolean = () => true\n): Set<T> {\n  const subset = new Set<T>()\n  if (ineed <= 0) return subset\n\n  for (const id of superSet) {\n    if (subset.size >= ineed) break\n    if (cond(id)) {\n      subset.add(id)\n      superSet.delete(id)\n    }\n  }\n\n  return subset\n}\n\n/**\n * Exclude up to `ineed` items from a set\n */\nexport function removeFirstNItemsFromSet<T> (superSet: Set<T>, ineed: number): Set<T> {\n  return removeItemsFromSet(superSet, ineed, () => true)\n}\n\nexport class MapDef<K, V> extends Map<K, V> {\n  constructor (private readonly getDefault: () => V) {\n    super()\n  }\n\n  getOrDefault (key: K): V {\n    let value = super.get(key)\n    if (value === undefined) {\n      value = this.getDefault()\n      this.set(key, value)\n    }\n    return value\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\nexport function computeScore (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>\n): number {\n  let score = 0\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScore = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap\n      }\n      topicScore += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += topicScore * topicParams.topicWeight\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n  }\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  score += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      score += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold\n    const p7 = excess * excess\n    score += p7 * params.behaviourPenaltyWeight\n  }\n\n  return score\n}\n", "import Denque from 'denque'\nimport { TimeCacheDuration } from '../constants.js'\n\nexport enum DeliveryRecordStatus {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  unknown,\n  /**\n   * we know the message is valid\n   */\n  valid,\n  /**\n   * we know the message is invalid\n   */\n  invalid,\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n  ignored\n}\n\nexport interface DeliveryRecord {\n  status: DeliveryRecordStatus\n  firstSeenTsMs: number\n  validated: number\n  peers: Set<string>\n}\n\ninterface DeliveryQueueEntry {\n  msgId: string\n  expire: number\n}\n\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n  private readonly records: Map<string, DeliveryRecord>\n  public queue: Denque<DeliveryQueueEntry>\n\n  constructor () {\n    this.records = new Map()\n    this.queue = new Denque()\n  }\n\n  getRecord (msgIdStr: string): DeliveryRecord | undefined {\n    return this.records.get(msgIdStr)\n  }\n\n  ensureRecord (msgIdStr: string): DeliveryRecord {\n    let drec = this.records.get(msgIdStr)\n    if (drec != null) {\n      return drec\n    }\n\n    // record doesn't exist yet\n    // create record\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeenTsMs: Date.now(),\n      validated: 0,\n      peers: new Set()\n    }\n    this.records.set(msgIdStr, drec)\n\n    // and add msgId to the queue\n    const entry: DeliveryQueueEntry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    }\n    this.queue.push(entry)\n\n    return drec\n  }\n\n  gc (): void {\n    const now = Date.now()\n    // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n    let head = this.queue.peekFront()\n    while ((head != null) && head.expire < now) {\n      this.records.delete(head.msgId)\n      this.queue.shift()\n      head = this.queue.peekFront()\n    }\n  }\n\n  clear (): void {\n    this.records.clear()\n    this.queue.clear()\n  }\n}\n", "import { type MsgIdStr, type PeerIdStr, RejectReason, type TopicStr, type IPStr } from '../types.js'\nimport { MapDef } from '../utils/set.js'\nimport { computeScore } from './compute-score.js'\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js'\nimport { type PeerScoreParams, validatePeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats, TopicStats } from './peer-stats.js'\nimport type { Metrics, ScorePenalty } from '../metrics.js'\nimport type { ComponentLogger, Logger } from '@libp2p/interface'\n\ninterface PeerScoreOpts {\n  /**\n   * Miliseconds to cache computed score per peer\n   */\n  scoreCacheValidityMs: number\n\n  computeScore?: typeof computeScore\n}\n\ninterface ScoreCacheEntry {\n  /** The cached score */\n  score: number\n  /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */\n  cacheUntil: number\n}\n\nexport type PeerScoreStatsDump = Record<PeerIdStr, PeerStats>\n\nexport class PeerScore {\n  /**\n   * Per-peer stats for score calculation\n   */\n  readonly peerStats = new Map<PeerIdStr, PeerStats>()\n  /**\n   * IP colocation tracking; maps IP => set of peers.\n   */\n  readonly peerIPs = new MapDef<PeerIdStr, Set<IPStr>>(() => new Set())\n  /**\n   * Cache score up to decayInterval if topic stats are unchanged.\n   */\n  readonly scoreCache = new Map<PeerIdStr, ScoreCacheEntry>()\n  /**\n   * Recent message delivery timing/participants\n   */\n  readonly deliveryRecords = new MessageDeliveries()\n\n  _backgroundInterval?: ReturnType<typeof setInterval>\n\n  private readonly scoreCacheValidityMs: number\n  private readonly computeScore: typeof computeScore\n  private readonly log: Logger\n\n  constructor (readonly params: PeerScoreParams, private readonly metrics: Metrics | null, componentLogger: ComponentLogger, opts: PeerScoreOpts) {\n    validatePeerScoreParams(params)\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs\n    this.computeScore = opts.computeScore ?? computeScore\n    this.log = componentLogger.forComponent('libp2p:gossipsub:score')\n  }\n\n  get size (): number {\n    return this.peerStats.size\n  }\n\n  /**\n   * Start PeerScore instance\n   */\n  start (): void {\n    if (this._backgroundInterval != null) {\n      this.log('Peer score already running')\n      return\n    }\n    this._backgroundInterval = setInterval(() => { this.background() }, this.params.decayInterval)\n    this.log('started')\n  }\n\n  /**\n   * Stop PeerScore instance\n   */\n  stop (): void {\n    if (this._backgroundInterval == null) {\n      this.log('Peer score already stopped')\n      return\n    }\n    clearInterval(this._backgroundInterval)\n    delete this._backgroundInterval\n    this.peerIPs.clear()\n    this.peerStats.clear()\n    this.deliveryRecords.clear()\n    this.log('stopped')\n  }\n\n  /**\n   * Periodic maintenance\n   */\n  background (): void {\n    this.refreshScores()\n    this.deliveryRecords.gc()\n  }\n\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]))\n  }\n\n  messageFirstSeenTimestampMs (msgIdStr: MsgIdStr): number | null {\n    const drec = this.deliveryRecords.getRecord(msgIdStr)\n    return (drec != null) ? drec.firstSeenTsMs : null\n  }\n\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n  public refreshScores (): void {\n    const now = Date.now()\n    const decayToZero = this.params.decayToZero\n\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs)\n          this.peerStats.delete(id)\n          this.scoreCache.delete(id)\n        }\n\n        // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n        return\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic]\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return\n        }\n\n        // decay counters\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0\n        }\n\n        // update mesh time and activate mesh message delivery parameter if need be\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true\n          }\n        }\n      })\n\n      // decay P7 counter\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0\n      }\n    })\n  }\n\n  /**\n   * Return the score for a peer\n   */\n  score (id: PeerIdStr): number {\n    this.metrics?.scoreFnCalls.inc()\n\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return 0\n    }\n\n    const now = Date.now()\n    const cacheEntry = this.scoreCache.get(id)\n\n    // Found cached score within validity period\n    if ((cacheEntry != null) && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score\n    }\n\n    this.metrics?.scoreFnRuns.inc()\n\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs)\n    const cacheUntil = now + this.scoreCacheValidityMs\n\n    if (cacheEntry != null) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score))\n      cacheEntry.score = score\n      cacheEntry.cacheUntil = cacheUntil\n    } else {\n      this.scoreCache.set(id, { score, cacheUntil })\n    }\n\n    return score\n  }\n\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n  addPenalty (id: PeerIdStr, penalty: number, penaltyLabel: ScorePenalty): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.behaviourPenalty += penalty\n      this.metrics?.onScorePenalty(penaltyLabel)\n    }\n  }\n\n  addPeer (id: PeerIdStr): void {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats: PeerStats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    }\n    this.peerStats.set(id, pstats)\n  }\n\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n  addIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.add(ip)\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id)\n  }\n\n  /** Remove peer association with IP */\n  removeIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.delete(ip)\n    }\n\n    const peersWithIP = this.peerIPs.get(ip)\n    if (peersWithIP != null) {\n      peersWithIP.delete(id)\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip)\n      }\n    }\n  }\n\n  removePeer (id: PeerIdStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return\n    }\n\n    // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs)\n      this.peerStats.delete(id)\n      return\n    }\n\n    // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0\n\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries\n        tstats.meshFailurePenalty += deficit * deficit\n      }\n\n      tstats.inMesh = false\n      tstats.meshMessageDeliveriesActive = false\n    })\n\n    pstats.connected = false\n    pstats.expire = Date.now() + this.params.retainScore\n  }\n\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n  graft (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true\n        tstats.graftTime = Date.now()\n        tstats.meshTime = 0\n        tstats.meshMessageDeliveriesActive = false\n      }\n    }\n  }\n\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n  prune (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries\n          tstats.meshFailurePenalty += deficit * deficit\n        }\n        tstats.meshMessageDeliveriesActive = false\n        tstats.inMesh = false\n\n        // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage (msgIdStr: MsgIdStr): void {\n    this.deliveryRecords.ensureRecord(msgIdStr)\n  }\n\n  deliverMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    this.markFirstMessageDelivery(from, topic)\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n    const now = Date.now()\n\n    // defensive check that this is the first delivery trace -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected delivery: message from %s was first seen %s ago and has delivery status %s',\n        from,\n        now - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    // mark the message as valid and reward mesh peers that have already forwarded it to us\n    drec.status = DeliveryRecordStatus.valid\n    drec.validated = now\n    drec.peers.forEach((p) => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic)\n      }\n    })\n  }\n\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n  rejectInvalidMessage (from: PeerIdStr, topic: TopicStr): void {\n    this.markInvalidMessageDelivery(from, topic)\n  }\n\n  rejectMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr, reason: RejectReason): void {\n    // eslint-disable-next-line default-case\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic)\n        return\n\n      // we ignore those messages, so do nothing.\n      case RejectReason.Blacklisted:\n        return\n\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    // defensive check that this is the first rejection -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected rejection: message from %s was first seen %s ago and has delivery status %d',\n        from,\n        Date.now() - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored\n      drec.peers.clear()\n      return\n    }\n\n    // mark the message as invalid and penalize peers that have already forwarded it.\n    drec.status = DeliveryRecordStatus.invalid\n\n    this.markInvalidMessageDelivery(from, topic)\n    drec.peers.forEach((p) => {\n      this.markInvalidMessageDelivery(p, topic)\n    })\n\n    // release the delivery time tracking map to free some memory early\n    drec.peers.clear()\n  }\n\n  duplicateMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return\n    }\n\n    // eslint-disable-next-line default-case\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from)\n        break\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from)\n        this.markDuplicateMessageDelivery(from, topic, drec.validated)\n        break\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic)\n        break\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break\n    }\n  }\n\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n  public markInvalidMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        tstats.invalidMessageDeliveries += 1\n      }\n    }\n  }\n\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n  public markFirstMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1)\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n  public markDuplicateMessageDelivery (from: PeerIdStr, topic: TopicStr, validatedTime?: number): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const now = validatedTime !== undefined ? Date.now() : 0\n\n      const tstats = this.getPtopicStats(pstats, topic)\n      // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n      if (tstats != null && tstats.inMesh) {\n        const tparams = this.params.topics[topic]\n\n        // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery)\n\n          if (isLateDelivery) {\n            return\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n      }\n    }\n  }\n\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n  private removeIPsForPeer (id: PeerIdStr, ipsToRemove: Set<IPStr>): void {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove)\n      if (peerSet != null) {\n        peerSet.delete(id)\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n  private getPtopicStats (pstats: PeerStats, topic: TopicStr): TopicStats | null {\n    let topicStats: TopicStats | undefined = pstats.topics[topic]\n\n    if (topicStats !== undefined) {\n      return topicStats\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      }\n      pstats.topics[topic] = topicStats\n\n      return topicStats\n    }\n\n    return null\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\ntype TopicLabel = string\ntype TopicStr = string\ntype TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport interface TopicScoreWeights<T> {\n  p1w: T\n  p2w: T\n  p3w: T\n  p3bw: T\n  p4w: T\n}\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport function computeScoreWeights (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number> {\n  let score = 0\n\n  const byTopic = new Map<TopicLabel, TopicScoreWeights<number>>()\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown'\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScores = byTopic.get(topicLabel)\n    if (topicScores == null) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      }\n      byTopic.set(topicLabel, topicScores)\n    }\n\n    let p1w = 0\n    let p2w = 0\n    let p3w = 0\n    let p3bw = 0\n    let p4w = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap)\n      p1w += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight\n\n    topicScores.p1w += p1w\n    topicScores.p2w += p2w\n    topicScores.p3w += p3w\n    topicScores.p3bw += p3bw\n    topicScores.p4w += p4w\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n\n    // Proportionally apply cap to all individual contributions\n    const capF = params.topicScoreCap / score\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF\n      ws.p2w *= capF\n      ws.p3w *= capF\n      ws.p3bw *= capF\n      ws.p4w *= capF\n    }\n  }\n\n  let p5w = 0\n  let p6w = 0\n  let p7w = 0\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  p5w += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      p6w += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty\n  p7w += p7 * params.behaviourPenaltyWeight\n\n  score += p5w + p6w + p7w\n\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  }\n}\n\nexport function computeAllPeersScoreWeights (\n  peerIdStrs: Iterable<string>,\n  peerStats: Map<string, PeerStats>,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number[]> {\n  const sw: ScoreWeights<number[]> = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  }\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr)\n    if (pstats != null) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel)\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic)\n        if (swTopic == null) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          }\n          sw.byTopic.set(topic, swTopic)\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w)\n        swTopic.p2w.push(swPeerTopic.p2w)\n        swTopic.p3w.push(swPeerTopic.p3w)\n        swTopic.p3bw.push(swPeerTopic.p3bw)\n        swTopic.p4w.push(swPeerTopic.p4w)\n      }\n\n      sw.p5w.push(swPeer.p5w)\n      sw.p6w.push(swPeer.p6w)\n      sw.p7w.push(swPeer.p7w)\n      sw.score.push(swPeer.score)\n    } else {\n      sw.p5w.push(0)\n      sw.p6w.push(0)\n      sw.p7w.push(0)\n      sw.score.push(0)\n    }\n  }\n\n  return sw\n}\n", "import { encode, decode } from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { pushable, type Pushable } from 'it-pushable'\nimport type { Stream } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ninterface OutboundStreamOpts {\n  /** Max size in bytes for pushable buffer. If full, will throw on .push */\n  maxBufferSize?: number\n}\n\ninterface InboundStreamOpts {\n  /** Max size in bytes for reading messages from the stream */\n  maxDataLength?: number\n}\n\nexport class OutboundStream {\n  private readonly pushable: Pushable<Uint8Array | Uint8ArrayList>\n  private readonly closeController: AbortController\n  private readonly maxBufferSize: number\n\n  constructor (private readonly rawStream: Stream, errCallback: (e: Error) => void, opts: OutboundStreamOpts) {\n    this.pushable = pushable()\n    this.closeController = new AbortController()\n    this.maxBufferSize = opts.maxBufferSize ?? Infinity\n\n    this.closeController.signal.addEventListener('abort', () => {\n      rawStream.close()\n        .catch(err => {\n          rawStream.abort(err)\n        })\n    })\n\n    pipe(\n      this.pushable,\n      this.rawStream\n    ).catch(errCallback)\n  }\n\n  get protocol (): string {\n    // TODO remove this non-nullish assertion after https://github.com/libp2p/js-libp2p-interfaces/pull/265 is incorporated\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.rawStream.protocol!\n  }\n\n  push (data: Uint8Array): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n\n    this.pushable.push(encode.single(data))\n  }\n\n  /**\n   * Same to push() but this is prefixed data so no need to encode length prefixed again\n   */\n  pushPrefixed (data: Uint8ArrayList): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n    this.pushable.push(data)\n  }\n\n  async close (): Promise<void> {\n    this.closeController.abort()\n    // similar to pushable.end() but clear the internal buffer\n    await this.pushable.return()\n  }\n}\n\nexport class InboundStream {\n  public readonly source: AsyncIterable<Uint8ArrayList>\n\n  private readonly rawStream: Stream\n  private readonly closeController: AbortController\n\n  constructor (rawStream: Stream, opts: InboundStreamOpts = {}) {\n    this.rawStream = rawStream\n    this.closeController = new AbortController()\n\n    this.closeController.signal.addEventListener('abort', () => {\n      rawStream.close()\n        .catch(err => {\n          rawStream.abort(err)\n        })\n    })\n\n    this.source = pipe(\n      this.rawStream,\n      (source) => decode(source, opts)\n    )\n  }\n\n  async close (): Promise<void> {\n    this.closeController.abort()\n  }\n}\n", "import { type MsgIdStr, type MsgIdToStrFn, type PeerIdStr, RejectReason } from './types.js'\nimport type { Metrics } from './metrics.js'\n\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  /**\n   * Promises to deliver a message\n   * Map per message id, per peer, promise expiration time\n   */\n  private readonly promises = new Map<MsgIdStr, Map<PeerIdStr, number>>()\n  /**\n   * First request time by msgId. Used for metrics to track expire times.\n   * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n   */\n  private readonly requestMsByMsg = new Map<MsgIdStr, number>()\n  private readonly requestMsByMsgExpire: number\n\n  constructor (\n    private readonly gossipsubIWantFollowupMs: number,\n    private readonly msgIdToStrFn: MsgIdToStrFn,\n    private readonly metrics: Metrics | null\n  ) {\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs\n  }\n\n  get size (): number {\n    return this.promises.size\n  }\n\n  get requestMsByMsgSize (): number {\n    return this.requestMsByMsg.size\n  }\n\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise (from: PeerIdStr, msgIds: Uint8Array[]): void {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length)\n    const msgId = msgIds[ix]\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    let expireByPeer = this.promises.get(msgIdStr)\n    if (expireByPeer == null) {\n      expireByPeer = new Map()\n      this.promises.set(msgIdStr, expireByPeer)\n    }\n\n    const now = Date.now()\n\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseStarted.inc(1)\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises (): Map<PeerIdStr, number> {\n    const now = Date.now()\n    const result = new Map<PeerIdStr, number>()\n\n    let brokenPromises = 0\n\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1)\n          // delete from tracked promises\n          expireByPeer.delete(p)\n          // for metrics\n          brokenPromises++\n        }\n      })\n      // clean up empty promises for a msgId\n      if (expireByPeer.size === 0) {\n        this.promises.delete(msgId)\n      }\n    })\n\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises)\n\n    return result\n  }\n\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage (msgIdStr: MsgIdStr, isDuplicate = false): void {\n    this.trackMessage(msgIdStr)\n\n    const expireByPeer = this.promises.get(msgIdStr)\n\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer != null) {\n      this.promises.delete(msgIdStr)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseResolved.inc(1)\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1)\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size)\n      }\n    }\n  }\n\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage (msgIdStr: MsgIdStr, reason: RejectReason): void {\n    this.trackMessage(msgIdStr)\n\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return\n      default:\n        break\n    }\n\n    this.promises.delete(msgIdStr)\n  }\n\n  clear (): void {\n    this.promises.clear()\n  }\n\n  prune (): void {\n    const maxMs = Date.now() - this.requestMsByMsgExpire\n    let count = 0\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k)\n        count++\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count)\n  }\n\n  private trackMessage (msgIdStr: MsgIdStr): void {\n    if (this.metrics != null) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr)\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000)\n        this.requestMsByMsg.delete(msgIdStr)\n      }\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign, type Message, type PublicKey, type PeerId } from '@libp2p/interface'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RPC } from '../message/rpc.js'\nimport { type PublishConfig, PublishConfigType, type TopicStr, ValidateError } from '../types.js'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\nexport interface RawMessageAndMessage {\n  raw: RPC.Message\n  msg: Message\n}\n\nexport async function buildRawMessage (\n  publishConfig: PublishConfig,\n  topic: TopicStr,\n  originalData: Uint8Array,\n  transformedData: Uint8Array\n): Promise<RawMessageAndMessage> {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing: {\n      const rpcMsg: RPC.Message = {\n        from: publishConfig.author.toBytes(),\n        data: transformedData,\n        seqno: randomBytes(8),\n        topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg)])\n\n      rpcMsg.signature = await publishConfig.privateKey.sign(bytes)\n      rpcMsg.key = publishConfig.key\n\n      const msg: Message = {\n        type: 'signed',\n        from: publishConfig.author,\n        data: originalData,\n        sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno as Uint8Array, 'base16')}`),\n        topic,\n        signature: rpcMsg.signature,\n        key: rpcMsg.key\n      }\n      return {\n        raw: rpcMsg,\n        msg\n      }\n    }\n\n    case PublishConfigType.Anonymous: {\n      return {\n        raw: {\n          from: undefined,\n          data: transformedData,\n          seqno: undefined,\n          topic,\n          signature: undefined,\n          key: undefined\n        },\n        msg: {\n          type: 'unsigned',\n          data: originalData,\n          topic\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n\nexport type ValidationResult = { valid: true, message: Message } | { valid: false, error: ValidateError }\n\nexport async function validateToRawMessage (\n  signaturePolicy: typeof StrictNoSign | typeof StrictSign,\n  msg: RPC.Message\n): Promise<ValidationResult> {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) return { valid: false, error: ValidateError.SignaturePresent }\n      if (msg.seqno != null) return { valid: false, error: ValidateError.SeqnoPresent }\n      if (msg.key != null) return { valid: false, error: ValidateError.FromPresent }\n\n      return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } }\n\n    case StrictSign: {\n      // Verify seqno\n      if (msg.seqno == null) return { valid: false, error: ValidateError.InvalidSeqno }\n      if (msg.seqno.length !== 8) {\n        return { valid: false, error: ValidateError.InvalidSeqno }\n      }\n\n      if (msg.signature == null) return { valid: false, error: ValidateError.InvalidSignature }\n      if (msg.from == null) return { valid: false, error: ValidateError.InvalidPeerId }\n\n      let fromPeerId: PeerId\n      try {\n        // TODO: Fix PeerId types\n        fromPeerId = peerIdFromBytes(msg.from)\n      } catch (e) {\n        return { valid: false, error: ValidateError.InvalidPeerId }\n      }\n\n      // - check from defined\n      // - transform source to PeerId\n      // - parse signature\n      // - get .key, else from source\n      // - check key == source if present\n      // - verify sig\n\n      let publicKey: PublicKey\n      if (msg.key != null) {\n        publicKey = unmarshalPublicKey(msg.key)\n        // TODO: Should `fromPeerId.pubKey` be optional?\n        if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n      } else {\n        if (fromPeerId.publicKey == null) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n        publicKey = unmarshalPublicKey(fromPeerId.publicKey)\n      }\n\n      const rpcMsgPreSign: RPC.Message = {\n        from: msg.from,\n        data: msg.data,\n        seqno: msg.seqno,\n        topic: msg.topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign)])\n\n      if (!(await publicKey.verify(bytes, msg.signature))) {\n        return { valid: false, error: ValidateError.InvalidSignature }\n      }\n\n      return {\n        valid: true,\n        message: {\n          type: 'signed',\n          from: fromPeerId,\n          data: msg.data ?? new Uint8Array(0),\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n          topic: msg.topic,\n          signature: msg.signature,\n          key: msg.key ?? marshalPublicKey(publicKey)\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "import type { RPC } from '../message/rpc.js'\n\n/**\n * Create a gossipsub RPC object\n */\nexport function createGossipRpc (messages: RPC.Message[] = [], control?: Partial<RPC.ControlMessage>): RPC {\n  return {\n    subscriptions: [],\n    messages,\n    control: control !== undefined\n      ? {\n          graft: control.graft ?? [],\n          prune: control.prune ?? [],\n          ihave: control.ihave ?? [],\n          iwant: control.iwant ?? []\n        }\n      : undefined\n  }\n}\n\nexport function ensureControl (rpc: RPC): Required<RPC> {\n  if (rpc.control === undefined) {\n    rpc.control = {\n      graft: [],\n      prune: [],\n      ihave: [],\n      iwant: []\n    }\n  }\n\n  return rpc as Required<RPC>\n}\n", "/**\n * Pseudo-randomly shuffles an array\n *\n * Mutates the input array\n */\nexport function shuffle<T> (arr: T[]): T[] {\n  if (arr.length <= 1) {\n    return arr\n  }\n  const randInt = (): number => {\n    return Math.floor(Math.random() * Math.floor(arr.length))\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const j = randInt()\n    const tmp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = tmp\n  }\n  return arr\n}\n", "import { toString } from 'uint8arrays/to-string'\n\n/**\n * Browser friendly function to convert Uint8Array message id to base64 string.\n */\nexport function messageIdToString (msgId: Uint8Array): string {\n  return toString(msgId, 'base64')\n}\n", "import { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign } from '@libp2p/interface'\nimport { type PublishConfig, PublishConfigType } from '../types.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\nexport async function getPublishConfigFromPeerId (\n  signaturePolicy: typeof StrictSign | typeof StrictNoSign,\n  peerId?: PeerId\n): Promise<PublishConfig> {\n  switch (signaturePolicy) {\n    case StrictSign: {\n      if (peerId == null) {\n        throw Error('Must provide PeerId')\n      }\n\n      if (peerId.privateKey == null) {\n        throw Error('Cannot sign message, no private key present')\n      }\n\n      if (peerId.publicKey == null) {\n        throw Error('Cannot sign message, no public key present')\n      }\n\n      // Transform privateKey once at initialization time instead of once per message\n      const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n      return {\n        type: PublishConfigType.Signing,\n        author: peerId,\n        key: peerId.publicKey,\n        privateKey\n      }\n    }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      }\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`)\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { CodeError } from '@libp2p/interface'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { codes } from './errors.js'\nimport type { Message, PubSubRPCMessage } from '@libp2p/interface'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: Uint8Array, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n\n  const msgId = new Uint8Array(key.length + seqnoBytes.length)\n  msgId.set(key, 0)\n  msgId.set(seqnoBytes, key.length)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array\n */\nexport const ensureArray = function <T> (maybeArray: T | T[]): T[] {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromBytes(message.from)\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingID = await peerIdFromKeys(message.key)\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new CodeError('RPC message was missing from', codes.ERR_MISSING_FROM)\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromBytes(message.from)\n\n  const msg: Message = {\n    type: 'signed',\n    from: peerIdFromBytes(message.from),\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: message.key ?? from.publicKey ?? new Uint8Array(0)\n  }\n\n  if (msg.key.length === 0) {\n    throw new CodeError('Signed RPC message was missing key', codes.ERR_MISSING_KEY)\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.multihash.bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n      key: message.key\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n", "import { msgId } from '@libp2p/pubsub/utils'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { Message } from '@libp2p/interface'\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport function msgIdFnStrictSign (msg: Message): Uint8Array {\n  if (msg.type !== 'signed') {\n    throw new Error('expected signed message type')\n  }\n  // Should never happen\n  if (msg.sequenceNumber == null) throw Error('missing seqno field')\n\n  // TODO: Should use .from here or key?\n  return msgId(msg.from.toBytes(), msg.sequenceNumber)\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport async function msgIdFnStrictNoSign (msg: Message): Promise<Uint8Array> {\n  return sha256.encode(msg.data)\n}\n", "import { convertToString } from '@multiformats/multiaddr/convert'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n// Protocols https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n// code  size  name\n// 4     32    ip4\n// 41    128   ip6\nenum Protocol {\n  ip4 = 4,\n  ip6 = 41\n}\n\nexport function multiaddrToIPStr (multiaddr: Multiaddr): string | null {\n  for (const tuple of multiaddr.tuples()) {\n    switch (tuple[0]) {\n      case Protocol.ip4:\n      case Protocol.ip6:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return convertToString(tuple[0], tuple[1]!)\n      default:\n        break\n    }\n  }\n\n  return null\n}\n", "interface SimpleTimeCacheOpts {\n  validityMs: number\n}\n\ninterface CacheValue<T> {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private readonly entries = new Map<string | number, CacheValue<T>>()\n  private readonly validityMs: number\n\n  constructor (opts: SimpleTimeCacheOpts) {\n    this.validityMs = opts.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size (): number {\n    return this.entries.size\n  }\n\n  /** Returns true if there was a key collision and the entry is dropped */\n  put (key: string | number, value: T): boolean {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true\n    }\n\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    return false\n  }\n\n  prune (): void {\n    const now = Date.now()\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break\n      }\n    }\n  }\n\n  has (key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get (key: string | number): T | undefined {\n    const value = this.entries.get(key)\n    return (value != null) && value.validUntilMs >= Date.now() ? value.value : undefined\n  }\n\n  clear (): void {\n    this.entries.clear()\n  }\n}\n", "import { TypedEventEmitter, StrictSign, StrictNoSign, TopicValidatorResult, serviceCapabilities, serviceDependencies } from '@libp2p/interface'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { encode } from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as constants from './constants.js'\nimport {\n  ACCEPT_FROM_WHITELIST_DURATION_MS,\n  ACCEPT_FROM_WHITELIST_MAX_MESSAGES,\n  ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE,\n  BACKOFF_SLACK\n} from './constants.js'\nimport { type DecodeRPCLimits, defaultDecodeRpcLimits } from './message/decodeRpc.js'\nimport { RPC } from './message/rpc.js'\nimport { MessageCache, type MessageCacheRecord } from './message-cache.js'\nimport {\n  ChurnReason,\n  getMetrics,\n  IHaveIgnoreReason,\n  InclusionReason,\n  type Metrics,\n  type MetricsRegister,\n  ScorePenalty,\n  type TopicStrToLabel,\n  type ToSendGroupCount\n} from './metrics.js'\nimport {\n  PeerScore,\n  type PeerScoreParams,\n  type PeerScoreThresholds,\n  createPeerScoreParams,\n  createPeerScoreThresholds,\n  type PeerScoreStatsDump\n} from './score/index.js'\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js'\nimport { InboundStream, OutboundStream } from './stream.js'\nimport { IWantTracer } from './tracer.js'\nimport {\n  type MsgIdFn,\n  type PublishConfig,\n  type TopicStr,\n  type MsgIdStr,\n  ValidateError,\n  type PeerIdStr,\n  MessageStatus,\n  RejectReason,\n  type RejectReasonObj,\n  type FastMsgIdFn,\n  type AddrInfo,\n  type DataTransform,\n  rejectReasonFromAcceptance,\n  type MsgIdToStrFn,\n  type MessageId,\n  type PublishOpts\n} from './types.js'\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js'\nimport { createGossipRpc, ensureControl } from './utils/create-gossip-rpc.js'\nimport { shuffle, messageIdToString } from './utils/index.js'\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js'\nimport { multiaddrToIPStr } from './utils/multiaddr.js'\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js'\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js'\nimport { SimpleTimeCache } from './utils/time-cache.js'\nimport type { GossipsubOptsSpec } from './config.js'\nimport type {\n  Connection, Direction, Stream, PeerId, Peer, PeerStore,\n  Message,\n  PublishResult,\n  PubSub,\n  PubSubEvents,\n  PubSubInit,\n  SubscriptionChangeData,\n  TopicValidatorFn,\n  Logger,\n  ComponentLogger,\n  Topology\n} from '@libp2p/interface'\nimport type { ConnectionManager, IncomingStreamData, Registrar } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ntype ConnectionDirection = 'inbound' | 'outbound'\n\ntype ReceivedMessageResult =\n  | { code: MessageStatus.duplicate, msgIdStr: MsgIdStr }\n  | ({ code: MessageStatus.invalid, msgIdStr?: MsgIdStr } & RejectReasonObj)\n  | { code: MessageStatus.valid, messageId: MessageId, msg: Message }\n\nexport const multicodec: string = constants.GossipsubIDv11\n\nexport interface GossipsubOpts extends GossipsubOptsSpec, PubSubInit {\n  /** if dial should fallback to floodsub */\n  fallbackToFloodsub: boolean\n  /** if self-published messages should be sent to all peers */\n  floodPublish: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish: boolean\n  /** whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. */\n  doPX: boolean\n  /** peers with which we will maintain direct connections */\n  directPeers: AddrInfo[]\n  /**\n   * If true will not forward messages to mesh peers until reportMessageValidationResult() is called.\n   * Messages will be cached in mcache for some time after which they are evicted. Calling\n   * reportMessageValidationResult() after the message is dropped from mcache won't forward the message.\n   */\n  asyncValidation: boolean\n  /**\n   * Do not throw `PublishError.NoPeersSubscribedToTopic` error if there are no\n   * peers listening on the topic.\n   *\n   * N.B. if you sent this option to true, and you publish a message on a topic\n   * with no peers listening on that topic, no other network node will ever\n   * receive the message.\n   */\n  allowPublishToZeroTopicPeers: boolean\n  /** Do not throw `PublishError.Duplicate` if publishing duplicate messages */\n  ignoreDuplicatePublishError: boolean\n  /** For a single stream, await processing each RPC before processing the next */\n  awaitRpcHandler: boolean\n  /** For a single RPC, await processing each message before processing the next */\n  awaitRpcMessageHandler: boolean\n\n  /** message id function */\n  msgIdFn: MsgIdFn\n  /** fast message id function */\n  fastMsgIdFn: FastMsgIdFn\n  /** Uint8Array message id to string function */\n  msgIdToStrFn: MsgIdToStrFn\n  /** override the default MessageCache */\n  messageCache: MessageCache\n  /** peer score parameters */\n  scoreParams: Partial<PeerScoreParams>\n  /** peer score thresholds */\n  scoreThresholds: Partial<PeerScoreThresholds>\n  /** customize GossipsubIWantFollowupTime in order not to apply IWANT penalties */\n  gossipsubIWantFollowupMs: number\n\n  /** override constants for fine tuning */\n  prunePeers?: number\n  pruneBackoff?: number\n  unsubcribeBackoff?: number\n  graftFloodThreshold?: number\n  opportunisticGraftPeers?: number\n  opportunisticGraftTicks?: number\n  directConnectTicks?: number\n\n  dataTransform?: DataTransform\n  metricsRegister?: MetricsRegister | null\n  metricsTopicStrToLabel?: TopicStrToLabel\n\n  // Debug\n  /** Prefix tag for debug logs */\n  debugName?: string\n\n  /**\n   * Specify the maximum number of inbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxInboundStreams?: number\n\n  /**\n   * Specify the maximum number of outbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Pass true to run on transient connections - data or time-limited\n   * connections that may be closed at any time such as circuit relay\n   * connections.\n   *\n   * @default false\n   */\n  runOnTransientConnection?: boolean\n\n  /**\n   * Specify max buffer size in bytes for OutboundStream.\n   * If full it will throw and reject sending any more data.\n   */\n  maxOutboundBufferSize?: number\n\n  /**\n   * Specify max size to skip decoding messages whose data\n   * section exceeds this size.\n   *\n   */\n  maxInboundDataLength?: number\n\n  /**\n   * If provided, only allow topics in this list\n   */\n  allowedTopics?: string[] | Set<string>\n\n  /**\n   * Limits to bound protobuf decoding\n   */\n  decodeRpcLimits?: DecodeRPCLimits\n\n  /**\n   * If true, will utilize the libp2p connection manager tagging system to prune/graft connections to peers, defaults to true\n   */\n  tagMeshPeers: boolean\n}\n\nexport interface GossipsubMessage {\n  propagationSource: PeerId\n  msgId: MsgIdStr\n  msg: Message\n}\n\nexport interface MeshPeer {\n  peerId: string\n  topic: string\n  direction: Direction\n}\n\nexport interface GossipsubEvents extends PubSubEvents {\n  'gossipsub:heartbeat': CustomEvent\n  'gossipsub:message': CustomEvent<GossipsubMessage>\n  'gossipsub:graft': CustomEvent<MeshPeer>\n  'gossipsub:prune': CustomEvent<MeshPeer>\n}\n\nenum GossipStatusCode {\n  started,\n  stopped\n}\n\ntype GossipStatus =\n  | {\n    code: GossipStatusCode.started\n    registrarTopologyIds: string[]\n    heartbeatTimeout: ReturnType<typeof setTimeout>\n    hearbeatStartMs: number\n  }\n  | {\n    code: GossipStatusCode.stopped\n  }\n\ninterface GossipOptions extends GossipsubOpts {\n  scoreParams: PeerScoreParams\n  scoreThresholds: PeerScoreThresholds\n}\n\ninterface AcceptFromWhitelistEntry {\n  /** number of messages accepted since recomputing the peer's score */\n  messagesAccepted: number\n  /** have to recompute score after this time */\n  acceptUntil: number\n}\n\nexport interface GossipSubComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  logger: ComponentLogger\n}\n\nexport class GossipSub extends TypedEventEmitter<GossipsubEvents> implements PubSub<GossipsubEvents> {\n  /**\n   * The signature policy to follow by default\n   */\n  public readonly globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n  public multicodecs: string[] = [constants.GossipsubIDv11, constants.GossipsubIDv10]\n\n  private publishConfig: PublishConfig | undefined\n\n  private readonly dataTransform: DataTransform | undefined\n\n  // State\n\n  public readonly peers = new Set<PeerIdStr>()\n  public readonly streamsInbound = new Map<PeerIdStr, InboundStream>()\n  public readonly streamsOutbound = new Map<PeerIdStr, OutboundStream>()\n\n  /** Ensures outbound streams are created sequentially */\n  private outboundInflightQueue = pushable<{ peerId: PeerId, connection: Connection }>({ objectMode: true })\n\n  /** Direct peers */\n  public readonly direct = new Set<PeerIdStr>()\n\n  /** Floodsub peers */\n  private readonly floodsubPeers = new Set<PeerIdStr>()\n\n  /** Cache of seen messages */\n  private readonly seenCache: SimpleTimeCache<void>\n\n  /**\n   * Map of peer id and AcceptRequestWhileListEntry\n   */\n  private readonly acceptFromWhitelist = new Map<PeerIdStr, AcceptFromWhitelistEntry>()\n\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  private readonly topics = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * List of our subscriptions\n   */\n  private readonly subscriptions = new Set<TopicStr>()\n\n  /**\n   * Map of topic meshes\n   * topic => peer id set\n   */\n  public readonly mesh = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n   * topic => peer id set\n   */\n  public readonly fanout = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of last publish time for fanout topics\n   * topic => last publish time\n   */\n  private readonly fanoutLastpub = new Map<TopicStr, number>()\n\n  /**\n   * Map of pending messages to gossip\n   * peer id => control messages\n   */\n  public readonly gossip = new Map<PeerIdStr, RPC.ControlIHave[]>()\n\n  /**\n   * Map of control messages\n   * peer id => control message\n   */\n  public readonly control = new Map<PeerIdStr, RPC.ControlMessage>()\n\n  /**\n   * Number of IHAVEs received from peer in the last heartbeat\n   */\n  private readonly peerhave = new Map<PeerIdStr, number>()\n\n  /** Number of messages we have asked from peer in the last heartbeat */\n  private readonly iasked = new Map<PeerIdStr, number>()\n\n  /** Prune backoff map */\n  private readonly backoff = new Map<TopicStr, Map<PeerIdStr, number>>()\n\n  /**\n   * Connection direction cache, marks peers with outbound connections\n   * peer id => direction\n   */\n  private readonly outbound = new Map<PeerIdStr, boolean>()\n  private readonly msgIdFn: MsgIdFn\n\n  /**\n   * A fast message id function used for internal message de-duplication\n   */\n  private readonly fastMsgIdFn: FastMsgIdFn | undefined\n\n  private readonly msgIdToStrFn: MsgIdToStrFn\n\n  /** Maps fast message-id to canonical message-id */\n  private readonly fastMsgIdCache: SimpleTimeCache<MsgIdStr> | undefined\n\n  /**\n   * Short term cache for published message ids. This is used for penalizing peers sending\n   * our own messages back if the messages are anonymous or use a random author.\n   */\n  private readonly publishedMessageIds: SimpleTimeCache<void>\n\n  /**\n   * A message cache that contains the messages for last few heartbeat ticks\n   */\n  private readonly mcache: MessageCache\n\n  /** Peer score tracking */\n  public readonly score: PeerScore\n\n  /**\n   * Custom validator function per topic.\n   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n   * validation result through `Gossipsub.reportValidationResult`\n   */\n  public readonly topicValidators = new Map<TopicStr, TopicValidatorFn>()\n\n  /**\n   * Make this protected so child class may want to redirect to its own log.\n   */\n  protected readonly log: Logger\n\n  /**\n   * Number of heartbeats since the beginning of time\n   * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n   */\n  private heartbeatTicks = 0\n\n  /**\n   * Tracks IHAVE/IWANT promises broken by peers\n   */\n  readonly gossipTracer: IWantTracer\n\n  private readonly components: GossipSubComponents\n\n  private directPeerInitial: ReturnType<typeof setTimeout> | null = null\n\n  public static multicodec: string = constants.GossipsubIDv11\n\n  // Options\n  readonly opts: Required<GossipOptions>\n  private readonly decodeRpcLimits: DecodeRPCLimits\n\n  private readonly metrics: Metrics | null\n  private status: GossipStatus = { code: GossipStatusCode.stopped }\n  private readonly maxInboundStreams?: number\n  private readonly maxOutboundStreams?: number\n  private readonly runOnTransientConnection?: boolean\n  private readonly allowedTopics: Set<TopicStr> | null\n\n  private heartbeatTimer: {\n    _intervalId: ReturnType<typeof setInterval> | undefined\n    runPeriodically(fn: () => void, period: number): void\n    cancel(): void\n  } | null = null\n\n  constructor (components: GossipSubComponents, options: Partial<GossipsubOpts> = {}) {\n    super()\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      batchPublish: false,\n      tagMeshPeers: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      unsubcribeBackoff: constants.GossipsubUnsubscribeBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    }\n\n    this.components = components\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits\n\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign\n\n    // Also wants to get notified of peers connected using floodsub\n    if (opts.fallbackToFloodsub) {\n      this.multicodecs.push(constants.FloodsubID)\n    }\n\n    // From pubsub\n    this.log = components.logger.forComponent(opts.debugName ?? 'libp2p:gossipsub')\n\n    // Gossipsub\n\n    this.opts = opts as Required<GossipOptions>\n    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()))\n    this.seenCache = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n    this.publishedMessageIds = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n\n    if (options.msgIdFn != null) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign\n          break\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign\n          break\n        default:\n          throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)\n      }\n    }\n\n    if (options.fastMsgIdFn != null) {\n      this.fastMsgIdFn = options.fastMsgIdFn\n      this.fastMsgIdCache = new SimpleTimeCache<MsgIdStr>({ validityMs: opts.seenTTL })\n    }\n\n    // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString\n\n    this.mcache = options.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn)\n\n    if (options.dataTransform != null) {\n      this.dataTransform = options.dataTransform\n    }\n\n    if (options.metricsRegister != null) {\n      if (options.metricsTopicStrToLabel == null) {\n        throw Error('Must set metricsTopicStrToLabel with metrics')\n      }\n\n      // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n      const maxMeshMessageDeliveriesWindowMs = Math.max(\n        ...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow),\n        constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS\n      )\n\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      })\n\n      metrics.mcacheSize.addCollect(() => { this.onScrapeMetrics(metrics) })\n      for (const protocol of this.multicodecs) {\n        metrics.protocolsEnabled.set({ protocol }, 1)\n      }\n\n      this.metrics = metrics\n    } else {\n      this.metrics = null\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics)\n\n    /**\n     * libp2p\n     */\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    })\n\n    this.maxInboundStreams = options.maxInboundStreams\n    this.maxOutboundStreams = options.maxOutboundStreams\n    this.runOnTransientConnection = options.runOnTransientConnection\n\n    this.allowedTopics = (opts.allowedTopics != null) ? new Set(opts.allowedTopics) : null\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-gossipsub'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/pubsub'\n  ]\n\n  readonly [serviceDependencies]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  getPeers (): PeerId[] {\n    return [...this.peers.keys()].map((str) => peerIdFromString(str))\n  }\n\n  isStarted (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n  async start (): Promise<void> {\n    // From pubsub\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('starting')\n\n    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId)\n\n    // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n    this.outboundInflightQueue = pushable({ objectMode: true })\n    pipe(this.outboundInflightQueue, async (source) => {\n      for await (const { peerId, connection } of source) {\n        await this.createOutboundStream(peerId, connection)\n      }\n    }).catch((e) => { this.log.error('outbound inflight queue error', e) })\n\n    // set direct peer addresses in the address book\n    await Promise.all(\n      this.opts.directPeers.map(async (p) => {\n        await this.components.peerStore.merge(p.id, {\n          multiaddrs: p.addrs\n        })\n      })\n    )\n\n    const registrar = this.components.registrar\n    // Incoming streams\n    // Called after a peer dials us\n    await Promise.all(\n      this.multicodecs.map(async (multicodec) =>\n        registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n          maxInboundStreams: this.maxInboundStreams,\n          maxOutboundStreams: this.maxOutboundStreams,\n          runOnTransientConnection: this.runOnTransientConnection\n        })\n      )\n    )\n\n    // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology: Topology = {\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this),\n      notifyOnTransient: this.runOnTransientConnection\n    }\n    const registrarTopologyIds = await Promise.all(\n      this.multicodecs.map(async (multicodec) => registrar.register(multicodec, topology))\n    )\n\n    // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay)\n    // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    }\n\n    this.score.start()\n    // connect to direct peers\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve()\n        .then(async () => {\n          await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)))\n        })\n        .catch((err) => {\n          this.log(err)\n        })\n    }, constants.GossipsubDirectConnectInitialDelay)\n\n    if (this.opts.tagMeshPeers) {\n      this.addEventListener('gossipsub:graft', this.tagMeshPeer)\n      this.addEventListener('gossipsub:prune', this.untagMeshPeer)\n    }\n\n    this.log('started')\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n  async stop (): Promise<void> {\n    this.log('stopping')\n    // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return\n    }\n\n    const { registrarTopologyIds } = this.status\n    this.status = { code: GossipStatusCode.stopped }\n\n    if (this.opts.tagMeshPeers) {\n      this.removeEventListener('gossipsub:graft', this.tagMeshPeer)\n      this.removeEventListener('gossipsub:prune', this.untagMeshPeer)\n    }\n\n    // unregister protocol and handlers\n    const registrar = this.components.registrar\n    await Promise.all(this.multicodecs.map(async (multicodec) => registrar.unhandle(multicodec)))\n    registrarTopologyIds.forEach((id) => { registrar.unregister(id) })\n\n    this.outboundInflightQueue.end()\n\n    const closePromises = []\n    for (const outboundStream of this.streamsOutbound.values()) {\n      closePromises.push(outboundStream.close())\n    }\n    this.streamsOutbound.clear()\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      closePromises.push(inboundStream.close())\n    }\n    this.streamsInbound.clear()\n\n    await Promise.all(closePromises)\n\n    this.peers.clear()\n    this.subscriptions.clear()\n\n    // Gossipsub\n\n    if (this.heartbeatTimer != null) {\n      this.heartbeatTimer.cancel()\n      this.heartbeatTimer = null\n    }\n\n    this.score.stop()\n\n    this.mesh.clear()\n    this.fanout.clear()\n    this.fanoutLastpub.clear()\n    this.gossip.clear()\n    this.control.clear()\n    this.peerhave.clear()\n    this.iasked.clear()\n    this.backoff.clear()\n    this.outbound.clear()\n    this.gossipTracer.clear()\n    this.seenCache.clear()\n    if (this.fastMsgIdCache != null) this.fastMsgIdCache.clear()\n    if (this.directPeerInitial != null) clearTimeout(this.directPeerInitial)\n\n    this.log('stopped')\n  }\n\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return this.score.dumpPeerScoreStats()\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  private onIncomingStream ({ stream, connection }: IncomingStreamData): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const peerId = connection.remotePeer\n    // add peer to router\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    // create inbound stream\n    this.createInboundStream(peerId, stream)\n    // attempt to create outbound stream\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  private onPeerConnected (peerId: PeerId, connection: Connection): void {\n    this.metrics?.newConnectionCount.inc({ status: connection.status })\n    // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n    if (!this.isStarted() || connection.status !== 'open') {\n      return\n    }\n\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  private onPeerDisconnected (peerId: PeerId): void {\n    this.log('connection ended %p', peerId)\n    this.removePeer(peerId)\n  }\n\n  private async createOutboundStream (peerId: PeerId, connection: Connection): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n    if (this.streamsOutbound.has(id)) {\n      return\n    }\n\n    try {\n      const stream = new OutboundStream(\n        await connection.newStream(this.multicodecs, {\n          runOnTransientConnection: this.runOnTransientConnection\n        }),\n        (e) => { this.log.error('outbound pipe error', e) },\n        { maxBufferSize: this.opts.maxOutboundBufferSize }\n      )\n\n      this.log('create outbound stream %p', peerId)\n\n      this.streamsOutbound.set(id, stream)\n\n      const protocol = stream.protocol\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id)\n      }\n      this.metrics?.peersPerProtocol.inc({ protocol }, 1)\n\n      // Immediately send own subscriptions via the newly attached stream\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id)\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true)\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e)\n    }\n  }\n\n  private createInboundStream (peerId: PeerId, stream: Stream): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n    const priorInboundStream = this.streamsInbound.get(id)\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id)\n      priorInboundStream.close().catch((err) => { this.log.error(err) })\n    }\n\n    this.log('create inbound stream %s', id)\n\n    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength })\n    this.streamsInbound.set(id, inboundStream)\n\n    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => { this.log(err) })\n  }\n\n  /**\n   * Add a peer to the router\n   */\n  private addPeer (peerId: PeerId, direction: ConnectionDirection, addr: Multiaddr): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      this.log('new peer %p', peerId)\n\n      this.peers.add(id)\n\n      // Add to peer scoring\n      this.score.addPeer(id)\n      const currentIP = multiaddrToIPStr(addr)\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP)\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString())\n      }\n\n      // track the connection direction. Don't allow to unset outbound\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound')\n      }\n    }\n  }\n\n  /**\n   * Removes a peer from the router\n   */\n  private removePeer (peerId: PeerId): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // delete peer\n    this.log('delete peer %p', peerId)\n    this.peers.delete(id)\n\n    const outboundStream = this.streamsOutbound.get(id)\n    const inboundStream = this.streamsInbound.get(id)\n\n    if (outboundStream != null) {\n      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1)\n    }\n\n    // close streams\n    outboundStream?.close().catch((err) => { this.log.error(err) })\n    inboundStream?.close().catch((err) => { this.log.error(err) })\n\n    // remove streams\n    this.streamsOutbound.delete(id)\n    this.streamsInbound.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    // Remove this peer from the mesh\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id)) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1)\n      }\n    }\n\n    // Remove this peer from the fanout\n    for (const peers of this.fanout.values()) {\n      peers.delete(id)\n    }\n\n    // Remove from floodsubPeers\n    this.floodsubPeers.delete(id)\n    // Remove from gossip mapping\n    this.gossip.delete(id)\n    // Remove from control mapping\n    this.control.delete(id)\n    // Remove from backoff mapping\n    this.outbound.delete(id)\n\n    // Remove from peer scoring\n    this.score.removePeer(id)\n\n    this.acceptFromWhitelist.delete(id)\n  }\n\n  // API METHODS\n\n  get started (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n  getMeshPeers (topic: TopicStr): PeerIdStr[] {\n    const peersInTopic = this.mesh.get(topic)\n    return (peersInTopic != null) ? Array.from(peersInTopic) : []\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers (topic: TopicStr): PeerId[] {\n    const peersInTopic = this.topics.get(topic)\n    return ((peersInTopic != null) ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str))\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics (): TopicStr[] {\n    return Array.from(this.subscriptions)\n  }\n\n  // TODO: Reviewing Pubsub API\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n  private async pipePeerReadStream (peerId: PeerId, stream: AsyncIterable<Uint8ArrayList>): Promise<void> {\n    try {\n      await pipe(stream, async (source) => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray()\n            // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n            const rpc = RPC.decode(rpcBytes, {\n              limits: {\n                subscriptions: this.decodeRpcLimits.maxSubscriptions,\n                messages: this.decodeRpcLimits.maxMessages,\n                control$: {\n                  ihave: this.decodeRpcLimits.maxIhaveMessageIDs,\n                  iwant: this.decodeRpcLimits.maxIwantMessageIDs,\n                  graft: this.decodeRpcLimits.maxControlMessages,\n                  prune: this.decodeRpcLimits.maxControlMessages,\n                  prune$: {\n                    peers: this.decodeRpcLimits.maxPeerInfos\n                  }\n                }\n              }\n            })\n\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length)\n\n            // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc)\n              } catch (err) {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              })\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError()\n            this.log(e as Error)\n          }\n        }\n      })\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError()\n      this.handlePeerReadStreamError(err as Error, peerId)\n    }\n  }\n\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   * */\n  private handlePeerReadStreamError (err: Error, peerId: PeerId): void {\n    this.log.error(err)\n    this.onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  public async handleReceivedRpc (from: PeerId, rpc: RPC): Promise<void> {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from)\n      this.metrics?.rpcRecvNotAccepted.inc()\n      return\n    }\n\n    const subscriptions = (rpc.subscriptions != null) ? rpc.subscriptions.length : 0\n    const messages = (rpc.messages != null) ? rpc.messages.length : 0\n    let ihave = 0\n    let iwant = 0\n    let graft = 0\n    let prune = 0\n    if (rpc.control != null) {\n      if (rpc.control.ihave != null) ihave = rpc.control.ihave.length\n      if (rpc.control.iwant != null) iwant = rpc.control.iwant.length\n      if (rpc.control.graft != null) graft = rpc.control.graft.length\n      if (rpc.control.prune != null) prune = rpc.control.prune.length\n    }\n    this.log(\n      `rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`\n    )\n\n    // Handle received subscriptions\n    if ((rpc.subscriptions != null) && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n\n      const subscriptions: Array<{ topic: TopicStr, subscribe: boolean }> = []\n\n      rpc.subscriptions.forEach((subOpt) => {\n        const topic = subOpt.topic\n        const subscribe = subOpt.subscribe === true\n\n        if (topic != null) {\n          if ((this.allowedTopics != null) && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe)\n\n          subscriptions.push({ topic, subscribe })\n        }\n      })\n\n      this.safeDispatchEvent<SubscriptionChangeData>('subscription-change', {\n        detail: { peerId: from, subscriptions }\n      })\n    }\n\n    // Handle messages\n    // TODO: (up to limit)\n    for (const message of rpc.messages) {\n      if ((this.allowedTopics != null) && !this.allowedTopics.has(message.topic)) {\n        // Not allowed: message cache data-structures are not bounded by topic count\n        // TODO: Should apply behaviour penalties?\n        continue\n      }\n\n      const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n        // Should never throw, but handle just in case\n        .catch((err) => {\n          this.metrics?.onMsgRecvError(message.topic)\n          this.log(err)\n        })\n\n      if (this.opts.awaitRpcMessageHandler) {\n        await handleReceivedMessagePromise\n      }\n    }\n\n    // Handle control messages\n    if (rpc.control != null) {\n      await this.handleControlMessage(from.toString(), rpc.control)\n    }\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  private handleReceivedSubscription (from: PeerId, topic: TopicStr, subscribe: boolean): void {\n    this.log('subscription update from %p topic %s', from, topic)\n\n    let topicSet = this.topics.get(topic)\n    if (topicSet == null) {\n      topicSet = new Set()\n      this.topics.set(topic, topicSet)\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString())\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString())\n    }\n\n    // TODO: rust-libp2p has A LOT more logic here\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async handleReceivedMessage (from: PeerId, rpcMsg: RPC.Message): Promise<void> {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic)\n\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg)\n\n    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code)\n\n    const validationCode = validationResult.code\n    switch (validationCode) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic)\n        // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true)\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString())\n        return\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr != null) {\n          const msgIdStr = validationResult.msgIdStr\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason)\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason)\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic)\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult)\n        return\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr)\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr)\n\n        // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation)\n\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from)\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(\n              new CustomEvent<GossipsubMessage>('gossipsub:message', {\n                detail: {\n                  propagationSource: from,\n                  msgId: validationResult.messageId.msgIdStr,\n                  msg: validationResult.msg\n                }\n              })\n            )\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent<Message>('message', { detail: validationResult.msg }))\n          }\n        }\n\n        // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString())\n        }\n        break\n      default:\n        throw new Error(`Invalid validation result: ${validationCode}`)\n    }\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async validateReceivedMessage (\n    propagationSource: PeerId,\n    rpcMsg: RPC.Message\n  ): Promise<ReceivedMessageResult> {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg)\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined\n\n    if (msgIdCached != null) {\n      // This message has been seen previously. Ignore it\n      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached }\n    }\n\n    // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg)\n\n    if (!validationResult.valid) {\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error }\n    }\n\n    const msg = validationResult.message\n\n    // Try and perform the data transform to the message. If it fails, consider it invalid.\n    try {\n      if (this.dataTransform != null) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data)\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e)\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed }\n    }\n\n    // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n\n    // Calculate the message id on the transformed data.\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n    const messageId = { msgId, msgIdStr }\n\n    // Add the message to the duplicate caches\n    if (fastMsgIdStr !== undefined && (this.fastMsgIdCache != null)) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr)\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc()\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return { code: MessageStatus.duplicate, msgIdStr }\n    } else {\n      this.seenCache.put(msgIdStr)\n    }\n\n    // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n    const topicValidator = this.topicValidators.get(rpcMsg.topic)\n    if (topicValidator != null) {\n      let acceptance: TopicValidatorResult\n      // Use try {} catch {} in case topicValidator() is synchronous\n      try {\n        acceptance = await topicValidator(propagationSource, msg)\n      } catch (e) {\n        const errCode = (e as { code: string }).code\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) acceptance = TopicValidatorResult.Ignore\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) acceptance = TopicValidatorResult.Reject\n        else acceptance = TopicValidatorResult.Ignore\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr }\n      }\n    }\n\n    return { code: MessageStatus.valid, messageId, msg }\n  }\n\n  /**\n   * Return score of a peer.\n   */\n  getScore (peerId: PeerIdStr): number {\n    return this.score.score(peerId)\n  }\n\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n  private sendSubscriptions (toPeer: PeerIdStr, topics: string[], subscribe: boolean): void {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map((topic) => ({ topic, subscribe })),\n      messages: []\n    })\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   */\n  private async handleControlMessage (id: PeerIdStr, controlMsg: RPC.ControlMessage): Promise<void> {\n    if (controlMsg === undefined) {\n      return\n    }\n\n    const iwant = (controlMsg.ihave != null) ? this.handleIHave(id, controlMsg.ihave) : []\n    const ihave = (controlMsg.iwant != null) ? this.handleIWant(id, controlMsg.iwant) : []\n    const prune = (controlMsg.graft != null) ? await this.handleGraft(id, controlMsg.graft) : []\n    ;(controlMsg.prune != null) && (await this.handlePrune(id, controlMsg.prune))\n\n    if ((iwant.length === 0) && (ihave.length === 0) && (prune.length === 0)) {\n      return\n    }\n\n    const sent = this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }))\n    const iwantMessageIds = iwant[0]?.messageIDs\n    if (iwantMessageIds != null) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds)\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1)\n      }\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   */\n  public acceptFrom (id: PeerIdStr): boolean {\n    if (this.direct.has(id)) {\n      return true\n    }\n\n    const now = Date.now()\n    const entry = this.acceptFromWhitelist.get(id)\n\n    if ((entry != null) && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1\n      return true\n    }\n\n    const score = this.score.score(id)\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      })\n    } else {\n      this.acceptFromWhitelist.delete(id)\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold\n  }\n\n  /**\n   * Handles IHAVE messages\n   */\n  private handleIHave (id: PeerIdStr, ihave: RPC.ControlIHave[]): RPC.ControlIWant[] {\n    if (ihave.length === 0) {\n      return []\n    }\n\n    // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore })\n      return []\n    }\n\n    // IHAVE flood protection\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1\n    this.peerhave.set(id, peerhave)\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log(\n        'IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring',\n        id,\n        peerhave\n      )\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave })\n      return []\n    }\n\n    const iasked = this.iasked.get(id) ?? 0\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked })\n      return []\n    }\n\n    // string msgId => msgId\n    const iwant = new Map<MsgIdStr, Uint8Array>()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (topicID == null || (messageIDs == null) || !this.mesh.has(topicID)) {\n        return\n      }\n\n      let idonthave = 0\n\n      messageIDs.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId)\n          idonthave++\n        }\n      })\n\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave)\n    })\n\n    if (iwant.size === 0) {\n      return []\n    }\n\n    let iask = iwant.size\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id)\n\n    let iwantList = Array.from(iwant.values())\n    // ask in random order\n    shuffle(iwantList)\n\n    // truncate to the messages we are actually asking for and update the iasked counter\n    iwantList = iwantList.slice(0, iask)\n    this.iasked.set(id, iasked + iask)\n\n    // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [\n      {\n        messageIDs: iwantList\n      }\n    ]\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n  private handleIWant (id: PeerIdStr, iwant: RPC.ControlIWant[]): RPC.Message[] {\n    if (iwant.length === 0) {\n      return []\n    }\n\n    // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score)\n      return []\n    }\n\n    const ihave = new Map<MsgIdStr, RPC.Message>()\n    const iwantByTopic = new Map<TopicStr, number>()\n    let iwantDonthave = 0\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs?.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        const entry = this.mcache.getWithIWantCount(msgIdStr, id)\n        if (entry == null) {\n          iwantDonthave++\n          return\n        }\n\n        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0))\n\n        if (entry.count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId)\n          return\n        }\n\n        ihave.set(msgIdStr, entry.msg)\n      })\n    })\n\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave)\n\n    if (ihave.size === 0) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id)\n      return []\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id)\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   */\n  private async handleGraft (id: PeerIdStr, graft: RPC.ControlGraft[]): Promise<RPC.ControlPrune[]> {\n    const prune: TopicStr[] = []\n    const score = this.score.score(id)\n    const now = Date.now()\n    let doPX = this.opts.doPX\n\n    graft.forEach(({ topicID }) => {\n      if (topicID == null) {\n        return\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false\n        // spam hardening: ignore GRAFTs for unknown topics\n        return\n      }\n\n      // check if peer is already in the mesh; if so do nothing\n      if (peersInMesh.has(id)) {\n        return\n      }\n\n      const backoffExpiry = this.backoff.get(topicID)?.get(id)\n\n      // This if/else chain contains the various cases of valid (and semi-valid) GRAFTs\n      // Most of these cases result in a PRUNE immediately being sent in response\n\n      // we don't GRAFT to/from direct peers; complain loudly if this happens\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id)\n        // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n        prune.push(topicID)\n        // but don't px\n        doPX = false\n\n        // make sure we are not backing off that peer\n      } else if (typeof backoffExpiry === 'number' && now < backoffExpiry) {\n        this.log('GRAFT: ignoring backed off peer %s', id)\n        // add behavioral penalty\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        // no PX\n        doPX = false\n        // check the flood cutoff -- is the GRAFT coming too fast?\n        const floodCutoff = backoffExpiry + this.opts.graftFloodThreshold - this.opts.pruneBackoff\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        }\n        // refresh the backoff\n        this.addBackoff(id, topicID)\n        prune.push(topicID)\n\n        // check the score\n      } else if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID)\n        // we do send them PRUNE however, because it's a matter of protocol correctness\n        prune.push(topicID)\n        // but we won't PX to them\n        doPX = false\n        // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n        this.addBackoff(id, topicID)\n\n        // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n        // from peers with outbound connections; this is a defensive check to restrict potential\n        // mesh takeover attacks combined with love bombing\n      } else if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {\n        prune.push(topicID)\n        this.addBackoff(id, topicID)\n\n        // valid graft\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', id, topicID)\n        this.score.graft(id, topicID)\n        peersInMesh.add(id)\n\n        this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1)\n      }\n\n      this.safeDispatchEvent<MeshPeer>('gossipsub:graft', { detail: { peerId: id, topic: topicID, direction: 'inbound' } })\n    })\n\n    if (prune.length === 0) {\n      return []\n    }\n\n    const onUnsubscribe = false\n    return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)))\n  }\n\n  /**\n   * Handles Prune messages\n   */\n  private async handlePrune (id: PeerIdStr, prune: RPC.ControlPrune[]): Promise<void> {\n    const score = this.score.score(id)\n\n    for (const { topicID, backoff, peers } of prune) {\n      if (topicID == null) {\n        continue\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        return\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID)\n      this.score.prune(id, topicID)\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id)\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1)\n      }\n\n      // is there a backoff specified by the peer? if so obey it\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000)\n      } else {\n        this.addBackoff(id, topicID)\n      }\n\n      // PX\n      if ((peers != null) && (peers.length > 0)) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log(\n            'PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]',\n            id,\n            score,\n            topicID\n          )\n        } else {\n          await this.pxConnect(peers)\n        }\n      }\n\n      this.safeDispatchEvent<MeshPeer>('gossipsub:prune', { detail: { peerId: id, topic: topicID, direction: 'inbound' } })\n    }\n  }\n\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n  private addBackoff (id: PeerIdStr, topic: TopicStr): void {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff)\n  }\n\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param intervalMs - backoff duration in milliseconds\n   */\n  private doAddBackoff (id: PeerIdStr, topic: TopicStr, intervalMs: number): void {\n    let backoff = this.backoff.get(topic)\n    if (backoff == null) {\n      backoff = new Map()\n      this.backoff.set(topic, backoff)\n    }\n    const expire = Date.now() + intervalMs\n    const existingExpire = backoff.get(id) ?? 0\n    if (existingExpire < expire) {\n      backoff.set(id, expire)\n    }\n  }\n\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n  private applyIwantPenalties (): void {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count)\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise)\n    })\n  }\n\n  /**\n   * Clear expired backoff expiries\n   */\n  private clearBackoff (): void {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return\n    }\n\n    const now = Date.now()\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        // add some slack time to the expiration, see https://github.com/libp2p/specs/pull/289\n        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {\n          backoff.delete(id)\n        }\n      })\n      if (backoff.size === 0) {\n        this.backoff.delete(topic)\n      }\n    })\n  }\n\n  /**\n   * Maybe reconnect to direct peers\n   */\n  private async directConnect (): Promise<void> {\n    const toconnect: string[] = []\n    this.direct.forEach((id) => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id)\n      }\n    })\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n  private async pxConnect (peers: RPC.PeerInfo[]): Promise<void> {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers)\n      peers = peers.slice(0, this.opts.prunePeers)\n    }\n    const toconnect: string[] = []\n\n    await Promise.all(\n      peers.map(async (pi) => {\n        if (pi.peerID == null) {\n          return\n        }\n\n        const peer = peerIdFromBytes(pi.peerID)\n        const p = peer.toString()\n\n        if (this.peers.has(p)) {\n          return\n        }\n\n        if (pi.signedPeerRecord == null) {\n          toconnect.push(p)\n          return\n        }\n\n        // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n        try {\n          if (!(await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer))) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book')\n            return\n          }\n          toconnect.push(p)\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record')\n        }\n      })\n    )\n\n    if (toconnect.length === 0) {\n      return\n    }\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n  private async connect (id: PeerIdStr): Promise<void> {\n    this.log('Initiating connection with %s', id)\n    const peerId = peerIdFromString(id)\n    const connection = await this.components.connectionManager.openConnection(peerId)\n    for (const multicodec of this.multicodecs) {\n      for (const topology of this.components.registrar.getTopologies(multicodec)) {\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a topic\n   */\n  subscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true)\n      }\n    }\n\n    this.join(topic)\n  }\n\n  /**\n   * Unsubscribe to a topic\n   */\n  unsubscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic)\n\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed)\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false)\n      }\n    }\n\n    this.leave(topic)\n  }\n\n  /**\n   * Join topic\n   */\n  private join (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    // if we are already in the mesh, return\n    if (this.mesh.has(topic)) {\n      return\n    }\n\n    this.log('JOIN %s', topic)\n    this.metrics?.onJoin(topic)\n\n    const toAdd = new Set<PeerIdStr>()\n    const backoff = this.backoff.get(topic)\n\n    // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n    const fanoutPeers = this.fanout.get(topic)\n    if (fanoutPeers != null) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic)\n      this.fanoutLastpub.delete(topic)\n\n      // remove explicit peers, peers with negative scores, and backoffed peers\n      fanoutPeers.forEach((id) => {\n        if (!this.direct.has(id) && this.score.score(id) >= 0 && ((backoff == null) || !backoff.has(id))) {\n          toAdd.add(id)\n        }\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size)\n    }\n\n    // check if we need to get more peers, which we randomly select\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size\n      const newPeers = this.getRandomGossipPeers(\n        topic,\n        this.opts.D,\n        (id: PeerIdStr): boolean =>\n          // filter direct peers and peers with negative score\n          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && ((backoff == null) || !backoff.has(id))\n      )\n\n      newPeers.forEach((peer) => {\n        toAdd.add(peer)\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount)\n    }\n\n    this.mesh.set(topic, toAdd)\n\n    toAdd.forEach((id) => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic)\n      this.sendGraft(id, topic)\n\n      // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    })\n  }\n\n  /**\n   * Leave topic\n   */\n  private leave (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    this.log('LEAVE %s', topic)\n    this.metrics?.onLeave(topic)\n\n    // Send PRUNE to mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers != null) {\n      Promise.all(\n        Array.from(meshPeers).map(async (id) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', id, topic)\n          await this.sendPrune(id, topic)\n        })\n      ).catch((err) => {\n        this.log('Error sending prunes to mesh peers', err)\n      })\n      this.mesh.delete(topic)\n    }\n  }\n\n  private selectPeersToForward (topic: TopicStr, propagationSource?: PeerIdStr, excludePeers?: Set<PeerIdStr>): Set<string> {\n    const tosend = new Set<PeerIdStr>()\n\n    // Add explicit peers\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      this.direct.forEach((peer) => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n\n      // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n      this.floodsubPeers.forEach((peer) => {\n        if (\n          peersInTopic.has(peer) &&\n          propagationSource !== peer &&\n          !(excludePeers?.has(peer) ?? false) &&\n          this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold\n        ) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    // add mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if ((meshPeers != null) && meshPeers.size > 0) {\n      meshPeers.forEach((peer) => {\n        if (propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    return tosend\n  }\n\n  private selectPeersToPublish (topic: TopicStr): {\n    tosend: Set<PeerIdStr>\n    tosendCount: ToSendGroupCount\n  } {\n    const tosend = new Set<PeerIdStr>()\n    const tosendCount: ToSendGroupCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach((id) => {\n          if (this.direct.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n\n        // direct peers (if subscribed)\n        this.direct.forEach((id) => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          }\n        })\n\n        // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n        this.floodsubPeers.forEach((id) => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n\n        // Gossipsub peers handling\n        const meshPeers = this.mesh.get(topic)\n        if ((meshPeers != null) && meshPeers.size > 0) {\n          meshPeers.forEach((peer) => {\n            tosend.add(peer)\n            tosendCount.mesh++\n          })\n\n          // We want to publish to at least `D` peers.\n          // If there are insufficient peers in the mesh, publish to other topic peers\n          if (meshPeers.size < this.opts.D) {\n            // pick additional topic peers above the publishThreshold\n            const topicPeers = this.getRandomGossipPeers(topic, this.opts.D - meshPeers.size, (id) => {\n              return !meshPeers.has(id) && !this.direct.has(id) && !this.floodsubPeers.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            topicPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.mesh++\n            })\n          }\n        // eslint-disable-next-line @typescript-eslint/brace-style\n        }\n\n        // We are not in the mesh for topic, use fanout peers\n        else {\n          const fanoutPeers = this.fanout.get(topic)\n          if ((fanoutPeers != null) && fanoutPeers.size > 0) {\n            fanoutPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.fanout++\n            })\n          // eslint-disable-next-line @typescript-eslint/brace-style\n          }\n\n          // We have no fanout peers, select mesh_n of them and add them to the fanout\n          else {\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            // eslint-disable-next-line max-depth\n            if (newFanoutPeers.size > 0) {\n              this.fanout.set(topic, newFanoutPeers)\n\n              newFanoutPeers.forEach((peer) => {\n                tosend.add(peer)\n                tosendCount.fanout++\n              })\n            }\n          }\n\n          // We are publishing to fanout peers - update the time we published\n          this.fanoutLastpub.set(topic, Date.now())\n        }\n      }\n    }\n\n    return { tosend, tosendCount }\n  }\n\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n  private forwardMessage (\n    msgIdStr: string,\n    rawMsg: RPC.Message,\n    propagationSource?: PeerIdStr,\n    excludePeers?: Set<PeerIdStr>\n  ): void {\n    // message is fully validated inform peer_score\n    if (propagationSource != null) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic)\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers)\n\n    // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n\n    // forward the message to peers\n    tosend.forEach((id) => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, createGossipRpc([rawMsg]))\n    })\n\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size)\n  }\n\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n  async publish (topic: TopicStr, data: Uint8Array, opts?: PublishOpts): Promise<PublishResult> {\n    const startMs = Date.now()\n    const transformedData = (this.dataTransform != null) ? this.dataTransform.outboundTransform(topic, data) : data\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized')\n    }\n\n    // Prepare raw message with user's publishConfig\n    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData)\n\n    // calculate the message id from the un-transformed data\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic)\n        return { recipients: [] }\n      }\n      throw Error('PublishError.Duplicate')\n    }\n\n    const { tosend, tosendCount } = this.selectPeersToPublish(topic)\n    const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const allowPublishToZeroTopicPeers = opts?.allowPublishToZeroTopicPeers ?? this.opts.allowPublishToZeroTopicPeers\n\n    if (tosend.size === 0 && !allowPublishToZeroTopicPeers && !willSendToSelf) {\n      throw Error('PublishError.NoPeersSubscribedToTopic')\n    }\n\n    // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n    this.seenCache.put(msgIdStr)\n    // all published messages are valid\n    this.mcache.put({ msgId, msgIdStr }, rawMsg, true)\n\n    // If the message is anonymous or has a random author add it to the published message ids cache.\n    this.publishedMessageIds.put(msgIdStr)\n\n    const batchPublish = opts?.batchPublish ?? this.opts.batchPublish\n    const rpc = createGossipRpc([rawMsg])\n    if (batchPublish) {\n      this.sendRpcInBatch(tosend, rpc)\n    } else {\n      // Send to set of peers aggregated from direct, mesh, fanout\n      for (const id of tosend) {\n        // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n        const sent = this.sendRpc(id, rpc)\n\n        // did not actually send the message\n        if (!sent) {\n          tosend.delete(id)\n        }\n      }\n    }\n\n    const durationMs = Date.now() - startMs\n    this.metrics?.onPublishMsg(\n      topic,\n      tosendCount,\n      tosend.size,\n      rawMsg.data != null ? rawMsg.data.length : 0,\n      durationMs\n    )\n\n    // Dispatch the message to the user if we are subscribed to the topic\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString())\n\n      super.dispatchEvent(\n        new CustomEvent<GossipsubMessage>('gossipsub:message', {\n          detail: {\n            propagationSource: this.components.peerId,\n            msgId: msgIdStr,\n            msg\n          }\n        })\n      )\n      // TODO: Add option to switch between emit per topic or all messages in one\n      super.dispatchEvent(new CustomEvent<Message>('message', { detail: msg }))\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))\n    }\n  }\n\n  /**\n   * Send the same data in batch to tosend list without considering cached control messages\n   * This is not only faster but also avoid allocating memory for each peer\n   * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344\n   */\n  private sendRpcInBatch (tosend: Set<PeerIdStr>, rpc: RPC): void {\n    const rpcBytes = RPC.encode(rpc)\n    const prefixedData = encode.single(rpcBytes)\n    for (const id of tosend) {\n      const outboundStream = this.streamsOutbound.get(id)\n      if (outboundStream == null) {\n        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n        tosend.delete(id)\n        continue\n      }\n      try {\n        outboundStream.pushPrefixed(prefixedData)\n      } catch (e) {\n        tosend.delete(id)\n        this.log.error(`Cannot send rpc to ${id}`, e)\n      }\n\n      this.metrics?.onRpcSent(rpc, rpcBytes.length)\n    }\n  }\n\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P₄ penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P₄ penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n  reportMessageValidationResult (msgId: MsgIdStr, propagationSource: PeerIdStr, acceptance: TopicValidatorResult): void {\n    let cacheEntry: MessageCacheRecord | null\n\n    if (acceptance === TopicValidatorResult.Accept) {\n      cacheEntry = this.mcache.validate(msgId)\n\n      if (cacheEntry != null) {\n        const { message: rawMsg, originatingPeers } = cacheEntry\n        // message is fully validated inform peer_score\n        this.score.deliverMessage(propagationSource, msgId, rawMsg.topic)\n\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource, originatingPeers)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    // eslint-disable-next-line @typescript-eslint/brace-style\n    }\n\n    // Not valid\n    else {\n      cacheEntry = this.mcache.remove(msgId)\n\n      if (cacheEntry != null) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance)\n        const { message: rawMsg, originatingPeers } = cacheEntry\n\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        this.score.rejectMessage(propagationSource, msgId, rawMsg.topic, rejectReason)\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason)\n        }\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId)\n    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs)\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   */\n  private sendGraft (id: PeerIdStr, topic: string): void {\n    const graft = [\n      {\n        topicID: topic\n      }\n    ]\n    const out = createGossipRpc([], { graft })\n    this.sendRpc(id, out)\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   */\n  private async sendPrune (id: PeerIdStr, topic: string): Promise<void> {\n    // this is only called from leave() function\n    const onUnsubscribe = true\n    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)]\n    const out = createGossipRpc([], { prune })\n    this.sendRpc(id, out)\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  private sendRpc (id: PeerIdStr, rpc: RPC): boolean {\n    const outboundStream = this.streamsOutbound.get(id)\n    if (outboundStream == null) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n      return false\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(id)\n    if (ctrl != null) {\n      this.piggybackControl(id, rpc, ctrl)\n      this.control.delete(id)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(id)\n    if (ihave != null) {\n      this.piggybackGossip(id, rpc, ihave)\n      this.gossip.delete(id)\n    }\n\n    const rpcBytes = RPC.encode(rpc)\n    try {\n      outboundStream.push(rpcBytes)\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e)\n\n      // if the peer had control messages or gossip, re-attach\n      if (ctrl != null) {\n        this.control.set(id, ctrl)\n      }\n      if (ihave != null) {\n        this.gossip.set(id, ihave)\n      }\n\n      return false\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length)\n\n    if (rpc.control?.graft != null) {\n      for (const topic of rpc.control?.graft) {\n        if (topic.topicID != null) {\n          this.safeDispatchEvent<MeshPeer>('gossipsub:graft', { detail: { peerId: id, topic: topic.topicID, direction: 'outbound' } })\n        }\n      }\n    }\n    if (rpc.control?.prune != null) {\n      for (const topic of rpc.control?.prune) {\n        if (topic.topicID != null) {\n          this.safeDispatchEvent<MeshPeer>('gossipsub:prune', { detail: { peerId: id, topic: topic.topicID, direction: 'outbound' } })\n        }\n      }\n    }\n\n    return true\n  }\n\n  /** Mutates `outRpc` adding graft and prune control messages */\n  public piggybackControl (id: PeerIdStr, outRpc: RPC, ctrl: RPC.ControlMessage): void {\n    const rpc = ensureControl(outRpc)\n    for (const graft of ctrl.graft) {\n      if (graft.topicID != null && (this.mesh.get(graft.topicID)?.has(id) ?? false)) {\n        rpc.control.graft.push(graft)\n      }\n    }\n\n    for (const prune of ctrl.prune) {\n      if (prune.topicID != null && !(this.mesh.get(prune.topicID)?.has(id) ?? false)) {\n        rpc.control.prune.push(prune)\n      }\n    }\n  }\n\n  /** Mutates `outRpc` adding ihave control messages */\n  private piggybackGossip (id: PeerIdStr, outRpc: RPC, ihave: RPC.ControlIHave[]): void {\n    const rpc = ensureControl(outRpc)\n    rpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n  private async sendGraftPrune (\n    tograft: Map<string, string[]>,\n    toprune: Map<string, string[]>,\n    noPX: Map<string, boolean>\n  ): Promise<void> {\n    const doPX = this.opts.doPX\n    const onUnsubscribe = false\n    for (const [id, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune: RPC.ControlPrune[] = []\n      // If a peer also has prunes, process them now\n      const pruning = toprune.get(id)\n      if (pruning != null) {\n        prune = await Promise.all(\n          pruning.map(\n            async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n          )\n        )\n        toprune.delete(id)\n      }\n\n      this.sendRpc(id, createGossipRpc([], { graft, prune }))\n    }\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(\n        topics.map(\n          async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n        )\n      )\n      this.sendRpc(id, createGossipRpc([], { prune }))\n    }\n  }\n\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n  private emitGossip (peersToGossipByTopic: Map<string, Set<PeerIdStr>>): void {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()))\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? [])\n    }\n  }\n\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   *\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n  private doEmitGossip (topic: string, candidateToGossip: Set<PeerIdStr>, messageIDs: Uint8Array[]): void {\n    if (messageIDs.length === 0) {\n      return\n    }\n\n    // shuffle to emit in random order\n    shuffle(messageIDs)\n\n    // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length)\n    }\n\n    if (candidateToGossip.size === 0) return\n    let target = this.opts.Dlazy\n    const factor = constants.GossipsubGossipFactor * candidateToGossip.size\n    let peersToGossip: Set<PeerIdStr> | PeerIdStr[] = candidateToGossip\n    if (factor > target) {\n      target = factor\n    }\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target)\n    }\n\n    // Emit the IHAVE gossip to the selected peers up to the target\n    peersToGossip.forEach((id) => {\n      let peerMessageIDs = messageIDs\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength)\n      }\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      })\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  private flush (): void {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      this.sendRpc(peer, createGossipRpc([], { ihave }))\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      const out = createGossipRpc([], { graft: control.graft, prune: control.prune })\n      this.sendRpc(peer, out)\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n  private pushGossip (id: PeerIdStr, controlIHaveMsgs: RPC.ControlIHave): void {\n    this.log('Add gossip to %s', id)\n    const gossip = this.gossip.get(id) ?? []\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n  private async makePrune (\n    id: PeerIdStr,\n    topic: string,\n    doPX: boolean,\n    onUnsubscribe: boolean\n  ): Promise<RPC.ControlPrune> {\n    this.score.prune(id, topic)\n    if (this.streamsOutbound.get(id)?.protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      }\n    }\n    // backoff is measured in seconds\n    // GossipsubPruneBackoff and GossipsubUnsubscribeBackoff are measured in milliseconds\n    // The protobuf has it as a uint64\n    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff\n    const backoff = backoffMs / 1000\n    this.doAddBackoff(id, topic, backoffMs)\n\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff\n      }\n    }\n\n    // select peers for Peer eXchange\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n      return xid !== id && this.score.score(xid) >= 0\n    })\n    const px = await Promise.all(\n      Array.from(peers).map(async (peerId) => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const id = peerIdFromString(peerId)\n        let peerInfo: Peer | undefined\n\n        try {\n          peerInfo = await this.components.peerStore.get(id)\n        } catch (err: any) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n        }\n\n        return {\n          peerID: id.toBytes(),\n          signedPeerRecord: peerInfo?.peerRecordEnvelope\n        }\n      })\n    )\n    return {\n      topicID: topic,\n      peers: px,\n      backoff\n    }\n  }\n\n  private readonly runHeartbeat = (): void => {\n    const timer = this.metrics?.heartbeatDuration.startTimer()\n\n    this.heartbeat()\n      .catch((err) => {\n        this.log('Error running heartbeat', err)\n      })\n      .finally(() => {\n        if (timer != null) {\n          timer()\n        }\n\n        // Schedule the next run if still in started status\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout)\n\n          // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n          let msToNextHeartbeat =\n            this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval)\n\n          // If too close to next heartbeat, skip one\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval\n            this.metrics?.heartbeatSkipped.inc()\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat)\n        }\n      })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n  public async heartbeat (): Promise<void> {\n    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts\n\n    this.heartbeatTicks++\n\n    // cache scores throught the heartbeat\n    const scores = new Map<string, number>()\n    const getScore = (id: string): number => {\n      let s = scores.get(id)\n      if (s === undefined) {\n        s = this.score.score(id)\n        scores.set(id, s)\n      }\n      return s\n    }\n\n    // peer id => topic[]\n    const tograft = new Map<string, string[]>()\n    // peer id => topic[]\n    const toprune = new Map<string, string[]>()\n    // peer id => don't px\n    const noPX = new Map<string, boolean>()\n\n    // clean up expired backoffs\n    this.clearBackoff()\n\n    // clean up peerhave/iasked counters\n    this.peerhave.clear()\n    this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size)\n    this.iasked.clear()\n\n    // apply IWANT request penalties\n    this.applyIwantPenalties()\n\n    // ensure direct peers are connected\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect()\n    }\n\n    // EXTRA: Prune caches\n    this.fastMsgIdCache?.prune()\n    this.seenCache.prune()\n    this.gossipTracer.prune()\n    this.publishedMessageIds.prune()\n\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     * + get more mesh peers\n     * + more outbound peers\n     * + oppportunistic grafting\n     * + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map<string, Set<PeerIdStr>>()\n    // maintain the mesh for topics we have joined\n    // eslint-disable-next-line complexity\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic)\n      const candidateMeshPeers = new Set<PeerIdStr>()\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        const backoff = this.backoff.get(topic)\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !peers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (((backoff == null) || !backoff.has(id)) && score >= 0) candidateMeshPeers.add(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = (id: PeerIdStr, reason: ChurnReason): void => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic)\n        // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n        this.addBackoff(id, topic)\n        // remove peer from mesh\n        peers.delete(id)\n        // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n        this.metrics?.onRemoveFromMesh(topic, reason, 1)\n        // add to toprune\n        const topics = toprune.get(id)\n        if (topics == null) {\n          toprune.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      const graftPeer = (id: PeerIdStr, reason: InclusionReason): void => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic)\n        // update peer score\n        this.score.graft(id, topic)\n        // add peer to mesh\n        peers.add(id)\n        // when we add a new mesh peer, we don't want to gossip messages to it\n        peersToGossip.delete(id)\n        this.metrics?.onAddToMesh(topic, reason, 1)\n        // add to tograft\n        const topics = tograft.get(id)\n        if (topics == null) {\n          tograft.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      // drop all peers with negative score, without PX\n      peers.forEach((id) => {\n        const score = getScore(id)\n\n        // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic)\n          prunePeer(id, ChurnReason.BadScore)\n          noPX.set(id, true)\n        }\n      })\n\n      // do we have enough peers?\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size\n        // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed)\n\n        newMeshPeers.forEach((p) => {\n          graftPeer(p, InclusionReason.NotEnough)\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers)\n        // sort by score\n        peersArray.sort((a, b) => getScore(b) - getScore(a))\n        // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)))\n\n        // count the outbound peers we are keeping\n        let outbound = 0\n        peersArray.slice(0, D).forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, bubble up some outbound peers from the random selection\n        if (outbound < Dout) {\n          const rotate = (i: number): void => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i]\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1]\n            }\n            peersArray[0] = p\n          }\n\n          // first bubble up all outbound peers already in the selection to the front\n          if (outbound > 0) {\n            let ihave = outbound\n            for (let i = 1; i < D && ihave > 0; i++) {\n              // eslint-disable-next-line max-depth\n              if (this.outbound.get(peersArray[i]) ?? false) {\n                rotate(i)\n                ihave--\n              }\n            }\n          }\n\n          // now bubble up enough outbound peers outside the selection to the front\n          let ineed = D - outbound\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i]) ?? false) {\n              rotate(i)\n              ineed--\n            }\n          }\n        }\n\n        // prune the excess peers\n        peersArray.slice(D).forEach((p) => {\n          prunePeer(p, ChurnReason.Excess)\n        })\n      }\n\n      // do we have enough outbound peers?\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0\n        peers.forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, select some peers with outbound connections and graft them\n        if (outbound < Dout) {\n          const ineed = Dout - outbound\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true)\n\n          newMeshPeers.forEach((p) => {\n            graftPeer(p, InclusionReason.Outbound)\n          })\n        }\n      }\n\n      // should we try to improve the mesh with opportunistic grafting?\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b))\n        const medianIndex = Math.floor(peers.size / 2)\n        const medianScore = getScore(peersList[medianIndex])\n\n        // if the median score is below the threshold, select a better peer (if any) and GRAFT\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore)\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic)\n            graftPeer(id, InclusionReason.Opportunistic)\n          }\n        }\n      }\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = Date.now()\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic)\n        this.fanoutLastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic)\n      fanoutPeers.forEach((id) => {\n        if (!(topicPeers?.has(id) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id)\n        }\n      })\n\n      const peersInTopic = this.topics.get(topic)\n      const candidateFanoutPeers = []\n      // the fanout map contains topics to which we are not subscribed.\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !fanoutPeers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (score >= this.opts.scoreThresholds.publishThreshold) candidateFanoutPeers.push(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // do we need more peers?\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size\n        candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n          fanoutPeers.add(id)\n          peersToGossip?.delete(id)\n        })\n      }\n    })\n\n    this.emitGossip(peersToGossipByTopic)\n\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    await this.sendGraftPrune(tograft, toprune, noPX)\n\n    // flush pending gossip that wasn't piggybacked above\n    this.flush()\n\n    // advance the message history window\n    this.mcache.shift()\n\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'))\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n  private getRandomGossipPeers (\n    topic: string,\n    count: number,\n    filter: (id: string) => boolean = () => true\n  ): Set<string> {\n    const peersInTopic = this.topics.get(topic)\n\n    if (peersInTopic == null) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers: string[] = []\n    peersInTopic.forEach((id) => {\n      const peerStreams = this.streamsOutbound.get(id)\n      if (peerStreams == null) {\n        return\n      }\n      if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = shuffle(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  private onScrapeMetrics (metrics: Metrics): void {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size)\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount)\n    // Arbitrary size\n    metrics.cacheSize.set({ cache: 'direct' }, this.direct.size)\n    metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size)\n    metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0)\n    metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size)\n    metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size)\n    metrics.cacheSize.set({ cache: 'score' }, this.score.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize)\n    // Bounded by topic\n    metrics.cacheSize.set({ cache: 'topics' }, this.topics.size)\n    metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size)\n    metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size)\n    metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size)\n    // Bounded by peer\n    metrics.cacheSize.set({ cache: 'peers' }, this.peers.size)\n    metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size)\n    metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size)\n    metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size)\n    metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size)\n    metrics.cacheSize.set({ cache: 'control' }, this.control.size)\n    metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size)\n    metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size)\n\n    // 2D nested data structure\n    let backoffSize = 0\n    const now = Date.now()\n    metrics.connectedPeersBackoffSec.reset()\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size\n      for (const [peer, expiredMs] of backoff.entries()) {\n        if (this.peers.has(peer)) {\n          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000)\n        }\n      }\n    }\n    metrics.cacheSize.set({ cache: 'backoff' }, backoffSize)\n\n    // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({ topicStr }, peers.size)\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({ topicStr }, peers.size)\n    }\n\n    // Peer scores\n\n    const scores: number[] = []\n    const scoreByPeer = new Map<PeerIdStr, number>()\n    metrics.behaviourPenalty.reset()\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr)\n      scores.push(score)\n      scoreByPeer.set(peerIdStr, score)\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0)\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds)\n\n    // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer)\n\n    // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(\n      this.peers.keys(),\n      this.score.peerStats,\n      this.score.params,\n      this.score.peerIPs,\n      metrics.topicStrToLabel\n    )\n\n    metrics.registerScoreWeights(sw)\n  }\n\n  private readonly tagMeshPeer = (evt: CustomEvent<MeshPeer>): void => {\n    const { peerId, topic } = evt.detail\n    this.components.peerStore.merge(peerIdFromString(peerId), {\n      tags: {\n        [topic]: {\n          value: 100\n        }\n      }\n    }).catch((err) => { this.log.error('Error tagging peer %s with topic %s', peerId, topic, err) })\n  }\n\n  private readonly untagMeshPeer = (evt: CustomEvent<MeshPeer>): void => {\n    const { peerId, topic } = evt.detail\n    this.components.peerStore.merge(peerIdFromString(peerId), {\n      tags: {\n        [topic]: undefined\n      }\n    }).catch((err) => { this.log.error('Error untagging peer %s with topic %s', peerId, topic, err) })\n  }\n}\n\nexport function gossipsub (\n  init: Partial<GossipsubOpts> = {}\n): (components: GossipSubComponents) => PubSub<GossipsubEvents> {\n  return (components: GossipSubComponents) => new GossipSub(components, init)\n}\n"],
  "mappings": "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",
  "names": ["Denque", "length", "length", "size", "message", "CODEC_TYPES", "encode", "decode", "encode", "decode", "CodeError", "message", "RPC", "SubOpts", "_codec", "length", "Message", "ControlMessage", "CodeError", "ControlIHave", "ControlIWant", "ControlGraft", "ControlPrune", "PeerInfo", "msgId", "message", "SignaturePolicy", "PublishConfigType", "RejectReason", "ValidateError", "MessageStatus", "MessageSource", "InclusionReason", "ChurnReason", "ScorePenalty", "IHaveIgnoreReason", "ScoreThreshold", "DeliveryRecordStatus", "Denque", "msgId", "msgId", "msgId", "Protocol", "GossipStatusCode", "multicodec", "subscriptions", "message", "msgId", "id"]
}
