import {
  PeerMap,
  PeerQueue,
  anySignal,
  createBloomFilter,
  peerFilter
} from "./chunk-52DUZ7B3.js";
import "./chunk-EUJIQQHS.js";
import "./chunk-E4JTUZPO.js";
import {
  CustomProgressEvent
} from "./chunk-VQNLKHIO.js";
import {
  pbStream
} from "./chunk-5OFRK2YN.js";
import {
  RecordEnvelope
} from "./chunk-OYIME3N6.js";
import "./chunk-GU5XU2O3.js";
import {
  peerIdFromBytes,
  peerIdFromString
} from "./chunk-UUNCSYGY.js";
import {
  CodeError as CodeError2,
  decodeMessage,
  encodeMessage,
  enumeration,
  message
} from "./chunk-VNQOKJMT.js";
import "./chunk-2F2YOVI2.js";
import {
  raceSignal
} from "./chunk-D35BF7SC.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  Circuit
} from "./chunk-IRS6632L.js";
import {
  multiaddr
} from "./chunk-QFZNCYMJ.js";
import "./chunk-XN2U5WYQ.js";
import "./chunk-62PHBWD2.js";
import {
  CodeError,
  TypedEventEmitter,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop,
  transportSymbol
} from "./chunk-N5EJSGOF.js";
import "./chunk-T6DLVMJJ.js";
import {
  alloc,
  equals
} from "./chunk-GHH3T6SM.js";

// node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var CIRCUIT_PROTO_CODE = 290;
var DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
var DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 1e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var RELAY_SOURCE_TAG = "circuit-relay-source";
var RELAY_TAG = "circuit-relay-relay";
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS = 300;
var ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL";
var ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED";
var ERR_TRANSFER_LIMIT_EXCEEDED = "ERR_TRANSFER_LIMIT_EXCEEDED";
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type;
  (function(Type2) {
    Type2["RESERVE"] = "RESERVE";
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type;
  (function(Type2) {
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          id: alloc(0),
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new CodeError2('decode error - map field "addrs" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          w.bytes(obj.voucher);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new CodeError2('decode error - map field "addrs" had too many elements', "ERR_MAX_LENGTH");
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf, opts) => {
    return decodeMessage(buf, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf, opts) => {
    return decodeMessage(buf, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          relay: alloc(0),
          peer: alloc(0),
          expiration: 0n
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf, opts) => {
    return decodeMessage(buf, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));

// node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
async function* countStreamBytes(source, limit, options) {
  const limitBytes = limit.remaining;
  for await (const buf of source) {
    const len = BigInt(buf.byteLength);
    if (limit.remaining - len < 0) {
      const remaining = Number(limit.remaining);
      limit.remaining = 0n;
      try {
        if (remaining !== 0) {
          yield buf.subarray(0, remaining);
        }
      } catch (err) {
        options.log.error(err);
      }
      throw new CodeError(`data limit of ${limitBytes} bytes exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED);
    }
    limit.remaining -= len;
    yield buf;
  }
}
function createLimitedRelay(src, dst, abortSignal, limit, options) {
  function abortStreams(err) {
    src.abort(err);
    dst.abort(err);
  }
  const signals = [abortSignal];
  if (limit?.duration != null) {
    signals.push(AbortSignal.timeout(limit.duration));
  }
  const signal = anySignal(signals);
  let srcDstFinished = false;
  let dstSrcFinished = false;
  let dataLimit;
  if (limit?.data != null) {
    dataLimit = {
      remaining: limit.data
    };
  }
  queueMicrotask(() => {
    const onAbort = () => {
      dst.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options)).catch((err) => {
      options.log.error("error while relaying streams src -> dst", err);
      abortStreams(err);
    }).finally(() => {
      srcDstFinished = true;
      if (dstSrcFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
  queueMicrotask(() => {
    const onAbort = () => {
      src.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options)).catch((err) => {
      options.log.error("error while relaying streams dst -> src", err);
      abortStreams(err);
    }).finally(() => {
      dstSrcFinished = true;
      if (srcDstFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-store.js
var ReservationStore = class {
  reservations = new PeerMap();
  _started = false;
  interval;
  maxReservations;
  reservationClearInterval;
  applyDefaultLimit;
  reservationTtl;
  defaultDurationLimit;
  defaultDataLimit;
  constructor(options = {}) {
    this.maxReservations = options.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
    this.reservationClearInterval = options.reservationClearInterval ?? DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL;
    this.applyDefaultLimit = options.applyDefaultLimit !== false;
    this.reservationTtl = options.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
    this.defaultDurationLimit = options.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
    this.defaultDataLimit = options.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
  }
  isStarted() {
    return this._started;
  }
  start() {
    if (this._started) {
      return;
    }
    this._started = true;
    this.interval = setInterval(() => {
      const now = (/* @__PURE__ */ new Date()).getTime();
      this.reservations.forEach((r, k) => {
        if (r.expire.getTime() < now) {
          this.reservations.delete(k);
        }
      });
    }, this.reservationClearInterval);
  }
  stop() {
    clearInterval(this.interval);
  }
  reserve(peer, addr, limit) {
    if (this.reservations.size >= this.maxReservations && !this.reservations.has(peer)) {
      return { status: Status.RESERVATION_REFUSED };
    }
    const expire = new Date(Date.now() + this.reservationTtl);
    let checkedLimit;
    if (this.applyDefaultLimit) {
      checkedLimit = limit ?? { data: this.defaultDataLimit, duration: this.defaultDurationLimit };
    }
    this.reservations.set(peer, { addr, expire, limit: checkedLimit });
    return { status: Status.OK, expire: Math.round(expire.getTime() / 1e3) };
  }
  removeReservation(peer) {
    this.reservations.delete(peer);
  }
  hasReservation(dst) {
    return this.reservations.has(dst);
  }
  get(peer) {
    return this.reservations.get(peer);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-voucher.js
var ReservationVoucherRecord = class _ReservationVoucherRecord {
  domain = "libp2p-relay-rsvp";
  codec = new Uint8Array([3, 2]);
  relay;
  peer;
  expiration;
  constructor({ relay, peer, expiration }) {
    this.relay = relay;
    this.peer = peer;
    this.expiration = expiration;
  }
  marshal() {
    return ReservationVoucher.encode({
      relay: this.relay.toBytes(),
      peer: this.peer.toBytes(),
      expiration: BigInt(this.expiration)
    });
  }
  equals(other) {
    if (!(other instanceof _ReservationVoucherRecord)) {
      return false;
    }
    if (!this.peer.equals(other.peer)) {
      return false;
    }
    if (!this.relay.equals(other.relay)) {
      return false;
    }
    if (this.expiration !== other.expiration) {
      return false;
    }
    return true;
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/index.js
var isRelayAddr = (ma) => ma.protoCodes().includes(CIRCUIT_PROTO_CODE);
var defaults = {
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var CircuitRelayServer = class extends TypedEventEmitter {
  registrar;
  peerStore;
  addressManager;
  peerId;
  connectionManager;
  connectionGater;
  reservationStore;
  started;
  hopTimeout;
  shutdownController;
  maxInboundHopStreams;
  maxOutboundHopStreams;
  maxOutboundStopStreams;
  log;
  /**
   * Creates an instance of Relay
   */
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:server");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.addressManager = components.addressManager;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.connectionGater = components.connectionGater;
    this.started = false;
    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT;
    this.maxInboundHopStreams = init.maxInboundHopStreams;
    this.maxOutboundHopStreams = init.maxOutboundHopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.reservationStore = new ReservationStore(init.reservations);
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-server";
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.started) {
      return;
    }
    await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {
      void this.onHop(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundHopStreams,
      maxOutboundStreams: this.maxOutboundHopStreams,
      runOnTransientConnection: true
    });
    this.reservationStore.start();
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    this.reservationStore.stop();
    this.shutdownController.abort();
    await this.registrar.unhandle(RELAY_V2_HOP_CODEC);
    this.started = false;
  }
  async onHop({ connection, stream }) {
    this.log("received circuit v2 hop protocol stream from %p", connection.remotePeer);
    const hopTimeoutPromise = pDefer();
    const timeout = setTimeout(() => {
      hopTimeoutPromise.reject("timed out");
    }, this.hopTimeout);
    const pbstr = pbStream(stream);
    try {
      const request = await Promise.race([
        pbstr.pb(HopMessage).read(),
        hopTimeoutPromise.promise
      ]);
      if (request?.type == null) {
        throw new Error("request was invalid, could not read from stream");
      }
      this.log("received", request.type);
      await Promise.race([
        this.handleHopProtocol({
          connection,
          stream: pbstr,
          request
        }),
        hopTimeoutPromise.promise
      ]);
    } catch (err) {
      this.log.error("error while handling hop", err);
      await pbstr.pb(HopMessage).write({
        type: HopMessage.Type.STATUS,
        status: Status.MALFORMED_MESSAGE
      });
      stream.abort(err);
    } finally {
      clearTimeout(timeout);
    }
  }
  async handleHopProtocol({ stream, request, connection }) {
    this.log("received hop message");
    switch (request.type) {
      case HopMessage.Type.RESERVE:
        await this.handleReserve({ stream, request, connection });
        break;
      case HopMessage.Type.CONNECT:
        await this.handleConnect({ stream, request, connection });
        break;
      default: {
        this.log.error("invalid hop request type %s via peer %p", request.type, connection.remotePeer);
        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      }
    }
  }
  async handleReserve({ stream, request, connection }) {
    const hopstr = stream.pb(HopMessage);
    this.log("hop reserve request from %p", connection.remotePeer);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    if (await this.connectionGater.denyInboundRelayReservation?.(connection.remotePeer) === true) {
      this.log.error("reservation for %p denied by connection gater", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
    if (result.status !== Status.OK) {
      await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status });
      return;
    }
    try {
      if (result.expire != null) {
        const ttl = result.expire * 1e3 - Date.now();
        await this.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: { value: 1, ttl }
          }
        });
      }
      await hopstr.write({
        type: HopMessage.Type.STATUS,
        status: Status.OK,
        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
        limit: this.reservationStore.get(connection.remotePeer)?.limit
      });
      this.log("sent confirmation response to %s", connection.remotePeer);
    } catch (err) {
      this.log.error("failed to send confirmation response to %p", connection.remotePeer, err);
      this.reservationStore.removeReservation(connection.remotePeer);
    }
  }
  async makeReservation(remotePeer, expire) {
    const addrs = [];
    for (const relayAddr of this.addressManager.getAddresses()) {
      if (relayAddr.toString().includes("/p2p-circuit")) {
        continue;
      }
      addrs.push(relayAddr.bytes);
    }
    const voucher = await RecordEnvelope.seal(new ReservationVoucherRecord({
      peer: remotePeer,
      relay: this.peerId,
      expiration: Number(expire)
    }), this.peerId);
    return {
      addrs,
      expire,
      voucher: voucher.marshal()
    };
  }
  async handleConnect({ stream, request, connection }) {
    const hopstr = stream.pb(HopMessage);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    this.log("hop connect request from %p", connection.remotePeer);
    let dstPeer;
    try {
      if (request.peer == null) {
        this.log.error("no peer info in hop connect request");
        throw new Error("no peer info in request");
      }
      request.peer.addrs.forEach(multiaddr);
      dstPeer = peerIdFromBytes(request.peer.id);
    } catch (err) {
      this.log.error("invalid hop connect request via peer %p %s", connection.remotePeer, err);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE });
      return;
    }
    if (!this.reservationStore.hasReservation(dstPeer)) {
      this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s", dstPeer, connection.remotePeer, Status.NO_RESERVATION);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
      return;
    }
    if (await this.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer) === true) {
      this.log.error("hop connect for %p to %p denied by connection gater", connection.remotePeer, dstPeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    const connections = this.connectionManager.getConnections(dstPeer);
    if (connections.length === 0) {
      this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection", dstPeer, connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
      return;
    }
    const limit = this.reservationStore.get(dstPeer)?.limit;
    const destinationConnection = connections[0];
    const destinationStream = await this.stopHop({
      connection: destinationConnection,
      request: {
        type: StopMessage.Type.CONNECT,
        peer: {
          id: connection.remotePeer.toBytes(),
          addrs: []
        },
        limit
      }
    });
    if (destinationStream == null) {
      this.log.error("failed to open stream to destination peer %p", destinationConnection?.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED });
      return;
    }
    await hopstr.write({
      type: HopMessage.Type.STATUS,
      status: Status.OK,
      limit
    });
    const sourceStream = stream.unwrap();
    this.log("connection from %p to %p established - merging streams", connection.remotePeer, dstPeer);
    createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, limit, {
      log: this.log
    });
  }
  /**
   * Send a STOP request to the target peer that the dialing peer wants to contact
   */
  async stopHop({ connection, request }) {
    this.log("starting circuit relay v2 stop request to %s", connection.remotePeer);
    const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnTransientConnection: true
    });
    const pbstr = pbStream(stream);
    const stopstr = pbstr.pb(StopMessage);
    await stopstr.write(request);
    let response;
    try {
      response = await stopstr.read();
    } catch (err) {
      this.log.error("error parsing stop message response from %p", connection.remotePeer);
    }
    if (response == null) {
      this.log.error("could not read response from %p", connection.remotePeer);
      await stream.close();
      return;
    }
    if (response.status === Status.OK) {
      this.log("stop request to %p was successful", connection.remotePeer);
      return pbstr.unwrap();
    }
    this.log("stop request failed with code %d", response.status);
    await stream.close();
  }
  get reservations() {
    return this.reservationStore.reservations;
  }
};
function circuitRelayServer(init = {}) {
  return (components) => {
    return new CircuitRelayServer(components, init);
  };
}

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
function streamToMaConnection(props) {
  const { stream, remoteAddr, logger } = props;
  const log = logger.forComponent("libp2p:stream:converter");
  let closedRead = false;
  let closedWrite = false;
  const streamClose = stream.close.bind(stream);
  stream.close = async (options) => {
    await streamClose(options);
    close(true);
  };
  const streamAbort = stream.abort.bind(stream);
  stream.abort = (err) => {
    streamAbort(err);
    close(true);
  };
  const streamSink = stream.sink.bind(stream);
  stream.sink = async (source) => {
    try {
      await streamSink(source);
    } catch (err) {
      if (err.type !== "aborted") {
        log.error("%s error in sink", remoteAddr, err);
      }
    } finally {
      closedWrite = true;
      close();
    }
  };
  const maConn = {
    log,
    sink: stream.sink,
    source: async function* () {
      try {
        for await (const list of stream.source) {
          if (list instanceof Uint8Array) {
            yield list;
          } else {
            yield* list;
          }
        }
      } finally {
        closedRead = true;
        close();
      }
    }(),
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    close: stream.close,
    abort: stream.abort
  };
  function close(force) {
    if (force === true) {
      closedRead = true;
      closedWrite = true;
    }
    if (closedRead && closedWrite && maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }
  return maConn;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  peerStore;
  registrar;
  connectionManager;
  randomWalk;
  started;
  running;
  topologyId;
  log;
  discoveryController;
  filter;
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.started = false;
    this.running = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.connectionManager = components.connectionManager;
    this.randomWalk = components.randomWalk;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId) => {
        this.log("discovered relay %p", peerId);
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.discoveryController?.abort();
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    Promise.resolve().then(async () => {
      this.log("searching peer store for relays");
      const peers = await this.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          () => Math.random() < 0.5 ? 1 : -1
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (this.connectionManager.getConnections(peer.id)?.length > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        this.log.trace("wait for space in queue for %p", peer.id);
        await raceSignal(queue.onSizeLessThan(10), this.discoveryController.signal);
        this.log("adding random peer %p to dial queue (length: %d)", peer.id, queue.size);
        queue.add(async () => {
          const signal = anySignal([this.discoveryController.signal, AbortSignal.timeout(5e3)]);
          setMaxListeners(Infinity, signal);
          try {
            await this.connectionManager.openConnection(peer.id, { signal });
          } finally {
            signal.clear();
          }
        }, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p", peer.id, err);
        });
      }
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network", err);
      }
    });
  }
  stopDiscovery() {
    this.log("stop discovery");
    this.running = false;
    this.discoveryController?.abort();
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  connectionManager;
  relayStore;
  listeningAddrs;
  log;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.relayStore = components.relayStore;
    this.listeningAddrs = new PeerMap();
    this.relayStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
  }
  _onRemoveRelayPeer = (evt) => {
    this.#removeRelayPeer(evt.detail);
  };
  async listen(addr) {
    this.log("listen on %a", addr);
    const relayAddr = addr.decapsulate("/p2p-circuit");
    const relayConn = await this.connectionManager.openConnection(relayAddr);
    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
      this.log("making reservation on peer %p", relayConn.remotePeer);
      await this.relayStore.addRelay(relayConn.remotePeer, "configured");
      return;
    }
    const reservation = this.relayStore.getReservation(relayConn.remotePeer);
    if (reservation == null) {
      throw new CodeError("Did not have reservation after making reservation", "ERR_NO_RESERVATION");
    }
    if (this.listeningAddrs.has(relayConn.remotePeer)) {
      this.log("already listening on relay %p", relayConn.remotePeer);
      return;
    }
    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map((buf) => {
      return multiaddr(buf).encapsulate("/p2p-circuit");
    }));
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  async close() {
  }
  #removeRelayPeer(peerId) {
    const had = this.listeningAddrs.has(peerId);
    this.log("relay peer removed %p - had reservation", peerId, had);
    this.listeningAddrs.delete(peerId);
    if (had) {
      this.log.trace("removing relay event listener for peer %p", peerId);
      this.relayStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
      this.safeDispatchEvent("close", {});
    }
  }
};
function createListener(options) {
  return new CircuitRelayTransportListener(options);
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore2 = class extends TypedEventEmitter {
  peerId;
  connectionManager;
  transportManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  maxDiscoveredRelays;
  maxReservationQueueLength;
  reservationCompletionTimeout;
  started;
  log;
  relayFilter;
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.maxDiscoveredRelays = init?.discoverRelays ?? 0;
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createBloomFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("peer:disconnect", (evt) => {
      this.#removeRelay(evt.detail);
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    if (this.reservations.size < this.maxDiscoveredRelays) {
      this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log("not trying to use self as relay");
      return;
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      this.log("not adding potential relay peer %p as the queue is full", peerId);
      return;
    }
    if (this.reserveQueue.has(peerId)) {
      this.log("potential relay peer %p is already in the reservation queue", peerId);
      return;
    }
    if (this.relayFilter.has(peerId.toBytes())) {
      this.log("potential relay peer %p has failed previously, not trying again", peerId);
      return;
    }
    this.log("try to reserve relay slot with %p", peerId);
    await this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have reservation on relay peer %p and it expires in more than 10 minutes", peerId);
            return;
          }
          clearTimeout(existingReservation.timeout);
          this.reservations.delete(peerId);
        }
        if (type === "discovered" && [...this.reservations.values()].reduce((acc, curr) => {
          if (curr.type === "discovered") {
            acc++;
          }
          return acc;
        }, 0) >= this.maxDiscoveredRelays) {
          this.log("already have enough discovered relays");
          return;
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (connection.remoteAddr.protoNames().includes("p2p-circuit")) {
          this.log("not creating reservation over relayed connection");
          return;
        }
        const reservation = await this.#createReservation(connection, {
          signal
        });
        this.log("created reservation on relay peer %p", peerId);
        const expiration = getExpirationMilliseconds(reservation.expire);
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.addRelay(peerId, type).catch((err) => {
            this.log.error("could not refresh reservation to relay %p", peerId, err);
          });
        }, timeoutDuration);
        this.reservations.set(peerId, {
          timeout,
          reservation,
          type
        });
        await this.peerStore.merge(peerId, {
          tags: {
            [RELAY_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)]);
        this.safeDispatchEvent("relay:created-reservation", {
          detail: peerId
        });
      } catch (err) {
        this.log.error("could not reserve slot on %p after %dms", peerId, Date.now() - start2, err);
        const reservation = this.reservations.get(peerId);
        if (reservation != null) {
          clearTimeout(reservation.timeout);
        }
        this.reservations.delete(peerId);
        this.relayFilter.add(peerId.toBytes());
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    return this.reservations.get(peerId)?.reservation;
  }
  reservationCount() {
    return this.reservations.size;
  }
  async #createReservation(connection, options) {
    options.signal?.throwIfAborted();
    this.log("requesting reservation from %p", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    await hopstr.write({ type: HopMessage.Type.RESERVE }, options);
    let response;
    try {
      response = await hopstr.read(options);
    } catch (err) {
      stream.abort(err);
      throw err;
    } finally {
      if (stream.status !== "closed") {
        await stream.close(options);
      }
    }
    if (response.status === Status.OK && response.reservation != null) {
      let hasRelayAddress = false;
      const relayAddressBytes = connection.remoteAddr.bytes;
      for (const buf of response.reservation.addrs) {
        if (equals(relayAddressBytes, buf)) {
          hasRelayAddress = true;
          break;
        }
      }
      if (!hasRelayAddress) {
        response.reservation.addrs.push(relayAddressBytes);
      }
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    this.log.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  #removeRelay(peerId) {
    const existingReservation = this.reservations.get(peerId);
    if (existingReservation == null) {
      return;
    }
    this.log("connection to relay %p closed, removing reservation from local store", peerId);
    clearTimeout(existingReservation.timeout);
    this.reservations.delete(peerId);
    this.safeDispatchEvent("relay:removed", { detail: peerId });
    if (this.reservations.size < this.maxDiscoveredRelays) {
      this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/transport.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults2 = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var CircuitRelayTransport = class {
  discovery;
  registrar;
  peerStore;
  connectionManager;
  transportManager;
  peerId;
  upgrader;
  addressManager;
  connectionGater;
  reservationStore;
  logger;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  stopTimeout;
  started;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults2.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults2.maxOutboundStopStreams;
    this.stopTimeout = init.stopTimeout ?? defaults2.stopTimeout;
    const discoverRelays = init.discoverRelays ?? 0;
    if (discoverRelays > 0) {
      this.discovery = new RelayDiscovery(components, {
        filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
      });
      this.discovery.addEventListener("relay:discover", (evt) => {
        this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
          this.log.error("could not add discovered relay %p", evt.detail, err);
        });
      });
    }
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:created-reservation", () => {
      if (this.reservationStore.reservationCount() >= discoverRelays) {
        this.discovery?.stopDiscovery();
      }
    });
    this.started = false;
  }
  [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
  [serviceCapabilities] = [
    "@libp2p/transport",
    "@libp2p/circuit-relay-v2-transport"
  ];
  get [serviceDependencies]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  [transportSymbol] = true;
  isStarted() {
    return this.started;
  }
  async start() {
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      void this.onStop(data).catch((err) => {
        this.log.error("error while handling STOP protocol", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnTransientConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    await stop(this.discovery, this.reservationStore);
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options) {
    if (ma.protoCodes().filter((code) => code === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      this.log.error(errMsg, ma);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;
      this.log.error(errMsg);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      options.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    } else {
      options.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      options.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC);
      return await this.connectV2({
        stream,
        connection: relayConnection,
        destinationPeer,
        destinationAddr,
        relayAddr,
        ma,
        disconnectOnFailure,
        onProgress: options.onProgress
      });
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
      if (stream != null) {
        stream.abort(err);
      }
      disconnectOnFailure && await relayConnection.close();
      throw err;
    }
  }
  async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure, onProgress }) {
    try {
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toBytes(),
          addrs: [multiaddr(destinationAddr).bytes]
        }
      });
      onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read();
      if (status.status !== Status.OK) {
        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`, ERR_HOP_REQUEST_FAILED);
      }
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
        logger: this.logger
      });
      this.log("new outbound relayed connection %a", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn, {
        transient: status.limit != null,
        onProgress
      });
    } catch (err) {
      this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);
      disconnectOnFailure && await connection.close();
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    return createListener({
      connectionManager: this.connectionManager,
      relayStore: this.reservationStore,
      logger: this.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }) {
    if (!this.reservationStore.hasReservation(connection.remotePeer)) {
      try {
        this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
        await this.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
      } catch (err) {
        this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
      }
    }
    const signal = AbortSignal.timeout(this.stopTimeout);
    const pbstr = pbStream(stream).pb(StopMessage);
    const request = await pbstr.read({
      signal
    });
    this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
    if (request?.type === void 0) {
      this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (request.type !== StopMessage.Type.CONNECT) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (!isValidStop(request)) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    const remotePeerId = peerIdFromBytes(request.peer.id);
    if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
      this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
        signal
      });
      await stream.close();
      return;
    }
    this.log.trace("sending success response to %p", connection.remotePeer);
    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
      signal
    });
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap().unwrap(),
      remoteAddr,
      localAddr,
      logger: this.logger
    });
    this.log("new inbound relayed connection %a", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn, {
      transient: request.limit != null
    });
    this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}
export {
  RELAY_V2_HOP_CODEC,
  RELAY_V2_STOP_CODEC,
  circuitRelayServer,
  circuitRelayTransport
};
//# sourceMappingURL=@libp2p_circuit-relay-v2.js.map
